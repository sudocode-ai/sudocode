{"id":"ISSUE-001","uuid":"6a41fb64-d043-415d-911d-76f2536795f4","title":"Server: Project Initialization & Basic Express Setup","description":"Set up the basic TypeScript + Express project structure for the sudocode backend server.\n\n## Tasks\n- [ ] Create `server/` directory structure\n- [ ] Initialize `package.json` with dependencies (express, typescript, etc.)\n- [ ] Create `tsconfig.json` for TypeScript configuration\n- [ ] Set up basic Express app in `src/index.ts`\n- [ ] Add development scripts (dev, build, start)\n- [ ] Create `.env.example` for environment variables\n- [ ] Create `.gitignore` with appropriate entries\n\n## Files to Create\n```\nserver/\n├── src/\n│   └── index.ts          # Basic Express app\n├── package.json\n├── tsconfig.json\n├── .env.example\n└── .gitignore\n```\n\n## Verification\n- Server should start on http://localhost:3001\n- GET http://localhost:3001/health should return 200\n- `npm run dev` should start the server successfully\n\n## Success Criteria\nExpress server that starts successfully with a health check endpoint.\n\nReference: [[server/server_plan.md]] - Phase 1, Step 1.1","content":"\n","status":"closed","priority":0,"assignee":null,"created_at":"2025-10-24 09:53:37","updated_at":"2025-10-24 10:18:01","closed_at":"2025-10-24 10:18:01","parent_id":null,"relationships":[],"tags":["foundation","phase-1","server","setup"]}
{"id":"ISSUE-002","uuid":"326b22be-f823-4cf9-a281-c774cb6742cc","title":"Server: Database Setup & Schema Implementation","description":"Initialize SQLite database with schema for sudocode server.\n\n## Tasks\n- [ ] Create `src/services/db.ts` with database connection\n- [ ] Import schema from `../cli/src/schema.ts`\n- [ ] Add new tables for projects, issue_attempts, execution_processes\n- [ ] Add execution_process_logs table\n- [ ] Write database initialization function\n- [ ] Add database migration logic\n- [ ] Create helper functions for common queries\n\n## Files to Create\n```\nserver/src/\n├── services/\n│   └── db.ts             # Database connection & init\n└── types/\n    └── extended.ts       # Extended types (Project, IssueAttempt, etc.)\n```\n\n## Schema Additions\n- Projects table\n- Issue attempts table\n- Execution processes table\n- Execution process logs table\n\n## Verification\n- Run server with `npm run dev`\n- Database should be created at `server/sudocode.db`\n- All tables should be created successfully\n- Can query tables with sqlite3\n\n## Success Criteria\nWorking SQLite database with all required tables.\n\nReference: [[server/server_plan.md]] - Phase 1, Step 1.2","content":"\n","status":"closed","priority":0,"assignee":null,"created_at":"2025-10-24 09:53:37","updated_at":"2025-10-24 10:18:01","closed_at":"2025-10-24 10:18:01","parent_id":null,"relationships":[],"tags":["database","phase-1","schema","server"]}
{"id":"ISSUE-003","uuid":"827d2fb6-ce4d-4889-a53f-d93688057825","title":"Server: Read Issues from JSONL","description":"Load and serve issues from issues.jsonl file.\n\n## Tasks\n- [ ] Create `src/services/jsonl.ts` for JSONL operations\n- [ ] Implement `readIssuesJsonl(path)` function\n- [ ] Implement `parseIssueJsonl(line)` function\n- [ ] Create `src/services/issues.ts` for issue business logic\n- [ ] Create `src/routes/issues.ts` for issue routes\n- [ ] Implement GET `/api/tasks` (list issues)\n- [ ] Implement GET `/api/tasks/:id` (get issue by ID)\n- [ ] Add request validation and error handling\n\n## Files to Create\n```\nserver/src/\n├── routes/\n│   └── issues.ts         # Issue routes (mapped to /tasks)\n└── services/\n    ├── jsonl.ts          # JSONL read/write operations\n    └── issues.ts         # Issue business logic\n```\n\n## JSONL Operations\n```typescript\nexport async function readIssuesJsonl(path: string): Promise<IssueJSONL[]>\nexport async function writeIssuesJsonl(path: string, issues: IssueJSONL[]): Promise<void>\nexport function parseJsonlLine<T>(line: string): T | null\n```\n\n## API Response Format\n```typescript\ninterface ApiResponse<T> {\n  success: boolean\n  data: T | null\n  error_data?: any\n  message?: string\n}\n```\n\n## Verification\n```bash\ncurl http://localhost:3002/api/tasks\n# Should return issues from .sudocode/issues.jsonl\n\ncurl http://localhost:3002/api/tasks/ISSUE-001\n# Should return specific issue\n```\n\n## Success Criteria\nRead-only issues API that loads from JSONL files.\n\nReference: [[server/server_plan.md]] - Phase 3, Step 3.1","content":"\n","status":"closed","priority":0,"assignee":null,"created_at":"2025-10-24 10:09:13","updated_at":"2025-10-24 10:24:51","closed_at":"2025-10-24 10:24:51","parent_id":null,"relationships":[],"tags":["api","issues","phase-3","server"]}
{"id":"ISSUE-004","uuid":"ac4048e7-32c5-424f-a7c7-23dde7909c9c","title":"Server: Sync Issues to SQLite Cache","description":"Load JSONL data into SQLite for fast queries. The CLI already maintains the cache.db, so the server should read from the existing database.\n\n## Tasks\n- [ ] Update issues service to read from SQLite instead of JSONL\n- [ ] Implement `getIssues()` to query from database\n- [ ] Implement `getIssueById(id)` to query from database\n- [ ] Handle relationships and tags from database\n- [ ] Add indexes for common queries if not already present\n- [ ] Update GET endpoints to read from SQLite\n- [ ] Handle case when database is not synced (warn user)\n\n## Database Queries\n```typescript\nexport async function getIssues(filters?: IssueFilters): Promise<Issue[]>\nexport async function getIssueById(id: string): Promise<Issue | null>\nexport async function getIssueRelationships(id: string): Promise<Relationship[]>\nexport async function getIssueTags(id: string): Promise<string[]>\n```\n\n## Verification\n```bash\n# Ensure CLI has synced data first\nsudocode sync\n\n# Start server\nnpm run dev\n\n# Query via API\ncurl http://localhost:3002/api/tasks\n# Should return issues from SQLite\n\n# Check database directly\nsqlite3 .sudocode/cache.db \"SELECT COUNT(*) FROM issues;\"\n```\n\n## Success Criteria\nIssues loaded from SQLite cache maintained by CLI, with fast query performance.\n\nReference: [[server/server_plan.md]] - Phase 3, Step 3.2","content":"\n","status":"closed","priority":0,"assignee":null,"created_at":"2025-10-24 10:09:14","updated_at":"2025-10-24 16:55:50","closed_at":"2025-10-24 16:55:50","parent_id":null,"relationships":[],"tags":["database","issues","phase-3","server"]}
{"id":"ISSUE-005","uuid":"68030861-d410-4baf-b1dc-36f486862c5a","title":"Server: Create & Update Issues via API","description":"Implement write operations for issues, delegating to CLI operations for JSONL consistency.\n\n## Tasks\n- [ ] Implement POST `/api/tasks` (create issue)\n- [ ] Implement PUT `/api/tasks/:id` (update issue)\n- [ ] Use CLI operations from `@sudocode/cli` for consistency\n- [ ] Add request validation with Zod schemas\n- [ ] Handle validation errors gracefully\n- [ ] Return updated issue in response\n- [ ] Trigger sync after write operations\n\n## Integration with CLI\n```typescript\nimport { createIssue, updateIssue } from '@sudocode/cli/operations/issues'\n\nexport async function createIssueService(data: CreateIssueRequest): Promise<Issue> {\n  // Use CLI operation to create in JSONL\n  const issue = await createIssue(db, data)\n  \n  // CLI handles JSONL and SQLite sync\n  return issue\n}\n```\n\n## Request Validation\n```typescript\nconst createIssueSchema = z.object({\n  title: z.string().min(1).max(500),\n  description: z.string(),\n  status: z.enum(['open', 'in_progress', 'blocked', 'needs_review', 'closed']),\n  priority: z.number().min(0).max(4).optional(),\n  assignee: z.string().optional(),\n  tags: z.array(z.string()).optional(),\n})\n```\n\n## Verification\n```bash\n# Create new issue\ncurl -X POST http://localhost:3002/api/tasks \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"title\": \"Test Issue\", \"description\": \"Test\", \"status\": \"open\"}'\n\n# Update issue\ncurl -X PUT http://localhost:3002/api/tasks/ISSUE-001 \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"status\": \"in_progress\"}'\n\n# Check issues.jsonl updated\ncat .sudocode/issues.jsonl | tail -1\n```\n\n## Success Criteria\nFull create and update operations for issues with JSONL persistence via CLI.\n\nReference: [[server/server_plan.md]] - Phase 3, Step 3.3","content":"\n","status":"closed","priority":0,"assignee":null,"created_at":"2025-10-24 10:09:14","updated_at":"2025-10-24 17:23:50","closed_at":"2025-10-24 17:23:50","parent_id":null,"relationships":[],"tags":["api","crud","issues","phase-3","server"]}
{"id":"ISSUE-006","uuid":"5952bd3f-1731-4aa9-9ee0-3023570b8c75","title":"Server: Delete Issues via API","description":"Implement issue deletion with proper cascade handling.\n\n## Tasks\n- [ ] Implement DELETE `/api/tasks/:id`\n- [ ] Use CLI delete operation for consistency\n- [ ] Handle cascade deletion of relationships and tags\n- [ ] Add soft delete option (status='closed') as alternative\n- [ ] Return success response with deleted issue ID\n- [ ] Add confirmation requirement for destructive operations\n\n## Delete Operations\n```typescript\nexport async function deleteIssueService(id: string, soft: boolean = false): Promise<void> {\n  if (soft) {\n    // Soft delete: just close the issue\n    await updateIssue(db, id, { status: 'closed', closed_at: new Date().toISOString() })\n  } else {\n    // Hard delete: remove from JSONL and database\n    await deleteIssue(db, id)\n  }\n}\n```\n\n## API Design\n```typescript\n// Hard delete\nDELETE /api/tasks/:id\n\n// Soft delete (close)\nPUT /api/tasks/:id\n{ \"status\": \"closed\" }\n```\n\n## Verification\n```bash\n# Soft delete (close issue)\ncurl -X PUT http://localhost:3002/api/tasks/ISSUE-001 \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"status\": \"closed\"}'\n\n# Hard delete\ncurl -X DELETE http://localhost:3002/api/tasks/ISSUE-001\n\n# Verify removed from JSONL and SQLite\ncat .sudocode/issues.jsonl | grep ISSUE-001\n# Should return nothing\n\nsqlite3 .sudocode/cache.db \"SELECT * FROM issues WHERE id='ISSUE-001';\"\n# Should return nothing\n```\n\n## Success Criteria\nComplete CRUD operations for issues with both hard and soft delete options.\n\nReference: [[server/server_plan.md]] - Phase 3, Step 3.4","content":"\n","status":"closed","priority":0,"assignee":null,"created_at":"2025-10-24 10:09:14","updated_at":"2025-10-24 17:33:04","closed_at":"2025-10-24 17:33:04","parent_id":null,"relationships":[],"tags":["api","crud","issues","phase-3","server"]}
{"id":"ISSUE-007","uuid":"bff23a82-fea5-45e4-8519-ef2b01c1004c","title":"Server: Read Specs from JSONL","description":"Load and serve specs from specs.jsonl file, following the same pattern as the Issues API.\n\n## Tasks\n- [ ] Create `src/routes/specs.ts` for spec routes\n- [ ] Create `src/services/specs.ts` wrapping CLI operations\n- [ ] Implement GET `/api/specs` (list specs)\n- [ ] Implement GET `/api/specs/:id` (get spec by ID)\n- [ ] Use CLI operations from `@sudocode/cli` for consistency\n- [ ] Support filtering and pagination\n- [ ] Include relationships in response\n\n## Files to Create\n```\nserver/src/\n├── routes/\n│   └── specs.ts         # Spec routes (mapped to /api/specs)\n└── services/\n    └── specs.ts         # Spec business logic (wraps CLI)\n```\n\n## Integration with CLI\n```typescript\nimport { getSpec, listSpecs } from '@sudocode/cli/dist/operations/index.js'\n\nexport function getAllSpecs(db: Database.Database, options?: ListSpecsOptions): Spec[] {\n  return listSpecs(db, options || {})\n}\n\nexport function getSpecById(db: Database.Database, id: string): Spec | null {\n  return getSpec(db, id)\n}\n```\n\n## API Response Format\nSame as issues API:\n```typescript\ninterface ApiResponse<T> {\n  success: boolean\n  data: T | null\n  error_data?: any\n  message?: string\n}\n```\n\n## Verification\n```bash\ncurl http://localhost:3002/api/specs\n# Should return specs from SQLite\n\ncurl http://localhost:3002/api/specs/SPEC-001\n# Should return specific spec\n```\n\n## Success Criteria\nRead-only specs API that delegates to CLI operations, following the same patterns as Issues API.\n\nReference: [[server/server_plan.md]] - Phase 4, Step 4.1","content":"","status":"closed","priority":0,"assignee":null,"created_at":"2025-10-24 17:50:33","updated_at":"2025-10-24 18:04:49","closed_at":"2025-10-24 18:04:49","parent_id":null,"relationships":[],"tags":[]}
{"id":"ISSUE-008","uuid":"eccab6c9-845c-4271-9c2e-f436ec4247e7","title":"Server: Specs CRUD Operations","description":"Implement full create, update, and delete operations for specs via API.\n\n## Tasks\n- [ ] Implement POST `/api/specs` (create spec)\n- [ ] Implement PUT `/api/specs/:id` (update spec)\n- [ ] Implement DELETE `/api/specs/:id` (delete spec)\n- [ ] Use CLI operations from `@sudocode/cli` for consistency\n- [ ] Add request validation\n- [ ] Handle validation errors gracefully\n- [ ] Return created/updated spec in response\n- [ ] Add comprehensive tests for all CRUD operations\n\n## Integration with CLI\n```typescript\nimport { createSpec, updateSpec, deleteSpec } from '@sudocode/cli/dist/operations/index.js'\n\nexport function createNewSpec(db: Database.Database, input: CreateSpecInput): Spec {\n  return createSpec(db, input)\n}\n\nexport function updateExistingSpec(db: Database.Database, id: string, input: UpdateSpecInput): Spec {\n  return updateSpec(db, id, input)\n}\n\nexport function deleteExistingSpec(db: Database.Database, id: string): boolean {\n  return deleteSpec(db, id)\n}\n```\n\n## Request Validation\n- Title: required, max 500 characters\n- Content: optional markdown content\n- Priority: 0-4, default 2\n- Parent ID: optional, must exist if provided\n\n## Verification\n```bash\n# Create new spec\ncurl -X POST http://localhost:3002/api/specs \\\\\n  -H \"Content-Type: application/json\" \\\\\n  -d '{\"title\": \"Test Spec\", \"content\": \"# Spec content\"}'\n\n# Update spec\ncurl -X PUT http://localhost:3002/api/specs/SPEC-001 \\\\\n  -H \"Content-Type: application/json\" \\\\\n  -d '{\"content\": \"# Updated content\"}'\n\n# Delete spec\ncurl -X DELETE http://localhost:3002/api/specs/SPEC-001\n\n# Run tests\nnpm test\n```\n\n## Success Criteria\nFull CRUD operations for specs with CLI delegation and comprehensive test coverage.\n\nReference: [[server/server_plan.md]] - Phase 4, Step 4.2","content":"","status":"closed","priority":0,"assignee":null,"created_at":"2025-10-24 17:50:34","updated_at":"2025-10-24 18:13:32","closed_at":"2025-10-24 18:13:32","parent_id":null,"relationships":[],"tags":[]}
{"id":"ISSUE-009","uuid":"e3e058f4-d8b5-4260-b0a3-27fee8a7aa2c","title":"Server: Relationships API","description":"Manage relationships between issues and specs via REST API.\n\n## Tasks\n- [ ] Create `src/routes/relationships.ts` for relationship routes\n- [ ] Create `src/services/relationships.ts` wrapping CLI operations\n- [ ] Implement GET `/api/relationships?entity_id=X&entity_type=issue`\n- [ ] Implement POST `/api/relationships` (create relationship)\n- [ ] Implement DELETE `/api/relationships` (delete relationship)\n- [ ] Use CLI operations from `@sudocode/cli` for consistency\n- [ ] Add request validation\n- [ ] Add comprehensive tests\n\n## Integration with CLI\n```typescript\nimport { \n  getRelationships, \n  createRelationship, \n  deleteRelationship \n} from '@sudocode/cli/dist/operations/index.js'\n\nexport function getEntityRelationships(\n  db: Database.Database, \n  entityId: string, \n  entityType: EntityType\n): Relationship[] {\n  return getRelationships(db, entityId, entityType)\n}\n```\n\n## API Endpoints\n- `GET /api/relationships?entity_id=X&entity_type=issue` - Get relationships for entity\n- `POST /api/relationships` - Create relationship\n  ```json\n  {\n    \"from_id\": \"ISSUE-001\",\n    \"from_type\": \"issue\",\n    \"to_id\": \"SPEC-001\",\n    \"to_type\": \"spec\",\n    \"type\": \"implements\"\n  }\n  ```\n- `DELETE /api/relationships` - Delete relationship (same body as POST)\n\n## Relationship Types\n- `blocks` - Entity blocks another\n- `implements` - Issue implements spec\n- `references` - Entity references another\n- `depends-on` - Entity depends on another\n- `discovered-from` - Issue discovered from spec\n- `related` - Generic relationship\n\n## Verification\n```bash\n# Get relationships for an issue\ncurl http://localhost:3002/api/relationships?entity_id=ISSUE-001&entity_type=issue\n\n# Create relationship\ncurl -X POST http://localhost:3002/api/relationships \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"from_id\": \"ISSUE-001\", \"from_type\": \"issue\", \"to_id\": \"SPEC-001\", \"to_type\": \"spec\", \"type\": \"implements\"}'\n\n# Delete relationship\ncurl -X DELETE http://localhost:3002/api/relationships \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"from_id\": \"ISSUE-001\", \"from_type\": \"issue\", \"to_id\": \"SPEC-001\", \"to_type\": \"spec\", \"type\": \"implements\"}'\n```\n\n## Success Criteria\nRelationship management API with CLI delegation and full test coverage.\n\nReference: [[server/server_plan.md]] - Phase 5, Step 5.1","content":"","status":"closed","priority":0,"assignee":null,"created_at":"2025-10-24 18:16:41","updated_at":"2025-10-24 18:29:03","closed_at":"2025-10-24 18:29:03","parent_id":null,"relationships":[],"tags":[]}
{"id":"ISSUE-010","uuid":"79a841f8-d7df-4f2a-b5bb-3a4d2849fdef","title":"Server: Feedback API","description":"Manage issue feedback on specs via REST API.\n\n## Tasks\n- [ ] Create `src/routes/feedback.ts` for feedback routes\n- [ ] Create `src/services/feedback.ts` wrapping CLI operations\n- [ ] Implement GET `/api/feedback?spec_id=X` (list feedback for spec)\n- [ ] Implement GET `/api/feedback/:id` (get specific feedback)\n- [ ] Implement POST `/api/feedback` (add feedback)\n- [ ] Implement PUT `/api/feedback/:id` (update feedback)\n- [ ] Implement DELETE `/api/feedback/:id` (delete feedback)\n- [ ] Handle feedback anchors (line numbers, text snippets, section headings)\n- [ ] Use CLI operations from `@sudocode/cli` for consistency\n- [ ] Add request validation\n- [ ] Add comprehensive tests\n\n## Integration with CLI\n```typescript\nimport { \n  getFeedback, \n  createFeedback, \n  updateFeedback, \n  deleteFeedback \n} from '@sudocode/cli/dist/operations/index.js'\n\nexport function getSpecFeedback(\n  db: Database.Database, \n  specId: string\n): Feedback[] {\n  return getFeedback(db, specId)\n}\n```\n\n## API Endpoints\n- `GET /api/feedback?spec_id=SPEC-001` - List feedback for a spec\n- `GET /api/feedback/:id` - Get specific feedback\n- `POST /api/feedback` - Create feedback\n  ```json\n  {\n    \"issue_id\": \"ISSUE-001\",\n    \"spec_id\": \"SPEC-001\",\n    \"type\": \"comment\",\n    \"content\": \"Great spec!\",\n    \"anchor\": {\n      \"section_heading\": \"Overview\",\n      \"line_number\": 42,\n      \"text_snippet\": \"some text\",\n      \"anchor_status\": \"valid\"\n    }\n  }\n  ```\n- `PUT /api/feedback/:id` - Update feedback\n- `DELETE /api/feedback/:id` - Delete feedback\n\n## Feedback Types\n- `comment` - General comment\n- `suggestion` - Suggestion for improvement\n- `request` - Request for clarification\n\n## Feedback Anchor\n```typescript\ninterface FeedbackAnchor {\n  section_heading?: string\n  line_number?: number\n  text_snippet?: string\n  anchor_status: 'valid' | 'relocated' | 'stale'\n}\n```\n\n## Verification\n```bash\n# Get feedback for spec\ncurl http://localhost:3002/api/feedback?spec_id=SPEC-001\n\n# Create feedback\ncurl -X POST http://localhost:3002/api/feedback \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"issue_id\": \"ISSUE-001\", \"spec_id\": \"SPEC-001\", \"type\": \"comment\", \"content\": \"Nice work!\", \"anchor\": {\"line_number\": 10, \"anchor_status\": \"valid\"}}'\n\n# Update feedback\ncurl -X PUT http://localhost:3002/api/feedback/fb-123 \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"content\": \"Updated comment\"}'\n\n# Delete feedback\ncurl -X DELETE http://localhost:3002/api/feedback/fb-123\n\n# Run tests\nnpm test\n```\n\n## Success Criteria\nFeedback management API with anchor support, CLI delegation, and full test coverage.\n\nReference: [[server/server_plan.md]] - Phase 5, Step 5.2","content":"","status":"closed","priority":0,"assignee":null,"created_at":"2025-10-24 18:17:04","updated_at":"2025-10-24 18:36:33","closed_at":"2025-10-24 18:36:33","parent_id":null,"relationships":[],"tags":[]}
{"id":"ISSUE-011","uuid":"0022dc0e-75e9-4e4b-842f-65cafcd74217","title":"Server: File Watcher Setup","description":"Watch JSONL files for external changes and trigger database sync.\n\n## Tasks\n- [ ] Create `src/services/watcher.ts` for file watching\n- [ ] Use `chokidar` to watch issues.jsonl and specs.jsonl\n- [ ] Debounce file change events (avoid multiple rapid syncs)\n- [ ] Trigger database sync on file change\n- [ ] Handle file rename/delete events\n- [ ] Add watcher to server startup\n\n## Implementation Details\n\nUse chokidar to watch for file system changes:\n```typescript\nimport chokidar from 'chokidar'\n\nexport function startFileWatcher(jsonlPath: string) {\n  const watcher = chokidar.watch([\n    `${jsonlPath}/issues.jsonl`,\n    `${jsonlPath}/specs.jsonl`,\n  ], {\n    persistent: true,\n    ignoreInitial: true,\n  })\n\n  watcher.on('change', debounce((path) => {\n    console.log(`File changed: ${path}`)\n    if (path.includes('issues.jsonl')) {\n      syncIssuesToDb(path)\n      broadcastIssueUpdate()\n    } else if (path.includes('specs.jsonl')) {\n      syncSpecsToDb(path)\n      broadcastSpecUpdate()\n    }\n  }, 1000))\n}\n```\n\n## Verification\n```bash\n# Start server\nnpm run dev\n\n# Manually edit .sudocode/issues.jsonl\n# Server logs should show \"File changed: issues.jsonl\"\n# Database should be re-synced\n```\n\n## Dependencies\n- chokidar package\n- Existing sync functions from CLI\n\n## Success Criteria\nAutomatic database sync when JSONL files change externally.\n\nReference: [[server/server_plan.md]] - Phase 6, Step 6.1","content":"","status":"in_progress","priority":1,"assignee":null,"created_at":"2025-10-24 18:41:25","updated_at":"2025-10-24 19:38:01","closed_at":null,"parent_id":null,"relationships":[],"tags":[]}
{"id":"ISSUE-012","uuid":"803e1739-35ba-4bd6-924a-b70f34d10cf4","title":"Server: WebSocket Server Setup","description":"Set up WebSocket server for real-time client updates.\n\n## Tasks\n- [ ] Create `src/services/websocket.ts` for WebSocket management\n- [ ] Initialize WebSocket server with `ws` library\n- [ ] Handle client connections and disconnections\n- [ ] Implement connection management (track clients)\n- [ ] Add heartbeat/ping-pong to detect dead connections\n- [ ] Implement subscription system (clients subscribe to projects/entities)\n- [ ] Integrate with Express server\n\n## Implementation Details\n\nWebSocket server setup:\n```typescript\nimport { WebSocketServer, WebSocket } from 'ws'\n\ninterface Client {\n  id: string\n  ws: WebSocket\n  subscriptions: string[]  // e.g., ['project:uuid', 'issue:ISSUE-001']\n}\n\nconst clients = new Map<string, Client>()\n\nexport function initWebSocketServer(server: http.Server) {\n  const wss = new WebSocketServer({ server, path: '/ws' })\n\n  wss.on('connection', (ws, req) => {\n    const clientId = generateId()\n    clients.set(clientId, { id: clientId, ws, subscriptions: [] })\n\n    ws.on('message', (data) => {\n      const message = JSON.parse(data.toString())\n      handleClientMessage(clientId, message)\n    })\n\n    ws.on('close', () => {\n      clients.delete(clientId)\n    })\n\n    // Heartbeat\n    ws.on('pong', () => {\n      client.isAlive = true\n    })\n  })\n\n  // Check for dead connections every 30s\n  setInterval(() => {\n    clients.forEach((client) => {\n      if (!client.isAlive) {\n        client.ws.terminate()\n        clients.delete(client.id)\n        return\n      }\n      client.isAlive = false\n      client.ws.ping()\n    })\n  }, 30000)\n}\n```\n\n## Message Protocol\n\nClient -> Server:\n```json\n{\n  \"type\": \"subscribe\",\n  \"entity_type\": \"issue\",\n  \"entity_id\": \"ISSUE-001\"\n}\n```\n\nServer -> Client:\n```json\n{\n  \"type\": \"issue_updated\",\n  \"data\": { \"id\": \"ISSUE-001\", ... }\n}\n```\n\n## Verification\n```bash\n# Use wscat to test\nnpm install -g wscat\nwscat -c ws://localhost:3002/ws\n# Should connect successfully\n> {\"type\": \"ping\"}\n# Should receive pong\n```\n\n## Dependencies\n- ws package\n- uuid for client IDs\n\n## Success Criteria\nWebSocket server accepting and managing client connections with heartbeat.\n\nReference: [[server/server_plan.md]] - Phase 6, Step 6.2","content":"","status":"open","priority":1,"assignee":null,"created_at":"2025-10-24 18:41:26","updated_at":"2025-10-24 18:41:26","closed_at":null,"parent_id":null,"relationships":[],"tags":[]}
{"id":"ISSUE-013","uuid":"7089f51c-758f-44fd-8183-a886b4876b7f","title":"Server: Real-Time Issue Updates","description":"Broadcast issue changes to connected WebSocket clients in real-time.\n\n## Tasks\n- [ ] Implement issue update broadcasting in `src/services/websocket.ts`\n- [ ] Broadcast updates on issue CRUD operations\n- [ ] Broadcast updates when file watcher detects changes\n- [ ] Add filtering (only send to subscribed clients)\n- [ ] Support subscription to specific issues or all issues\n- [ ] Handle different update types (created/updated/deleted)\n\n## Implementation Details\n\nBroadcasting logic:\n```typescript\nexport function broadcastIssueUpdate(\n  issue: Issue,\n  type: 'created' | 'updated' | 'deleted'\n) {\n  const message = {\n    type: `issue_${type}`,\n    data: issue,\n    timestamp: new Date().toISOString(),\n  }\n\n  clients.forEach((client) => {\n    const subscribed = client.subscriptions.some(sub => \n      sub === 'issues:all' || \n      sub === `issue:${issue.id}` ||\n      (issue.project_id && sub === `project:${issue.project_id}`)\n    )\n    \n    if (subscribed) {\n      client.ws.send(JSON.stringify(message))\n    }\n  })\n}\n```\n\nIntegration points:\n1. Call from routes after CRUD operations\n2. Call from file watcher on external changes\n3. Support filtering by project_id\n\n## Message Types\n\n- `issue_created` - New issue created\n- `issue_updated` - Issue modified\n- `issue_deleted` - Issue removed\n\n## Verification\n```bash\n# Connect with wscat\nwscat -c ws://localhost:3002/ws\n> {\"type\": \"subscribe\", \"entity_type\": \"issues\"}\n\n# In another terminal, create an issue\ncurl -X POST http://localhost:3002/api/issues -d '{\"title\": \"Test\"}'\n\n# wscat should receive update message\n< {\"type\": \"issue_created\", \"data\": {...}}\n```\n\n## Integration\n- Modify `src/routes/issues.ts` to call broadcast functions\n- Connect with file watcher from ISSUE-011\n\n## Success Criteria\nConnected clients receive real-time updates when issues change.\n\nReference: [[server/server_plan.md]] - Phase 6, Step 6.3","content":"","status":"open","priority":1,"assignee":null,"created_at":"2025-10-24 18:41:26","updated_at":"2025-10-24 18:41:26","closed_at":null,"parent_id":null,"relationships":[],"tags":[]}
{"id":"ISSUE-014","uuid":"916d44ca-42fa-4af9-a2a3-3aea6499ec9b","title":"Server: Real-Time Spec Updates","description":"Broadcast spec changes to connected WebSocket clients in real-time.\n\n## Tasks\n- [ ] Implement spec update broadcasting in `src/services/websocket.ts`\n- [ ] Broadcast updates on spec CRUD operations\n- [ ] Broadcast updates when file watcher detects changes\n- [ ] Add filtering (only send to subscribed clients)\n- [ ] Support subscription to specific specs or all specs\n- [ ] Handle different update types (created/updated/deleted)\n\n## Implementation Details\n\nBroadcasting logic:\n```typescript\nexport function broadcastSpecUpdate(\n  spec: Spec,\n  type: 'created' | 'updated' | 'deleted'\n) {\n  const message = {\n    type: `spec_${type}`,\n    data: spec,\n    timestamp: new Date().toISOString(),\n  }\n\n  clients.forEach((client) => {\n    const subscribed = client.subscriptions.some(sub => \n      sub === 'specs:all' || \n      sub === `spec:${spec.id}` ||\n      (spec.project_id && sub === `project:${spec.project_id}`)\n    )\n    \n    if (subscribed) {\n      client.ws.send(JSON.stringify(message))\n    }\n  })\n}\n```\n\nIntegration points:\n1. Call from routes after CRUD operations\n2. Call from file watcher on external changes\n3. Support filtering by project_id\n\n## Message Types\n\n- `spec_created` - New spec created\n- `spec_updated` - Spec modified\n- `spec_deleted` - Spec removed\n\n## Verification\n```bash\n# Connect with wscat\nwscat -c ws://localhost:3002/ws\n> {\"type\": \"subscribe\", \"entity_type\": \"specs\"}\n\n# In another terminal, create a spec\ncurl -X POST http://localhost:3002/api/specs -d '{\"title\": \"Test Spec\"}'\n\n# wscat should receive update message\n< {\"type\": \"spec_created\", \"data\": {...}}\n```\n\n## Integration\n- Modify `src/routes/specs.ts` to call broadcast functions\n- Connect with file watcher from ISSUE-011\n- Consider broadcasting relationship and feedback updates\n\n## Success Criteria\nConnected clients receive real-time updates when specs change.\n\nReference: [[server/server_plan.md]] - Phase 6, Step 6.4","content":"","status":"open","priority":1,"assignee":null,"created_at":"2025-10-24 18:41:27","updated_at":"2025-10-24 18:41:27","closed_at":null,"parent_id":null,"relationships":[],"tags":[]}
{"id":"ISSUE-015","uuid":"0483ddd8-d2ff-4d22-8f5a-4d4ddbbfc925","title":"Import should preserve timestamps from JSONL","description":"When importing from JSONL, updateIssue/updateSpec always generate new updated_at timestamps. This causes JSONL files to be modified even when content hasn't changed, breaking the bidirectional sync content-matching optimization.","content":"","status":"closed","priority":1,"assignee":null,"created_at":"2025-10-24 21:16:59","updated_at":"2025-10-24 21:35:58","closed_at":"2025-10-24 21:35:58","parent_id":null,"relationships":[],"tags":[]}
