{"id":"ISSUE-001","uuid":"6a41fb64-d043-415d-911d-76f2536795f4","title":"Server: Project Initialization & Basic Express Setup","content":"Set up the basic TypeScript + Express project structure for the sudocode backend server.\n\n## Tasks\n- [ ] Create `server/` directory structure\n- [ ] Initialize `package.json` with dependencies (express, typescript, etc.)\n- [ ] Create `tsconfig.json` for TypeScript configuration\n- [ ] Set up basic Express app in `src/index.ts`\n- [ ] Add development scripts (dev, build, start)\n- [ ] Create `.env.example` for environment variables\n- [ ] Create `.gitignore` with appropriate entries\n\n## Files to Create\n```\nserver/\n├── src/\n│   └── index.ts          # Basic Express app\n├── package.json\n├── tsconfig.json\n├── .env.example\n└── .gitignore\n```\n\n## Verification\n- Server should start on http://localhost:3001\n- GET http://localhost:3001/health should return 200\n- `npm run dev` should start the server successfully\n\n## Success Criteria\nExpress server that starts successfully with a health check endpoint.\n\nReference: [[server/server_plan.md]] - Phase 1, Step 1.1","status":"closed","priority":0,"assignee":null,"archived":1,"archived_at":"2025-10-28T19:15:21.036Z","created_at":"2025-10-24 09:53:37","updated_at":"2025-10-28 19:15:21","closed_at":"2025-10-28 19:03:00","parent_id":null,"relationships":[],"tags":["foundation","phase-1","server","setup"]}
{"id":"ISSUE-002","uuid":"326b22be-f823-4cf9-a281-c774cb6742cc","title":"Server: Database Setup & Schema Implementation","content":"Initialize SQLite database with schema for sudocode server.\n\n## Tasks\n- [ ] Create `src/services/db.ts` with database connection\n- [ ] Import schema from `../cli/src/schema.ts`\n- [ ] Add new tables for projects, issue_attempts, execution_processes\n- [ ] Add execution_process_logs table\n- [ ] Write database initialization function\n- [ ] Add database migration logic\n- [ ] Create helper functions for common queries\n\n## Files to Create\n```\nserver/src/\n├── services/\n│   └── db.ts             # Database connection & init\n└── types/\n    └── extended.ts       # Extended types (Project, IssueAttempt, etc.)\n```\n\n## Schema Additions\n- Projects table\n- Issue attempts table\n- Execution processes table\n- Execution process logs table\n\n## Verification\n- Run server with `npm run dev`\n- Database should be created at `server/sudocode.db`\n- All tables should be created successfully\n- Can query tables with sqlite3\n\n## Success Criteria\nWorking SQLite database with all required tables.\n\nReference: [[server/server_plan.md]] - Phase 1, Step 1.2","status":"closed","priority":0,"assignee":null,"archived":1,"archived_at":"2025-10-28T19:15:21.095Z","created_at":"2025-10-24 09:53:37","updated_at":"2025-10-28 19:15:21","closed_at":"2025-10-24 10:18:01","parent_id":null,"relationships":[],"tags":["database","phase-1","schema","server"]}
{"id":"ISSUE-003","uuid":"827d2fb6-ce4d-4889-a53f-d93688057825","title":"Server: Read Issues from JSONL","content":"Load and serve issues from issues.jsonl file.\n\n## Tasks\n- [ ] Create `src/services/jsonl.ts` for JSONL operations\n- [ ] Implement `readIssuesJsonl(path)` function\n- [ ] Implement `parseIssueJsonl(line)` function\n- [ ] Create `src/services/issues.ts` for issue business logic\n- [ ] Create `src/routes/issues.ts` for issue routes\n- [ ] Implement GET `/api/tasks` (list issues)\n- [ ] Implement GET `/api/tasks/:id` (get issue by ID)\n- [ ] Add request validation and error handling\n\n## Files to Create\n```\nserver/src/\n├── routes/\n│   └── issues.ts         # Issue routes (mapped to /tasks)\n└── services/\n    ├── jsonl.ts          # JSONL read/write operations\n    └── issues.ts         # Issue business logic\n```\n\n## JSONL Operations\n```typescript\nexport async function readIssuesJsonl(path: string): Promise<IssueJSONL[]>\nexport async function writeIssuesJsonl(path: string, issues: IssueJSONL[]): Promise<void>\nexport function parseJsonlLine<T>(line: string): T | null\n```\n\n## API Response Format\n```typescript\ninterface ApiResponse<T> {\n  success: boolean\n  data: T | null\n  error_data?: any\n  message?: string\n}\n```\n\n## Verification\n```bash\ncurl http://localhost:3002/api/tasks\n# Should return issues from .sudocode/issues.jsonl\n\ncurl http://localhost:3002/api/tasks/ISSUE-001\n# Should return specific issue\n```\n\n## Success Criteria\nRead-only issues API that loads from JSONL files.\n\nReference: [[server/server_plan.md]] - Phase 3, Step 3.1","status":"closed","priority":0,"assignee":null,"archived":1,"archived_at":"2025-10-28T19:15:21.092Z","created_at":"2025-10-24 10:09:13","updated_at":"2025-10-28 19:15:21","closed_at":"2025-10-24 10:24:51","parent_id":null,"relationships":[],"tags":["api","issues","phase-3","server"]}
{"id":"ISSUE-004","uuid":"ac4048e7-32c5-424f-a7c7-23dde7909c9c","title":"Server: Sync Issues to SQLite Cache","content":"Load JSONL data into SQLite for fast queries. The CLI already maintains the cache.db, so the server should read from the existing database.\n\n## Tasks\n- [ ] Update issues service to read from SQLite instead of JSONL\n- [ ] Implement `getIssues()` to query from database\n- [ ] Implement `getIssueById(id)` to query from database\n- [ ] Handle relationships and tags from database\n- [ ] Add indexes for common queries if not already present\n- [ ] Update GET endpoints to read from SQLite\n- [ ] Handle case when database is not synced (warn user)\n\n## Database Queries\n```typescript\nexport async function getIssues(filters?: IssueFilters): Promise<Issue[]>\nexport async function getIssueById(id: string): Promise<Issue | null>\nexport async function getIssueRelationships(id: string): Promise<Relationship[]>\nexport async function getIssueTags(id: string): Promise<string[]>\n```\n\n## Verification\n```bash\n# Ensure CLI has synced data first\nsudocode sync\n\n# Start server\nnpm run dev\n\n# Query via API\ncurl http://localhost:3002/api/tasks\n# Should return issues from SQLite\n\n# Check database directly\nsqlite3 .sudocode/cache.db \"SELECT COUNT(*) FROM issues;\"\n```\n\n## Success Criteria\nIssues loaded from SQLite cache maintained by CLI, with fast query performance.\n\nReference: [[server/server_plan.md]] - Phase 3, Step 3.2","status":"closed","priority":0,"assignee":null,"archived":1,"archived_at":"2025-10-28T19:15:21.091Z","created_at":"2025-10-24 10:09:14","updated_at":"2025-10-28 19:15:21","closed_at":"2025-10-24 16:55:50","parent_id":null,"relationships":[],"tags":["database","issues","phase-3","server"]}
{"id":"ISSUE-005","uuid":"68030861-d410-4baf-b1dc-36f486862c5a","title":"Server: Create & Update Issues via API","content":"Implement write operations for issues, delegating to CLI operations for JSONL consistency.\n\n## Tasks\n- [ ] Implement POST `/api/tasks` (create issue)\n- [ ] Implement PUT `/api/tasks/:id` (update issue)\n- [ ] Use CLI operations from `@sudocode/cli` for consistency\n- [ ] Add request validation with Zod schemas\n- [ ] Handle validation errors gracefully\n- [ ] Return updated issue in response\n- [ ] Trigger sync after write operations\n\n## Integration with CLI\n```typescript\nimport { createIssue, updateIssue } from '@sudocode/cli/operations/issues'\n\nexport async function createIssueService(data: CreateIssueRequest): Promise<Issue> {\n  // Use CLI operation to create in JSONL\n  const issue = await createIssue(db, data)\n  \n  // CLI handles JSONL and SQLite sync\n  return issue\n}\n```\n\n## Request Validation\n```typescript\nconst createIssueSchema = z.object({\n  title: z.string().min(1).max(500),\n  description: z.string(),\n  status: z.enum(['open', 'in_progress', 'blocked', 'needs_review', 'closed']),\n  priority: z.number().min(0).max(4).optional(),\n  assignee: z.string().optional(),\n  tags: z.array(z.string()).optional(),\n})\n```\n\n## Verification\n```bash\n# Create new issue\ncurl -X POST http://localhost:3002/api/tasks \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"title\": \"Test Issue\", \"description\": \"Test\", \"status\": \"open\"}'\n\n# Update issue\ncurl -X PUT http://localhost:3002/api/tasks/ISSUE-001 \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"status\": \"in_progress\"}'\n\n# Check issues.jsonl updated\ncat .sudocode/issues.jsonl | tail -1\n```\n\n## Success Criteria\nFull create and update operations for issues with JSONL persistence via CLI.\n\nReference: [[server/server_plan.md]] - Phase 3, Step 3.3","status":"closed","priority":0,"assignee":null,"archived":1,"archived_at":"2025-10-28T19:15:21.090Z","created_at":"2025-10-24 10:09:14","updated_at":"2025-10-28 19:15:21","closed_at":"2025-10-24 17:23:50","parent_id":null,"relationships":[],"tags":["api","crud","issues","phase-3","server"]}
{"id":"ISSUE-006","uuid":"5952bd3f-1731-4aa9-9ee0-3023570b8c75","title":"Server: Delete Issues via API","content":"Implement issue deletion with proper cascade handling.\n\n## Tasks\n- [ ] Implement DELETE `/api/tasks/:id`\n- [ ] Use CLI delete operation for consistency\n- [ ] Handle cascade deletion of relationships and tags\n- [ ] Add soft delete option (status='closed') as alternative\n- [ ] Return success response with deleted issue ID\n- [ ] Add confirmation requirement for destructive operations\n\n## Delete Operations\n```typescript\nexport async function deleteIssueService(id: string, soft: boolean = false): Promise<void> {\n  if (soft) {\n    // Soft delete: just close the issue\n    await updateIssue(db, id, { status: 'closed', closed_at: new Date().toISOString() })\n  } else {\n    // Hard delete: remove from JSONL and database\n    await deleteIssue(db, id)\n  }\n}\n```\n\n## API Design\n```typescript\n// Hard delete\nDELETE /api/tasks/:id\n\n// Soft delete (close)\nPUT /api/tasks/:id\n{ \"status\": \"closed\" }\n```\n\n## Verification\n```bash\n# Soft delete (close issue)\ncurl -X PUT http://localhost:3002/api/tasks/ISSUE-001 \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"status\": \"closed\"}'\n\n# Hard delete\ncurl -X DELETE http://localhost:3002/api/tasks/ISSUE-001\n\n# Verify removed from JSONL and SQLite\ncat .sudocode/issues.jsonl | grep ISSUE-001\n# Should return nothing\n\nsqlite3 .sudocode/cache.db \"SELECT * FROM issues WHERE id='ISSUE-001';\"\n# Should return nothing\n```\n\n## Success Criteria\nComplete CRUD operations for issues with both hard and soft delete options.\n\nReference: [[server/server_plan.md]] - Phase 3, Step 3.4","status":"closed","priority":0,"assignee":null,"archived":1,"archived_at":"2025-10-28T19:15:21.089Z","created_at":"2025-10-24 10:09:14","updated_at":"2025-10-28 19:15:21","closed_at":"2025-10-24 17:33:04","parent_id":null,"relationships":[],"tags":["api","crud","issues","phase-3","server"]}
{"id":"ISSUE-007","uuid":"bff23a82-fea5-45e4-8519-ef2b01c1004c","title":"Server: Read Specs from JSONL","content":"Load and serve specs from specs.jsonl file, following the same pattern as the Issues API.\n\n## Tasks\n- [ ] Create `src/routes/specs.ts` for spec routes\n- [ ] Create `src/services/specs.ts` wrapping CLI operations\n- [ ] Implement GET `/api/specs` (list specs)\n- [ ] Implement GET `/api/specs/:id` (get spec by ID)\n- [ ] Use CLI operations from `@sudocode/cli` for consistency\n- [ ] Support filtering and pagination\n- [ ] Include relationships in response\n\n## Files to Create\n```\nserver/src/\n├── routes/\n│   └── specs.ts         # Spec routes (mapped to /api/specs)\n└── services/\n    └── specs.ts         # Spec business logic (wraps CLI)\n```\n\n## Integration with CLI\n```typescript\nimport { getSpec, listSpecs } from '@sudocode/cli/dist/operations/index.js'\n\nexport function getAllSpecs(db: Database.Database, options?: ListSpecsOptions): Spec[] {\n  return listSpecs(db, options || {})\n}\n\nexport function getSpecById(db: Database.Database, id: string): Spec | null {\n  return getSpec(db, id)\n}\n```\n\n## API Response Format\nSame as issues API:\n```typescript\ninterface ApiResponse<T> {\n  success: boolean\n  data: T | null\n  error_data?: any\n  message?: string\n}\n```\n\n## Verification\n```bash\ncurl http://localhost:3002/api/specs\n# Should return specs from SQLite\n\ncurl http://localhost:3002/api/specs/SPEC-001\n# Should return specific spec\n```\n\n## Success Criteria\nRead-only specs API that delegates to CLI operations, following the same patterns as Issues API.\n\nReference: [[server/server_plan.md]] - Phase 4, Step 4.1","status":"closed","priority":0,"assignee":null,"archived":1,"archived_at":"2025-10-28T19:15:21.088Z","created_at":"2025-10-24 17:50:33","updated_at":"2025-10-28 19:15:21","closed_at":"2025-10-24 18:04:49","parent_id":null,"relationships":[],"tags":[]}
{"id":"ISSUE-008","uuid":"eccab6c9-845c-4271-9c2e-f436ec4247e7","title":"Server: Specs CRUD Operations","content":"Implement full create, update, and delete operations for specs via API.\n\n## Tasks\n- [ ] Implement POST `/api/specs` (create spec)\n- [ ] Implement PUT `/api/specs/:id` (update spec)\n- [ ] Implement DELETE `/api/specs/:id` (delete spec)\n- [ ] Use CLI operations from `@sudocode/cli` for consistency\n- [ ] Add request validation\n- [ ] Handle validation errors gracefully\n- [ ] Return created/updated spec in response\n- [ ] Add comprehensive tests for all CRUD operations\n\n## Integration with CLI\n```typescript\nimport { createSpec, updateSpec, deleteSpec } from '@sudocode/cli/dist/operations/index.js'\n\nexport function createNewSpec(db: Database.Database, input: CreateSpecInput): Spec {\n  return createSpec(db, input)\n}\n\nexport function updateExistingSpec(db: Database.Database, id: string, input: UpdateSpecInput): Spec {\n  return updateSpec(db, id, input)\n}\n\nexport function deleteExistingSpec(db: Database.Database, id: string): boolean {\n  return deleteSpec(db, id)\n}\n```\n\n## Request Validation\n- Title: required, max 500 characters\n- Content: optional markdown content\n- Priority: 0-4, default 2\n- Parent ID: optional, must exist if provided\n\n## Verification\n```bash\n# Create new spec\ncurl -X POST http://localhost:3002/api/specs \\\\\n  -H \"Content-Type: application/json\" \\\\\n  -d '{\"title\": \"Test Spec\", \"content\": \"# Spec content\"}'\n\n# Update spec\ncurl -X PUT http://localhost:3002/api/specs/SPEC-001 \\\\\n  -H \"Content-Type: application/json\" \\\\\n  -d '{\"content\": \"# Updated content\"}'\n\n# Delete spec\ncurl -X DELETE http://localhost:3002/api/specs/SPEC-001\n\n# Run tests\nnpm test\n```\n\n## Success Criteria\nFull CRUD operations for specs with CLI delegation and comprehensive test coverage.\n\nReference: [[server/server_plan.md]] - Phase 4, Step 4.2","status":"closed","priority":0,"assignee":null,"archived":1,"archived_at":"2025-10-28T19:15:21.087Z","created_at":"2025-10-24 17:50:34","updated_at":"2025-10-28 19:15:21","closed_at":"2025-10-24 18:13:32","parent_id":null,"relationships":[],"tags":[]}
{"id":"ISSUE-009","uuid":"e3e058f4-d8b5-4260-b0a3-27fee8a7aa2c","title":"Server: Relationships API","content":"Manage relationships between issues and specs via REST API.\n\n## Tasks\n- [ ] Create `src/routes/relationships.ts` for relationship routes\n- [ ] Create `src/services/relationships.ts` wrapping CLI operations\n- [ ] Implement GET `/api/relationships?entity_id=X&entity_type=issue`\n- [ ] Implement POST `/api/relationships` (create relationship)\n- [ ] Implement DELETE `/api/relationships` (delete relationship)\n- [ ] Use CLI operations from `@sudocode/cli` for consistency\n- [ ] Add request validation\n- [ ] Add comprehensive tests\n\n## Integration with CLI\n```typescript\nimport { \n  getRelationships, \n  createRelationship, \n  deleteRelationship \n} from '@sudocode/cli/dist/operations/index.js'\n\nexport function getEntityRelationships(\n  db: Database.Database, \n  entityId: string, \n  entityType: EntityType\n): Relationship[] {\n  return getRelationships(db, entityId, entityType)\n}\n```\n\n## API Endpoints\n- `GET /api/relationships?entity_id=X&entity_type=issue` - Get relationships for entity\n- `POST /api/relationships` - Create relationship\n  ```json\n  {\n    \"from_id\": \"ISSUE-001\",\n    \"from_type\": \"issue\",\n    \"to_id\": \"SPEC-001\",\n    \"to_type\": \"spec\",\n    \"type\": \"implements\"\n  }\n  ```\n- `DELETE /api/relationships` - Delete relationship (same body as POST)\n\n## Relationship Types\n- `blocks` - Entity blocks another\n- `implements` - Issue implements spec\n- `references` - Entity references another\n- `depends-on` - Entity depends on another\n- `discovered-from` - Issue discovered from spec\n- `related` - Generic relationship\n\n## Verification\n```bash\n# Get relationships for an issue\ncurl http://localhost:3002/api/relationships?entity_id=ISSUE-001&entity_type=issue\n\n# Create relationship\ncurl -X POST http://localhost:3002/api/relationships \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"from_id\": \"ISSUE-001\", \"from_type\": \"issue\", \"to_id\": \"SPEC-001\", \"to_type\": \"spec\", \"type\": \"implements\"}'\n\n# Delete relationship\ncurl -X DELETE http://localhost:3002/api/relationships \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"from_id\": \"ISSUE-001\", \"from_type\": \"issue\", \"to_id\": \"SPEC-001\", \"to_type\": \"spec\", \"type\": \"implements\"}'\n```\n\n## Success Criteria\nRelationship management API with CLI delegation and full test coverage.\n\nReference: [[server/server_plan.md]] - Phase 5, Step 5.1","status":"closed","priority":0,"assignee":null,"archived":1,"archived_at":"2025-10-28T19:15:21.087Z","created_at":"2025-10-24 18:16:41","updated_at":"2025-10-28 19:15:21","closed_at":"2025-10-24 18:29:03","parent_id":null,"relationships":[],"tags":[]}
{"id":"ISSUE-010","uuid":"79a841f8-d7df-4f2a-b5bb-3a4d2849fdef","title":"Server: Feedback API","content":"Manage issue feedback on specs via REST API.\n\n## Tasks\n- [ ] Create `src/routes/feedback.ts` for feedback routes\n- [ ] Create `src/services/feedback.ts` wrapping CLI operations\n- [ ] Implement GET `/api/feedback?spec_id=X` (list feedback for spec)\n- [ ] Implement GET `/api/feedback/:id` (get specific feedback)\n- [ ] Implement POST `/api/feedback` (add feedback)\n- [ ] Implement PUT `/api/feedback/:id` (update feedback)\n- [ ] Implement DELETE `/api/feedback/:id` (delete feedback)\n- [ ] Handle feedback anchors (line numbers, text snippets, section headings)\n- [ ] Use CLI operations from `@sudocode/cli` for consistency\n- [ ] Add request validation\n- [ ] Add comprehensive tests\n\n## Integration with CLI\n```typescript\nimport { \n  getFeedback, \n  createFeedback, \n  updateFeedback, \n  deleteFeedback \n} from '@sudocode/cli/dist/operations/index.js'\n\nexport function getSpecFeedback(\n  db: Database.Database, \n  specId: string\n): Feedback[] {\n  return getFeedback(db, specId)\n}\n```\n\n## API Endpoints\n- `GET /api/feedback?spec_id=SPEC-001` - List feedback for a spec\n- `GET /api/feedback/:id` - Get specific feedback\n- `POST /api/feedback` - Create feedback\n  ```json\n  {\n    \"issue_id\": \"ISSUE-001\",\n    \"spec_id\": \"SPEC-001\",\n    \"type\": \"comment\",\n    \"content\": \"Great spec!\",\n    \"anchor\": {\n      \"section_heading\": \"Overview\",\n      \"line_number\": 42,\n      \"text_snippet\": \"some text\",\n      \"anchor_status\": \"valid\"\n    }\n  }\n  ```\n- `PUT /api/feedback/:id` - Update feedback\n- `DELETE /api/feedback/:id` - Delete feedback\n\n## Feedback Types\n- `comment` - General comment\n- `suggestion` - Suggestion for improvement\n- `request` - Request for clarification\n\n## Feedback Anchor\n```typescript\ninterface FeedbackAnchor {\n  section_heading?: string\n  line_number?: number\n  text_snippet?: string\n  anchor_status: 'valid' | 'relocated' | 'stale'\n}\n```\n\n## Verification\n```bash\n# Get feedback for spec\ncurl http://localhost:3002/api/feedback?spec_id=SPEC-001\n\n# Create feedback\ncurl -X POST http://localhost:3002/api/feedback \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"issue_id\": \"ISSUE-001\", \"spec_id\": \"SPEC-001\", \"type\": \"comment\", \"content\": \"Nice work!\", \"anchor\": {\"line_number\": 10, \"anchor_status\": \"valid\"}}'\n\n# Update feedback\ncurl -X PUT http://localhost:3002/api/feedback/fb-123 \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"content\": \"Updated comment\"}'\n\n# Delete feedback\ncurl -X DELETE http://localhost:3002/api/feedback/fb-123\n\n# Run tests\nnpm test\n```\n\n## Success Criteria\nFeedback management API with anchor support, CLI delegation, and full test coverage.\n\nReference: [[server/server_plan.md]] - Phase 5, Step 5.2","status":"closed","priority":0,"assignee":null,"archived":1,"archived_at":"2025-10-28T19:15:21.084Z","created_at":"2025-10-24 18:17:04","updated_at":"2025-10-28 19:15:21","closed_at":"2025-10-24 18:36:33","parent_id":null,"relationships":[],"tags":[]}
{"id":"ISSUE-011","uuid":"0022dc0e-75e9-4e4b-842f-65cafcd74217","title":"Server: File Watcher Setup","content":"Watch JSONL files for external changes and trigger database sync.\n\n## Tasks\n- [ ] Create `src/services/watcher.ts` for file watching\n- [ ] Use `chokidar` to watch issues.jsonl and specs.jsonl\n- [ ] Debounce file change events (avoid multiple rapid syncs)\n- [ ] Trigger database sync on file change\n- [ ] Handle file rename/delete events\n- [ ] Add watcher to server startup\n\n## Implementation Details\n\nUse chokidar to watch for file system changes:\n```typescript\nimport chokidar from 'chokidar'\n\nexport function startFileWatcher(jsonlPath: string) {\n  const watcher = chokidar.watch([\n    `${jsonlPath}/issues.jsonl`,\n    `${jsonlPath}/specs.jsonl`,\n  ], {\n    persistent: true,\n    ignoreInitial: true,\n  })\n\n  watcher.on('change', debounce((path) => {\n    console.log(`File changed: ${path}`)\n    if (path.includes('issues.jsonl')) {\n      syncIssuesToDb(path)\n      broadcastIssueUpdate()\n    } else if (path.includes('specs.jsonl')) {\n      syncSpecsToDb(path)\n      broadcastSpecUpdate()\n    }\n  }, 1000))\n}\n```\n\n## Verification\n```bash\n# Start server\nnpm run dev\n\n# Manually edit .sudocode/issues.jsonl\n# Server logs should show \"File changed: issues.jsonl\"\n# Database should be re-synced\n```\n\n## Dependencies\n- chokidar package\n- Existing sync functions from CLI\n\n## Success Criteria\nAutomatic database sync when JSONL files change externally.\n\nReference: [[server/server_plan.md]] - Phase 6, Step 6.1","status":"closed","priority":1,"assignee":null,"archived":1,"archived_at":"2025-10-28T19:15:21.066Z","created_at":"2025-10-24 18:41:25","updated_at":"2025-10-28 19:15:21","closed_at":"2025-10-25 02:42:16","parent_id":null,"relationships":[],"tags":[]}
{"id":"ISSUE-012","uuid":"803e1739-35ba-4bd6-924a-b70f34d10cf4","title":"Server: WebSocket Server Setup","content":"Set up WebSocket server for real-time client updates.\n\n## Tasks\n- [ ] Create `src/services/websocket.ts` for WebSocket management\n- [ ] Initialize WebSocket server with `ws` library\n- [ ] Handle client connections and disconnections\n- [ ] Implement connection management (track clients)\n- [ ] Add heartbeat/ping-pong to detect dead connections\n- [ ] Implement subscription system (clients subscribe to projects/entities)\n- [ ] Integrate with Express server\n\n## Implementation Details\n\nWebSocket server setup:\n```typescript\nimport { WebSocketServer, WebSocket } from 'ws'\n\ninterface Client {\n  id: string\n  ws: WebSocket\n  subscriptions: string[]  // e.g., ['project:uuid', 'issue:ISSUE-001']\n}\n\nconst clients = new Map<string, Client>()\n\nexport function initWebSocketServer(server: http.Server) {\n  const wss = new WebSocketServer({ server, path: '/ws' })\n\n  wss.on('connection', (ws, req) => {\n    const clientId = generateId()\n    clients.set(clientId, { id: clientId, ws, subscriptions: [] })\n\n    ws.on('message', (data) => {\n      const message = JSON.parse(data.toString())\n      handleClientMessage(clientId, message)\n    })\n\n    ws.on('close', () => {\n      clients.delete(clientId)\n    })\n\n    // Heartbeat\n    ws.on('pong', () => {\n      client.isAlive = true\n    })\n  })\n\n  // Check for dead connections every 30s\n  setInterval(() => {\n    clients.forEach((client) => {\n      if (!client.isAlive) {\n        client.ws.terminate()\n        clients.delete(client.id)\n        return\n      }\n      client.isAlive = false\n      client.ws.ping()\n    })\n  }, 30000)\n}\n```\n\n## Message Protocol\n\nClient -> Server:\n```json\n{\n  \"type\": \"subscribe\",\n  \"entity_type\": \"issue\",\n  \"entity_id\": \"ISSUE-001\"\n}\n```\n\nServer -> Client:\n```json\n{\n  \"type\": \"issue_updated\",\n  \"data\": { \"id\": \"ISSUE-001\", ... }\n}\n```\n\n## Verification\n```bash\n# Use wscat to test\nnpm install -g wscat\nwscat -c ws://localhost:3002/ws\n# Should connect successfully\n> {\"type\": \"ping\"}\n# Should receive pong\n```\n\n## Dependencies\n- ws package\n- uuid for client IDs\n\n## Success Criteria\nWebSocket server accepting and managing client connections with heartbeat.\n\nReference: [[server/server_plan.md]] - Phase 6, Step 6.2","status":"closed","priority":1,"assignee":null,"archived":1,"archived_at":"2025-10-28T19:15:21.082Z","created_at":"2025-10-24 18:41:26","updated_at":"2025-10-28 19:15:21","closed_at":"2025-10-24 21:47:26","parent_id":null,"relationships":[],"tags":[]}
{"id":"ISSUE-013","uuid":"7089f51c-758f-44fd-8183-a886b4876b7f","title":"Server: Real-Time Issue Updates","content":"Broadcast issue changes to connected WebSocket clients in real-time.\n\n## Tasks\n- [ ] Implement issue update broadcasting in `src/services/websocket.ts`\n- [ ] Broadcast updates on issue CRUD operations\n- [ ] Broadcast updates when file watcher detects changes\n- [ ] Add filtering (only send to subscribed clients)\n- [ ] Support subscription to specific issues or all issues\n- [ ] Handle different update types (created/updated/deleted)\n\n## Implementation Details\n\nBroadcasting logic:\n```typescript\nexport function broadcastIssueUpdate(\n  issue: Issue,\n  type: 'created' | 'updated' | 'deleted'\n) {\n  const message = {\n    type: `issue_${type}`,\n    data: issue,\n    timestamp: new Date().toISOString(),\n  }\n\n  clients.forEach((client) => {\n    const subscribed = client.subscriptions.some(sub => \n      sub === 'issues:all' || \n      sub === `issue:${issue.id}` ||\n      (issue.project_id && sub === `project:${issue.project_id}`)\n    )\n    \n    if (subscribed) {\n      client.ws.send(JSON.stringify(message))\n    }\n  })\n}\n```\n\nIntegration points:\n1. Call from routes after CRUD operations\n2. Call from file watcher on external changes\n3. Support filtering by project_id\n\n## Message Types\n\n- `issue_created` - New issue created\n- `issue_updated` - Issue modified\n- `issue_deleted` - Issue removed\n\n## Verification\n```bash\n# Connect with wscat\nwscat -c ws://localhost:3002/ws\n> {\"type\": \"subscribe\", \"entity_type\": \"issues\"}\n\n# In another terminal, create an issue\ncurl -X POST http://localhost:3002/api/issues -d '{\"title\": \"Test\"}'\n\n# wscat should receive update message\n< {\"type\": \"issue_created\", \"data\": {...}}\n```\n\n## Integration\n- Modify `src/routes/issues.ts` to call broadcast functions\n- Connect with file watcher from ISSUE-011\n\n## Success Criteria\nConnected clients receive real-time updates when issues change.\n\nReference: [[server/server_plan.md]] - Phase 6, Step 6.3","status":"closed","priority":1,"assignee":null,"archived":1,"archived_at":"2025-10-28T19:15:21.080Z","created_at":"2025-10-24 18:41:26","updated_at":"2025-10-28 19:15:21","closed_at":"2025-10-24 22:13:03","parent_id":null,"relationships":[],"tags":[]}
{"id":"ISSUE-014","uuid":"916d44ca-42fa-4af9-a2a3-3aea6499ec9b","title":"Server: Real-Time Spec Updates","content":"Broadcast spec changes to connected WebSocket clients in real-time.\n\n## Tasks\n- [ ] Implement spec update broadcasting in `src/services/websocket.ts`\n- [ ] Broadcast updates on spec CRUD operations\n- [ ] Broadcast updates when file watcher detects changes\n- [ ] Add filtering (only send to subscribed clients)\n- [ ] Support subscription to specific specs or all specs\n- [ ] Handle different update types (created/updated/deleted)\n\n## Implementation Details\n\nBroadcasting logic:\n```typescript\nexport function broadcastSpecUpdate(\n  spec: Spec,\n  type: 'created' | 'updated' | 'deleted'\n) {\n  const message = {\n    type: `spec_${type}`,\n    data: spec,\n    timestamp: new Date().toISOString(),\n  }\n\n  clients.forEach((client) => {\n    const subscribed = client.subscriptions.some(sub => \n      sub === 'specs:all' || \n      sub === `spec:${spec.id}` ||\n      (spec.project_id && sub === `project:${spec.project_id}`)\n    )\n    \n    if (subscribed) {\n      client.ws.send(JSON.stringify(message))\n    }\n  })\n}\n```\n\nIntegration points:\n1. Call from routes after CRUD operations\n2. Call from file watcher on external changes\n3. Support filtering by project_id\n\n## Message Types\n\n- `spec_created` - New spec created\n- `spec_updated` - Spec modified\n- `spec_deleted` - Spec removed\n\n## Verification\n```bash\n# Connect with wscat\nwscat -c ws://localhost:3002/ws\n> {\"type\": \"subscribe\", \"entity_type\": \"specs\"}\n\n# In another terminal, create a spec\ncurl -X POST http://localhost:3002/api/specs -d '{\"title\": \"Test Spec\"}'\n\n# wscat should receive update message\n< {\"type\": \"spec_created\", \"data\": {...}}\n```\n\n## Integration\n- Modify `src/routes/specs.ts` to call broadcast functions\n- Connect with file watcher from ISSUE-011\n- Consider broadcasting relationship and feedback updates\n\n## Success Criteria\nConnected clients receive real-time updates when specs change.\n\nReference: [[server/server_plan.md]] - Phase 6, Step 6.4","status":"closed","priority":1,"assignee":null,"archived":1,"archived_at":"2025-10-28T19:15:21.074Z","created_at":"2025-10-24 18:41:27","updated_at":"2025-10-28 19:15:21","closed_at":"2025-10-24 22:49:06","parent_id":null,"relationships":[],"tags":[]}
{"id":"ISSUE-015","uuid":"0483ddd8-d2ff-4d22-8f5a-4d4ddbbfc925","title":"Import should preserve timestamps from JSONL","content":"When importing from JSONL, updateIssue/updateSpec always generate new updated_at timestamps. This causes JSONL files to be modified even when content hasn't changed, breaking the bidirectional sync content-matching optimization.","status":"closed","priority":1,"assignee":null,"archived":1,"archived_at":"2025-10-28T19:15:21.083Z","created_at":"2025-10-24 21:16:59","updated_at":"2025-10-28 19:15:21","closed_at":"2025-10-24 21:35:58","parent_id":null,"relationships":[],"tags":[]}
{"id":"ISSUE-016","uuid":"e0dc4e55-aa7b-4666-b41a-510a8a5541b0","title":"Frontend Setup: Create workspace and configure build tools","content":"Set up the frontend workspace with Vite, React, and TypeScript, following the architecture outlined in [[server/ui.md]].\n\n## Tasks\n- [ ] Create `frontend/` directory in monorepo root\n- [ ] Initialize package.json with dependencies from ui.md\n- [ ] Configure Vite with React plugin and path aliases\n- [ ] Set up TypeScript with strict mode\n- [ ] Configure Tailwind CSS + PostCSS\n- [ ] Add shadcn/ui components configuration\n- [ ] Update root package.json to include frontend workspace\n- [ ] Add build and dev scripts\n\n## Dependencies\nCore:\n- React 18.2, React DOM\n- TypeScript 5.5+\n- Vite 5\n\nUI/Styling:\n- Tailwind CSS 3.4\n- shadcn/ui components (Radix UI primitives)\n- Lucide React icons\n\nSee server/ui.md lines 210-292 for complete dependency list.\n\n## Acceptance Criteria\n- `npm run dev --workspace=frontend` starts Vite dev server on port 3000\n- TypeScript compiles without errors\n- Tailwind CSS is working\n- Hot module replacement is functional","status":"closed","priority":0,"assignee":null,"archived":1,"archived_at":"2025-10-28T19:15:21.081Z","created_at":"2025-10-24 22:00:42","updated_at":"2025-10-28 19:15:21","closed_at":"2025-10-24 22:07:34","parent_id":null,"relationships":[],"tags":["frontend","infrastructure","setup"]}
{"id":"ISSUE-017","uuid":"f91867e7-b587-432b-899a-07a72bf525cd","title":"Server: Add static file serving for production frontend","content":"Update Express server to serve built frontend assets in production mode, following the pattern in [[server/ui.md]].\n\n## Tasks\n- [ ] Add static file serving middleware for frontend/dist\n- [ ] Add SPA fallback route to serve index.html for non-API routes\n- [ ] Ensure API routes are registered before static serving\n- [ ] Add production check (NODE_ENV === 'production')\n- [ ] Resolve port configuration (currently 3002, ui.md references 3001)\n- [ ] Document production build process\n\n## Implementation\n```typescript\n// server/src/index.ts (after API routes)\nif (process.env.NODE_ENV === 'production') {\n  const frontendPath = path.join(__dirname, '../../frontend/dist');\n  app.use(express.static(frontendPath));\n  \n  app.get('*', (req, res) => {\n    res.sendFile(path.join(frontendPath, 'index.html'));\n  });\n}\n```\n\n## Acceptance Criteria\n- Built frontend is served at http://localhost:3002/\n- API routes still work at http://localhost:3002/api/*\n- WebSocket endpoint still works at ws://localhost:3002/ws\n- SPA routing works (refresh on /projects, /issues, etc.)","status":"closed","priority":0,"assignee":null,"archived":1,"archived_at":"2025-10-28T19:15:21.077Z","created_at":"2025-10-24 22:00:42","updated_at":"2025-10-28 19:15:21","closed_at":"2025-10-24 22:22:36","parent_id":null,"relationships":[],"tags":["infrastructure","production","server"]}
{"id":"ISSUE-018","uuid":"79a69058-fa37-4b1a-bec5-533fb55892e6","title":"Frontend: Implement API client and WebSocket infrastructure","content":"Build the core API client layer with axios and WebSocket support, as designed in [[server/ui.md]] lines 470-670.\n\n## Tasks\n- [ ] Create `lib/api.ts` with axios instance and interceptors\n- [ ] Implement response unwrapping for ApiResponse wrapper\n- [ ] Create API modules: issuesApi, specsApi, relationshipsApi, feedbackApi\n- [ ] Create `lib/websocket.ts` with useWebSocket hook\n- [ ] Add environment variable support (VITE_API_URL, VITE_WS_URL)\n- [ ] Add error handling and logging\n- [ ] Create TypeScript types in `types/api.ts`\n\n## API Structure\n```typescript\nexport const issuesApi = {\n  getAll: (projectId?: string) => get<Issue[]>('/issues'),\n  getById: (id: string) => get<Issue>(\\`/issues/\\${id}\\`),\n  create: (data: CreateIssueRequest) => post<Issue>('/issues', data),\n  update: (id: string, data: UpdateIssueRequest) => put<Issue>(\\`/issues/\\${id}\\`, data),\n  delete: (id: string) => del(\\`/issues/\\${id}\\`)\n}\n```\n\n## Acceptance Criteria\n- API client successfully connects to server\n- Response unwrapping works correctly\n- WebSocket connection establishes and receives messages\n- Type safety for all API calls\n- Error handling with user-friendly messages","status":"closed","priority":1,"assignee":null,"archived":1,"archived_at":"2025-10-28T19:15:21.076Z","created_at":"2025-10-24 22:00:42","updated_at":"2025-10-28 19:15:21","closed_at":"2025-10-24 22:47:32","parent_id":null,"relationships":[],"tags":["api","frontend","infrastructure"]}
{"id":"ISSUE-019","uuid":"9947c91e-e3fb-4d94-9ad4-e0cde902b59a","title":"Frontend: Set up routing and application shell","content":"Implement React Router structure, providers, and main application layout per [[server/ui.md]] lines 747-788.\n\n## Tasks\n- [ ] Create `App.tsx` with QueryClientProvider, ThemeProvider, BrowserRouter\n- [ ] Set up React Router routes structure\n- [ ] Create page components: ProjectsPage, IssuesPage, SpecsPage\n- [ ] Create MainLayout component with outlet\n- [ ] Implement ProjectContext for current project state\n- [ ] Implement ThemeContext for dark/light mode\n- [ ] Configure TanStack Query with default options\n- [ ] Add route-based code splitting\n\n## Route Structure\n```\n/ → redirect to /projects\n/projects → Project list\n/projects/:id/issues → Issue kanban board\n/projects/:id/specs → Spec list\n/projects/:id/specs/:specId → Spec detail view\n/settings/* → Settings pages\n```\n\n## Acceptance Criteria\n- All routes render without errors\n- Navigation between routes works\n- QueryClient is configured with proper caching\n- Context providers accessible throughout app\n- Theme switching works (if implemented)","status":"closed","priority":1,"assignee":null,"archived":1,"archived_at":"2025-10-28T19:15:21.072Z","created_at":"2025-10-24 22:00:42","updated_at":"2025-10-28 19:15:21","closed_at":"2025-10-24 23:06:42","parent_id":null,"relationships":[],"tags":["frontend","infrastructure","routing"]}
{"id":"ISSUE-020","uuid":"20b4d501-8102-4261-996c-9af16d30ea5e","title":"Frontend: Build core layout components","content":"Implement the main layout structure with header, sidebar, and responsive containers following [[server/ui.md]] component architecture.\n\n## Tasks\n- [ ] Create `components/layout/MainLayout.tsx` - Main wrapper with outlets\n- [ ] Create `components/layout/Header.tsx` - Top navigation bar\n- [ ] Create `components/layout/Sidebar.tsx` - Left navigation sidebar\n- [ ] Create `components/layout/PanelLayout.tsx` - Slide-out panel system\n- [ ] Add Lucide React icons for navigation\n- [ ] Implement responsive breakpoints\n- [ ] Add keyboard navigation support\n- [ ] Style with Tailwind utilities\n\n## Features\n- Header: Logo, project selector, search, settings\n- Sidebar: Navigation links (Issues, Specs, Settings)\n- Panel system: Reusable slide-out panels for details\n- Responsive: Mobile-friendly collapsible sidebar\n\n## Acceptance Criteria\n- Layout renders correctly on desktop and mobile\n- Sidebar can be toggled open/closed\n- Navigation links highlight active route\n- Panel system can open/close smoothly\n- Accessible keyboard navigation","status":"closed","priority":1,"assignee":null,"archived":1,"archived_at":"2025-10-28T19:15:21.071Z","created_at":"2025-10-24 22:00:42","updated_at":"2025-10-28 19:15:21","closed_at":"2025-10-24 23:18:08","parent_id":null,"relationships":[],"tags":["components","frontend","layout"]}
{"id":"ISSUE-021","uuid":"b71ce905-f767-4ccf-9f88-3eb6612a7bd9","title":"Frontend: Implement issue kanban board (MVP)","content":"Build the core kanban board for issues with drag-and-drop, following the example in [[server/ui.md]] lines 675-743.\n\n## Tasks\n- [ ] Install @dnd-kit/core, @dnd-kit/sortable\n- [ ] Create `components/ui/kanban/` primitives (Board, Column, Card)\n- [ ] Create `components/issues/IssueKanbanBoard.tsx` - Main board\n- [ ] Create `components/issues/IssueCard.tsx` - Individual issue card\n- [ ] Create `components/issues/IssuePanel.tsx` - Detail slide-out panel\n- [ ] Implement useIssues hook with TanStack Query\n- [ ] Add WebSocket live updates for issue changes\n- [ ] Add drag-and-drop to change status\n- [ ] Style cards with priority badges and status indicators\n\n## Kanban Columns\n- Open → In Progress → Blocked → Closed\n\n## Acceptance Criteria\n- Issues load and display in correct columns\n- Drag-and-drop updates issue status via API\n- WebSocket updates reflect changes from other clients\n- Issue card shows: title, ID, priority, description preview\n- Click card opens detail panel\n- Optimistic updates with error handling","status":"closed","priority":2,"assignee":null,"archived":1,"archived_at":"2025-10-28T19:15:21.070Z","created_at":"2025-10-24 22:00:43","updated_at":"2025-10-28 19:15:21","closed_at":"2025-10-24 23:56:58","parent_id":null,"relationships":[],"tags":["frontend","issues","kanban","mvp"]}
{"id":"ISSUE-022","uuid":"1b1aa9c7-5984-4b46-9d9f-ae46dfde265f","title":"Frontend: Implement issue CRUD operations and forms","content":"Build issue creation, editing, and deletion UI with form validation.\n\n## Tasks\n- [ ] Create `components/issues/IssueEditor.tsx` - Create/edit form\n- [ ] Add markdown editor support (react-markdown or Lexical)\n- [ ] Implement issue creation dialog\n- [ ] Implement issue edit mode in panel\n- [ ] Add delete confirmation dialog\n- [ ] Implement priority selector (0-4)\n- [ ] Implement status selector\n- [ ] Add form validation\n- [ ] Connect to issuesApi mutations\n\n## Form Fields\n- Title (required)\n- Description (markdown)\n- Status (open/in_progress/blocked/closed)\n- Priority (0=highest to 4=lowest)\n- Tags (optional)\n- Parent issue (optional for relationships)\n\n## Acceptance Criteria\n- Can create new issues from kanban board\n- Can edit existing issues from detail panel\n- Can delete issues with confirmation\n- Form validates required fields\n- Markdown preview works\n- Mutations update QueryClient cache","status":"closed","priority":2,"assignee":null,"archived":1,"archived_at":"2025-10-28T19:15:21.068Z","created_at":"2025-10-24 22:00:43","updated_at":"2025-10-28 19:15:21","closed_at":"2025-10-25 00:20:17","parent_id":null,"relationships":[],"tags":["forms","frontend","issues","mvp"]}
{"id":"ISSUE-024","uuid":"feea9e38-7b61-4906-ab17-cbe2a7efb8f6","title":"Frontend: Implement feedback anchoring UI","content":"Build the feedback system for anchoring comments to spec lines, as designed in [[server/ui.md]].\n\n## Tasks\n- [ ] Create `components/specs/SpecFeedbackPanel.tsx` - Feedback sidebar\n- [ ] Create `components/specs/FeedbackAnchor.tsx` - Visual anchor on lines\n- [ ] Create `components/specs/FeedbackCard.tsx` - Individual feedback item\n- [ ] Create `components/specs/FeedbackForm.tsx` - Add feedback form\n- [ ] Implement useFeedback hook\n- [ ] Add click-to-anchor interaction on spec lines\n- [ ] Add line/text-based anchoring logic\n- [ ] Connect to feedbackApi\n- [ ] Add feedback type badges (comment/suggestion/request)\n\n## Feedback Features\n- Click spec line to add feedback\n- Feedback anchored by line number or text snippet\n- Visual indicators on lines with feedback\n- Sidebar shows all feedback for spec\n- Link feedback to issues\n\n## Acceptance Criteria\n- Can click line to add feedback\n- Feedback displays with correct anchor\n- Visual indicators show lines with feedback\n- Can view and navigate all feedback for a spec\n- Can link feedback to issues\n- Feedback persists across page reloads","status":"closed","priority":3,"assignee":null,"archived":1,"archived_at":"2025-10-28T19:15:21.064Z","created_at":"2025-10-24 22:00:43","updated_at":"2025-10-28 19:15:21","closed_at":"2025-10-25 08:55:22","parent_id":null,"relationships":[],"tags":["feedback","frontend","phase-2","specs"]}
{"id":"ISSUE-025","uuid":"c6ca5565-9ac7-4608-8b8d-9618eaccb164","title":"Frontend: Implement relationship visualization","content":"Build UI for viewing and creating relationships between specs and issues.\n\n## Tasks\n- [x] Create relationship utilities and helpers (`lib/relationships.ts`)\n- [x] Create `components/relationships/RelationshipList.tsx` - List view\n- [x] Create `components/relationships/RelationshipForm.tsx` - Create link form\n- [x] Integrate relationships into IssuePanel\n- [ ] Create `components/panels/RelationshipPanel.tsx` - Side panel (optional)\n- [ ] Create `components/relationships/RelationshipGraph.tsx` - Visual graph (deferred to future)\n- [ ] Add graph visualization library (deferred to future)\n- [ ] Integrate relationships into SpecViewer\n\n## Completed Features\n- ✅ Relationship type badges with color coding\n- ✅ List view showing outgoing/incoming relationships\n- ✅ Form for creating new relationships\n- ✅ Delete relationship functionality\n- ✅ Integrated into Issue Panel\n- ✅ Connected to relationshipsApi\n\n## Relationship Types\n- blocks\n- implements\n- references\n- depends-on\n- discovered-from\n- related\n\n## Acceptance Criteria\n- ✅ Can view relationships for issues\n- ✅ Relationship types clearly indicated with color-coded badges\n- ✅ Can create new relationships between entities\n- ✅ Can delete relationships\n- ⏳ Can view relationships for specs (pending SpecViewer integration)\n- ⏳ Can navigate to related entities (partially implemented)\n- ⏳ Graph visualization (deferred to future phase)","status":"closed","priority":4,"assignee":null,"archived":1,"archived_at":"2025-10-28T19:15:21.062Z","created_at":"2025-10-24 22:00:43","updated_at":"2025-10-28 19:15:21","closed_at":"2025-10-27 00:23:55","parent_id":null,"relationships":[{"from":"ISSUE-025","from_type":"issue","to":"ISSUE-021","to_type":"issue","type":"depends-on"},{"from":"ISSUE-025","from_type":"issue","to":"ISSUE-021","to_type":"issue","type":"references"}],"tags":["frontend","phase-2","relationships"]}
{"id":"ISSUE-026","uuid":"b03a982b-d66c-4561-bd89-1f5311c5eea4","title":"Frontend: Add dark mode support","content":"Implement dark/light theme switching with system preference detection.\n\n## Tasks\n- [x] Set up CSS variables for theme colors\n- [x] Configure Tailwind dark mode (class strategy)\n- [x] Implement ThemeContext with localStorage persistence\n- [x] Add theme toggle component in header\n- [x] Add system preference detection\n- [x] Update all components to support dark mode\n- [x] Test contrast and accessibility\n- [ ] Add smooth transitions between themes\n\n## Fixes Applied\n- Added missing chart color CSS variables (--chart-1 through --chart-5) for both light and dark modes\n- Fixed priority badge colors in IssueCard and SpecCard to use darker shades (600/700 variants) for better contrast with white text\n- Fixed FeedbackAnchor badge colors for better contrast in both themes\n- Changed kanban board outline from hard-coded black to theme-aware border color\n\n## Theme Colors (from ui.md)\n- Define HSL color variables for light/dark\n- Use Tailwind's dark: prefix for dark mode styles\n- shadcn/ui components support dark mode by default\n\n## Acceptance Criteria\n- Theme toggle button switches themes instantly\n- Theme preference persists in localStorage\n- Respects system preference on first visit\n- All components render correctly in both themes\n- Smooth transition animation between themes\n- Accessible contrast ratios in both modes","status":"closed","priority":4,"assignee":null,"archived":1,"archived_at":"2025-10-28T19:15:21.062Z","created_at":"2025-10-24 22:00:44","updated_at":"2025-10-28 19:15:21","closed_at":"2025-10-26 23:00:03","parent_id":null,"relationships":[],"tags":["accessibility","frontend","polish","ui"]}
{"id":"ISSUE-028","uuid":"060368aa-be35-492e-b410-b44ddbcca9d2","title":"Database schema and TypeScript types for executions","content":"Implement the database schema for the executions table and corresponding TypeScript types/interfaces.\n\n## Tasks\n\n- [ ] Create SQLite migration for executions table\n- [ ] Add TypeScript types: `Execution`, `AgentType`, `ExecutionStatus`\n- [ ] Create database helper functions: `createExecution`, `getExecution`, `updateExecution`\n- [ ] Write unit tests for database operations\n\n## Schema\n\n```sql\nCREATE TABLE executions (\n  id TEXT PRIMARY KEY,\n  issue_id TEXT NOT NULL REFERENCES issues(id) ON DELETE CASCADE,\n  agent_type TEXT NOT NULL,\n  status TEXT NOT NULL,\n  \n  started_at INTEGER NOT NULL,\n  completed_at INTEGER,\n  exit_code INTEGER,\n  \n  before_commit TEXT,\n  after_commit TEXT,\n  \n  session_id TEXT,\n  prompt TEXT,\n  summary TEXT,\n  \n  created_at INTEGER NOT NULL DEFAULT (unixepoch()),\n  updated_at INTEGER NOT NULL DEFAULT (unixepoch())\n);\n\nCREATE INDEX idx_executions_issue_id ON executions(issue_id);\nCREATE INDEX idx_executions_status ON executions(status);\nCREATE INDEX idx_executions_session_id ON executions(session_id);\n```\n\n## Acceptance Criteria\n\n- Migration runs successfully\n- Types match database schema exactly\n- Can create, read, and update executions\n- All tests pass\n\nImplements [[SPEC-001]] Phase 1","status":"closed","priority":0,"assignee":null,"archived":1,"archived_at":"2025-10-28T19:15:21.059Z","created_at":"2025-10-27 00:09:52","updated_at":"2025-10-28 19:15:21","closed_at":"2025-10-27 03:14:59","parent_id":null,"relationships":[],"tags":[]}
{"id":"ISSUE-029","uuid":"5ec59582-8d3e-448c-a5f0-1f8bafe3abb9","title":"Implement ExecutionManager class for process lifecycle management","content":"Create the core ExecutionManager class that handles spawning, monitoring, and stopping agent processes.\n\n## Tasks\n\n- [ ] Create `ExecutionManager` class in `server/src/execution/`\n- [ ] Implement `startExecution(issueId, agentType, prompt)` method\n- [ ] Implement `stopExecution(executionId)` method\n- [ ] Implement `getExecutionStatus(executionId)` method\n- [ ] Track running processes in memory (Map<executionId, ChildProcess>)\n- [ ] Handle process lifecycle events (spawn, exit, error)\n- [ ] Write stdout/stderr to temp files\n- [ ] Update database with status changes\n- [ ] Write unit tests\n\n## Key Responsibilities\n\n1. **Process Spawning**: Start agent processes with correct arguments\n2. **Process Tracking**: Maintain in-memory map of running processes\n3. **Status Updates**: Update database when status changes\n4. **Log Storage**: Write raw logs to temp files\n5. **Cleanup**: Handle process termination and cleanup\n\n## Dependencies\n\n- [[ISSUE-028]] - Database schema must be ready\n\n## Example Usage\n\n```typescript\nconst manager = new ExecutionManager(db);\n\n// Start execution\nconst executionId = await manager.startExecution(\n  'issue-123',\n  'claude-code',\n  'Fix the bug in auth.ts'\n);\n\n// Check status\nconst status = await manager.getExecutionStatus(executionId);\n// { id: 'exec-abc', status: 'running', ... }\n\n// Stop execution\nawait manager.stopExecution(executionId);\n```\n\nImplements [[SPEC-001]] Phase 1","status":"closed","priority":0,"assignee":null,"archived":1,"archived_at":"2025-10-28T19:15:21.059Z","created_at":"2025-10-27 00:11:11","updated_at":"2025-10-28 19:15:21","closed_at":"2025-10-27 04:15:54","parent_id":null,"relationships":[],"tags":[]}
{"id":"ISSUE-030","uuid":"a690a530-a4b6-4554-9391-32afd81f95f0","title":"Implement basic Claude Code process spawning","content":"Implement the ability to spawn Claude Code processes with correct arguments and environment.\n\n## Tasks\n\n- [ ] Create utility function `spawnClaudeCode(workDir, prompt)` \n- [ ] Configure correct npx command and arguments\n- [ ] Set up stdio pipes (stdin, stdout, stderr)\n- [ ] Send prompt via stdin and close\n- [ ] Return ChildProcess instance\n- [ ] Handle spawn errors gracefully\n- [ ] Add logging for debugging\n- [ ] Write integration tests\n\n## Command to Spawn\n\n```bash\nnpx -y @anthropic-ai/claude-code@latest \\\n  -p \\\n  --output-format=stream-json \\\n  --include-partial-messages \\\n  --verbose\n```\n\n## Implementation Notes\n\n- Use `spawn` from Node's `child_process`\n- Set `cwd` to work directory (for now, use repo root)\n- Capture stdout/stderr separately\n- Write prompt to stdin, then end stream\n- Don't normalize logs yet (Phase 2)\n\n## Dependencies\n\nNone - can be implemented independently\n\nImplements [[SPEC-001]] Phase 1","status":"closed","priority":0,"assignee":null,"archived":1,"archived_at":"2025-10-28T19:15:21.053Z","created_at":"2025-10-27 00:11:12","updated_at":"2025-10-28 19:15:21","closed_at":"2025-10-27 04:33:32","parent_id":null,"relationships":[],"tags":[]}
{"id":"ISSUE-031","uuid":"8fa52422-4f5b-4d0d-9bcb-172dcce12f90","title":"API endpoints for execution management","content":"Create REST API endpoints for starting, stopping, and monitoring executions.\n\n## Tasks\n\n- [ ] Create `server/src/routes/executions.ts`\n- [ ] Implement `POST /api/issues/:issueId/executions` - Start execution\n- [ ] Implement `GET /api/executions/:executionId` - Get status\n- [ ] Implement `POST /api/executions/:executionId/stop` - Stop execution\n- [ ] Implement `GET /api/issues/:issueId/executions` - List executions for issue\n- [ ] Add request validation\n- [ ] Add error handling\n- [ ] Update API types in `server/src/types/api.ts`\n- [ ] Write integration tests\n\n## Endpoints\n\n### Start Execution\n```\nPOST /api/issues/:issueId/executions\nBody: { \"agentType\": \"claude-code\", \"prompt\": \"Fix the bug\" }\nResponse: { \"executionId\": \"exec-123\" }\n```\n\n### Get Execution Status\n```\nGET /api/executions/:executionId\nResponse: {\n  \"id\": \"exec-123\",\n  \"issueId\": \"issue-456\",\n  \"agentType\": \"claude-code\",\n  \"status\": \"running\",\n  \"startedAt\": \"2025-01-26T10:00:00Z\",\n  ...\n}\n```\n\n### Stop Execution\n```\nPOST /api/executions/:executionId/stop\nResponse: { \"status\": \"killed\" }\n```\n\n### List Executions\n```\nGET /api/issues/:issueId/executions\nResponse: { \"executions\": [...] }\n```\n\n## Dependencies\n\n- [[ISSUE-028]] - Database schema\n- [[ISSUE-029]] - ExecutionManager class\n\nImplements [[SPEC-001]] Phase 1\n","status":"open","priority":0,"assignee":null,"archived":1,"archived_at":"2025-10-28T19:03:15.815Z","created_at":"2025-10-27 00:11:13","updated_at":"2025-10-28 19:03:15","closed_at":null,"parent_id":null,"relationships":[{"from":"ISSUE-031","from_type":"issue","to":"ISSUE-028","to_type":"issue","type":"references"},{"from":"ISSUE-031","from_type":"issue","to":"ISSUE-029","to_type":"issue","type":"references"},{"from":"ISSUE-031","from_type":"issue","to":"SPEC-001","to_type":"spec","type":"references"}],"tags":[]}
{"id":"ISSUE-032","uuid":"64f7faef-eab5-4214-95c8-00001ce87870","title":"Raw log storage in temp files","content":"Implement system for storing raw stdout/stderr from agent processes in temporary files for later processing.\n\n## Tasks\n\n- [ ] Create temp directory structure for logs (e.g., `.sudocode/tmp/executions/{executionId}/`)\n- [ ] Stream stdout to `stdout.log` file\n- [ ] Stream stderr to `stderr.log` file  \n- [ ] Handle file write errors\n- [ ] Implement cleanup on execution completion\n- [ ] Add configurable retention policy (default: keep for 24 hours)\n- [ ] Create utility functions: `getExecutionLogPath()`, `readExecutionLogs()`\n- [ ] Write tests for log storage\n\n## File Structure\n\n```\n.sudocode/tmp/executions/\n  exec-abc-123/\n    stdout.log\n    stderr.log\n  exec-def-456/\n    stdout.log\n    stderr.log\n```\n\n## Implementation Notes\n\n- Use Node's `fs.createWriteStream()` for efficient streaming\n- Create directories with `fs.mkdir({ recursive: true })`\n- Store logs until execution completes + retention period\n- In Phase 2, we'll parse these logs for normalization\n- For now, just preserve raw output\n\n## Dependencies\n\nNone - can be implemented independently\n\nImplements [[SPEC-001]] Phase 1","status":"open","priority":0,"assignee":null,"archived":1,"archived_at":"2025-10-28T19:03:18.430Z","created_at":"2025-10-27 00:11:14","updated_at":"2025-10-28 19:03:18","closed_at":null,"parent_id":null,"relationships":[],"tags":[]}
{"id":"ISSUE-033","uuid":"e3ed54c5-9be7-409a-acd5-646fbc4e9984","title":"Integration test for Phase 1 MVP","content":"Create end-to-end integration test that validates the complete Phase 1 execution flow.\n\n## Tasks\n\n- [ ] Create test file `server/tests/integration/executions.test.ts`\n- [ ] Test: Start execution via API\n- [ ] Test: Verify execution appears in database\n- [ ] Test: Check execution status via API\n- [ ] Test: Verify raw logs are written to temp files\n- [ ] Test: Stop execution via API\n- [ ] Test: Verify final status is 'killed' or 'completed'\n- [ ] Test: List executions for an issue\n- [ ] Add cleanup after tests (delete temp files, database rows)\n- [ ] Document test setup and teardown\n\n## Test Scenario\n\n```typescript\ndescribe('Execution MVP', () => {\n  it('should complete full execution lifecycle', async () => {\n    // 1. Create a test issue\n    const issue = await createTestIssue();\n    \n    // 2. Start execution\n    const { executionId } = await POST(`/api/issues/${issue.id}/executions`, {\n      agentType: 'claude-code',\n      prompt: 'List files in current directory'\n    });\n    \n    // 3. Verify running status\n    const status = await GET(`/api/executions/${executionId}`);\n    expect(status.status).toBe('running');\n    \n    // 4. Wait for completion or timeout\n    await waitForStatus(executionId, ['completed', 'failed'], 30000);\n    \n    // 5. Verify logs exist\n    const logs = await readExecutionLogs(executionId);\n    expect(logs.stdout).toBeTruthy();\n    \n    // 6. Verify in database\n    const dbExecution = await db.getExecution(executionId);\n    expect(dbExecution.status).toMatch(/completed|failed/);\n  });\n});\n```\n\n## Dependencies\n\n- [[ISSUE-028]] - Database schema\n- [[ISSUE-029]] - ExecutionManager\n- [[ISSUE-030]] - Process spawning\n- [[ISSUE-031]] - API endpoints\n- [[ISSUE-032]] - Log storage\n\nImplements [[SPEC-001]] Phase 1","status":"open","priority":0,"assignee":null,"archived":1,"archived_at":"2025-10-28T19:03:20.673Z","created_at":"2025-10-27 00:11:16","updated_at":"2025-10-28 19:03:20","closed_at":null,"parent_id":null,"relationships":[],"tags":[]}
{"id":"ISSUE-034","uuid":"6831a818-45d6-4062-be11-0a4e7c7db779","title":"Implement custom Tiptap extension for entity mention widgets","content":"## Goal\nBuild a custom Tiptap extension that renders `[[ISSUE-ID]]` and `[[SPEC-ID]]` mentions as interactive React components (widgets) in the spec viewer.\n\n## Current Behavior\nEntity mentions in specs and issues are displayed as plain text in the format `[[ENTITY-ID]]`.\n\n## Desired Behavior\nEntity mentions should be rendered as interactive badge widgets that:\n- Display the entity ID with appropriate styling (different colors for issues vs specs)\n- Show an icon indicating the entity type\n- Link to the entity page\n- (Future) Display a run button for executing the entity\n- (Future) Show run status (pending, running, complete)\n- (Future) Display agent messages in an expandable panel\n\n## Technical Approach\nUse Tiptap's custom node extension with React node views:\n\n1. **Create EntityMention extension** (`EntityMention.tsx`)\n   - Define as inline, atomic node\n   - Store `entityId` and `entityType` as attributes\n   - Use `ReactNodeViewRenderer` for custom rendering\n\n2. **Create EntityMentionComponent** (`EntityMentionComponent.tsx`)\n   - React component using `NodeViewWrapper`\n   - Render Badge with appropriate styling\n   - Link to entity page\n   - Placeholder for future interactive features\n\n3. **Parse markdown to detect entity mentions**\n   - Preprocess markdown to convert `[[ENTITY-ID]]` to custom HTML\n   - Configure Tiptap to parse the custom HTML into EntityMention nodes\n\n4. **Add extension to editors**\n   - Update `TiptapEditor.tsx` to include EntityMention extension\n   - Update `TiptapMarkdownViewer.tsx` to include EntityMention extension\n\n5. **Handle markdown export**\n   - Ensure entity mentions convert back to `[[ENTITY-ID]]` format when saving\n\n## Files to Create/Modify\n- Create: `frontend/src/components/specs/extensions/EntityMention.tsx`\n- Create: `frontend/src/components/specs/extensions/EntityMentionComponent.tsx`\n- Modify: `frontend/src/components/specs/TiptapEditor.tsx`\n- Modify: `frontend/src/components/specs/TiptapMarkdownViewer.tsx`\n\n## References\n- Tiptap custom extensions: https://tiptap.dev/docs/editor/extensions/custom-extensions\n- React node views: https://tiptap.dev/docs/editor/extensions/custom-extensions/node-views/react","status":"closed","priority":1,"assignee":null,"archived":1,"archived_at":"2025-10-28T19:15:21.056Z","created_at":"2025-10-27 04:20:34","updated_at":"2025-10-28 19:15:21","closed_at":"2025-10-27 04:24:47","parent_id":null,"relationships":[],"tags":[]}
{"id":"ISSUE-035","uuid":"2a63d735-417f-4623-85d0-a796e3e57439","title":"Setup process layer directory structure","content":"Create the directory structure for the Process Layer implementation as defined in [[SPEC-003]].\n\n## Tasks\n- [ ] Create `server/src/execution/` directory\n- [ ] Create `server/src/execution/process/` subdirectory\n- [ ] Create placeholder files:\n  - `types.ts` - Core types and interfaces\n  - `manager.ts` - IProcessManager interface\n  - `simple-manager.ts` - SimpleProcessManager implementation\n  - `utils.ts` - Helper functions (generateId, etc.)\n- [ ] Create `server/src/execution/process/__tests__/` for tests\n- [ ] Add barrel export `index.ts` to export public API\n\n## Acceptance Criteria\n- Directory structure matches spec file structure\n- All placeholder files created with basic TypeScript module structure\n- Imports/exports work correctly","status":"closed","priority":0,"assignee":null,"archived":1,"archived_at":"2025-10-28T19:15:21.052Z","created_at":"2025-10-28 09:04:39","updated_at":"2025-10-28 19:15:21","closed_at":"2025-10-28 18:15:09","parent_id":null,"relationships":[],"tags":["infrastructure","setup"]}
{"id":"ISSUE-036","uuid":"35503523-9f1e-43d9-b74d-3873668d10f7","title":"Define core process types in types.ts","content":"Implement all core TypeScript types and interfaces for the Process Layer as defined in [[SPEC-003]].\n\n## Types to Implement\n\n### ManagedProcess\n```typescript\ninterface ManagedProcess {\n  id: string;\n  pid: number;\n  status: ProcessStatus;\n  spawnedAt: Date;\n  lastActivity: Date;\n  exitCode: number | null;\n  signal: string | null;\n  process: ChildProcess;\n  streams: {\n    stdout: Readable;\n    stderr: Readable;\n    stdin: Writable;\n  };\n  metrics: {\n    totalDuration: number;\n    tasksCompleted: number;\n    successRate: number;\n  };\n}\n```\n\n### ProcessStatus\n```typescript\ntype ProcessStatus = \n  | 'spawning'\n  | 'idle'\n  | 'busy'\n  | 'terminating'\n  | 'crashed'\n  | 'completed';\n```\n\n### ProcessConfig\n```typescript\ninterface ProcessConfig {\n  claudePath: string;\n  workDir: string;\n  args: {\n    print: boolean;\n    outputFormat: 'stream-json' | 'json' | 'text';\n    dangerouslySkipPermissions: boolean;\n    permissionMode?: string;\n  };\n  env?: Record<string, string>;\n  timeout?: number;\n  idleTimeout?: number;\n  retry?: {\n    maxAttempts: number;\n    backoffMs: number;\n  };\n}\n```\n\n### ProcessMetrics\n```typescript\ninterface ProcessMetrics {\n  totalSpawned: number;\n  currentlyActive: number;\n  totalCompleted: number;\n  totalFailed: number;\n  averageDuration: number;\n}\n```\n\n### Handler Types\n```typescript\ntype OutputHandler = (data: Buffer, type: 'stdout' | 'stderr') => void;\ntype ErrorHandler = (error: Error) => void;\n```\n\n## Acceptance Criteria\n- All types defined with correct TypeScript syntax\n- Types exported from `types.ts`\n- JSDoc comments added for documentation\n- No TypeScript compilation errors","status":"closed","priority":0,"assignee":null,"archived":1,"archived_at":"2025-10-28T19:15:21.051Z","created_at":"2025-10-28 09:04:40","updated_at":"2025-10-28 19:15:21","closed_at":"2025-10-28 18:53:52","parent_id":null,"relationships":[],"tags":["core","types"]}
{"id":"ISSUE-037","uuid":"8652253b-c22a-4a56-b6ff-d1d022a2d76c","title":"Define IProcessManager interface","content":"Implement the IProcessManager interface that defines the contract for all process managers as specified in [[SPEC-003]].\n\n## Interface Methods\n\n```typescript\ninterface IProcessManager {\n  // Process lifecycle\n  acquireProcess(config: ProcessConfig): Promise<ManagedProcess>;\n  releaseProcess(processId: string): Promise<void>;\n  terminateProcess(processId: string, signal?: NodeJS.Signals): Promise<void>;\n  \n  // Process communication\n  sendInput(processId: string, input: string): Promise<void>;\n  onOutput(processId: string, handler: OutputHandler): void;\n  onError(processId: string, handler: ErrorHandler): void;\n  \n  // Monitoring\n  getProcess(processId: string): ManagedProcess | null;\n  getActiveProcesses(): ManagedProcess[];\n  getMetrics(): ProcessMetrics;\n  \n  // Cleanup\n  shutdown(): Promise<void>;\n}\n```\n\n## Tasks\n- [ ] Define interface in `manager.ts`\n- [ ] Add comprehensive JSDoc comments for each method\n- [ ] Import necessary types from `types.ts`\n- [ ] Export interface\n\n## Acceptance Criteria\n- Interface compiles without errors\n- All methods have clear JSDoc documentation\n- Types are correctly imported\n- Interface is exported for use by implementations","status":"closed","priority":0,"assignee":null,"archived":1,"archived_at":"2025-10-28T19:15:21.047Z","created_at":"2025-10-28 09:04:41","updated_at":"2025-10-28 19:15:21","closed_at":"2025-10-28 18:54:00","parent_id":null,"relationships":[],"tags":["core","interface"]}
{"id":"ISSUE-038","uuid":"2d075822-7165-4973-bc83-bd95ed0893a8","title":"Implement utility functions (generateId, etc.)","content":"Implement helper utility functions needed by the Process Layer in `utils.ts` as referenced in [[SPEC-003]].\n\n## Functions to Implement\n\n### generateId\nGenerate unique process IDs with a prefix.\n```typescript\nfunction generateId(prefix: string): string\n```\n\nExample: `generateId('process')` → `'process-abc123'`\n\n### Additional Utilities (as needed)\n- Error message formatting\n- Signal name validation\n- Duration formatting\n\n## Tasks\n- [ ] Implement `generateId` function using `nanoid` or similar\n- [ ] Add tests for `generateId` uniqueness\n- [ ] Export all utility functions\n\n## Acceptance Criteria\n- `generateId` produces unique IDs\n- IDs are URL-safe and readable\n- Functions are well-tested\n- All utilities exported","status":"closed","priority":0,"assignee":null,"archived":1,"archived_at":"2025-10-28T19:15:21.043Z","created_at":"2025-10-28 09:04:41","updated_at":"2025-10-28 19:15:21","closed_at":"2025-10-28 18:54:05","parent_id":null,"relationships":[],"tags":["core","utils"]}
{"id":"ISSUE-039","uuid":"06916dd4-cfc2-4893-abdf-353a0e17ca61","title":"Implement SimpleProcessManager class skeleton","content":"Create the basic SimpleProcessManager class structure that implements IProcessManager as defined in [[SPEC-003]].\n\n## Class Structure\n\n```typescript\nclass SimpleProcessManager implements IProcessManager {\n  private activeProcesses = new Map<string, ManagedProcess>();\n  private metrics: ProcessMetrics = {\n    totalSpawned: 0,\n    currentlyActive: 0,\n    totalCompleted: 0,\n    totalFailed: 0,\n    averageDuration: 0,\n  };\n\n  constructor(private defaultConfig: Partial<ProcessConfig> = {}) {}\n\n  async acquireProcess(config: ProcessConfig): Promise<ManagedProcess> {\n    throw new Error('Not implemented');\n  }\n\n  async releaseProcess(processId: string): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  async terminateProcess(processId: string, signal?: NodeJS.Signals): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  async sendInput(processId: string, input: string): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  onOutput(processId: string, handler: OutputHandler): void {\n    throw new Error('Not implemented');\n  }\n\n  onError(processId: string, handler: ErrorHandler): void {\n    throw new Error('Not implemented');\n  }\n\n  getProcess(processId: string): ManagedProcess | null {\n    throw new Error('Not implemented');\n  }\n\n  getActiveProcesses(): ManagedProcess[] {\n    throw new Error('Not implemented');\n  }\n\n  getMetrics(): ProcessMetrics {\n    throw new Error('Not implemented');\n  }\n\n  async shutdown(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n}\n```\n\n## Tasks\n- [ ] Create class in `simple-manager.ts`\n- [ ] Implement constructor\n- [ ] Add private fields (activeProcesses, metrics)\n- [ ] Add stub methods for all interface methods\n- [ ] Export class\n\n## Acceptance Criteria\n- Class implements IProcessManager correctly\n- TypeScript compilation succeeds\n- All methods have stubs\n- Class can be instantiated","status":"closed","priority":0,"assignee":null,"archived":1,"archived_at":"2025-10-28T19:15:21.041Z","created_at":"2025-10-28 09:04:42","updated_at":"2025-10-28 19:15:21","closed_at":"2025-10-28 18:54:10","parent_id":null,"relationships":[],"tags":["core","implementation"]}
{"id":"ISSUE-040","uuid":"a52ac3cc-cbdc-4e19-92e9-785caba38c9a","title":"Implement process spawning with child_process","content":"Implement the core process spawning functionality in SimpleProcessManager as defined in [[SPEC-003]].\n\n## Implementation Details\n\n### Methods to Implement\n\n1. **spawnClaudeProcess** (private)\n   - Use Node.js `spawn` from `child_process`\n   - Set stdio to `['pipe', 'pipe', 'pipe']`\n   - Pass working directory and environment\n   - Return ChildProcess instance\n\n2. **buildClaudeArgs** (private)\n   - Build CLI arguments array from ProcessConfig\n   - Handle `--print`, `--output-format`, `--dangerously-skip-permissions`\n   - Handle optional `--permission-mode`\n\n3. **acquireProcess** (public)\n   - Call `spawnClaudeProcess`\n   - Create ManagedProcess object\n   - Validate process spawned (check pid)\n   - Add to activeProcesses map\n   - Update metrics\n   - Return ManagedProcess\n\n## Tasks\n- [ ] Implement `buildClaudeArgs` method\n- [ ] Implement `spawnClaudeProcess` method  \n- [ ] Implement `acquireProcess` method\n- [ ] Handle spawn errors gracefully\n- [ ] Update metrics on spawn\n\n## Acceptance Criteria\n- Process spawns successfully with correct arguments\n- Working directory is set correctly\n- Environment variables are passed\n- Process ID is generated and tracked\n- Metrics are updated\n- Errors are thrown if spawn fails","status":"closed","priority":1,"assignee":null,"archived":1,"archived_at":"2025-10-29T08:14:40.960Z","created_at":"2025-10-28 09:04:43","updated_at":"2025-10-29 08:14:40","closed_at":"2025-10-28 19:43:19","parent_id":null,"relationships":[],"tags":["implementation","spawning"]}
{"id":"ISSUE-041","uuid":"4a74fe37-7697-413a-aca3-2a0d722c8634","title":"Implement event handlers for process lifecycle","content":"Implement event handlers for process exit, error, and I/O events as defined in [[SPEC-003]].\n\n## Implementation Details\n\n### setupProcessHandlers (private method)\n\nHandle these events:\n\n1. **exit event**\n   - Clear timeout if set\n   - Set exitCode and signal on ManagedProcess\n   - Set status to 'completed' (code 0) or 'crashed' (code != 0)\n   - Calculate duration\n   - Update global metrics (currentlyActive, totalCompleted, totalFailed)\n   - Schedule cleanup (delete from activeProcesses after 5s delay)\n\n2. **error event**\n   - Clear timeout if set\n   - Set status to 'crashed'\n   - Update metrics (currentlyActive--, totalFailed++)\n\n3. **stdout/stderr data events**\n   - Update lastActivity timestamp\n\n### Timeout Handling\n- Set timeout from config if provided\n- Clear timeout on process exit/error\n- Terminate process (SIGTERM) on timeout\n\n## Tasks\n- [ ] Implement `setupProcessHandlers` method\n- [ ] Add exit event handler\n- [ ] Add error event handler\n- [ ] Add I/O data handlers for activity tracking\n- [ ] Add timeout management\n- [ ] Call `setupProcessHandlers` from `acquireProcess`\n\n## Acceptance Criteria\n- Exit events update metrics correctly\n- Error events are handled gracefully\n- Timeouts terminate processes\n- Last activity is tracked on I/O\n- Cleanup happens after delay","status":"closed","priority":1,"assignee":null,"archived":1,"archived_at":"2025-10-29T08:14:40.958Z","created_at":"2025-10-28 09:04:43","updated_at":"2025-10-29 08:14:40","closed_at":"2025-10-28 20:01:26","parent_id":null,"relationships":[],"tags":["events","implementation"]}
{"id":"ISSUE-042","uuid":"45abf348-f296-4636-b62d-25ecd15f68e6","title":"Implement process I/O communication methods","content":"Implement methods for sending input to processes and receiving output as defined in [[SPEC-003]].\n\n## Methods to Implement\n\n### sendInput\n```typescript\nasync sendInput(processId: string, input: string): Promise<void> {\n  const managed = this.activeProcesses.get(processId);\n  if (!managed) {\n    throw new Error(`Process ${processId} not found`);\n  }\n\n  return new Promise((resolve, reject) => {\n    managed.streams.stdin.write(input, (error) => {\n      if (error) reject(error);\n      else resolve();\n    });\n  });\n}\n```\n\n### onOutput\n```typescript\nonOutput(processId: string, handler: OutputHandler): void {\n  const managed = this.activeProcesses.get(processId);\n  if (!managed) return;\n\n  managed.streams.stdout.on('data', (data: Buffer) => {\n    handler(data, 'stdout');\n  });\n\n  managed.streams.stderr.on('data', (data: Buffer) => {\n    handler(data, 'stderr');\n  });\n}\n```\n\n### onError\n```typescript\nonError(processId: string, handler: ErrorHandler): void {\n  const managed = this.activeProcesses.get(processId);\n  if (!managed) return;\n\n  managed.process.on('error', (error: Error) => {\n    handler(error);\n  });\n}\n```\n\n## Tasks\n- [ ] Implement `sendInput` method\n- [ ] Implement `onOutput` method\n- [ ] Implement `onError` method\n- [ ] Handle process not found errors\n- [ ] Handle stream write errors\n\n## Acceptance Criteria\n- sendInput writes to process stdin\n- onOutput registers handlers for stdout/stderr\n- onError registers error handler\n- Errors are properly propagated\n- Methods handle missing processes gracefully","status":"closed","priority":1,"assignee":null,"archived":1,"archived_at":"2025-10-29T08:14:40.952Z","created_at":"2025-10-28 09:04:44","updated_at":"2025-10-29 08:14:40","closed_at":"2025-10-28 22:03:14","parent_id":null,"relationships":[],"tags":["implementation","io"]}
{"id":"ISSUE-043","uuid":"15a21f28-9b47-4617-a2a6-e85be1cd68d4","title":"Implement graceful process termination","content":"Implement graceful process termination with SIGTERM → SIGKILL fallback as defined in [[SPEC-003]].\n\n## Implementation Details\n\n### terminateProcess\n```typescript\nasync terminateProcess(\n  processId: string, \n  signal: NodeJS.Signals = 'SIGTERM'\n): Promise<void> {\n  const managed = this.activeProcesses.get(processId);\n  if (!managed) return;\n\n  managed.status = 'terminating';\n\n  // Try graceful shutdown first\n  managed.process.kill(signal);\n\n  // Wait for graceful shutdown\n  await new Promise(resolve => setTimeout(resolve, 2000));\n\n  // Force kill if still running\n  if (!managed.process.killed && managed.exitCode === null) {\n    managed.process.kill('SIGKILL');\n  }\n}\n```\n\n### releaseProcess\n```typescript\nasync releaseProcess(processId: string): Promise<void> {\n  await this.terminateProcess(processId);\n}\n```\n\n### shutdown\n```typescript\nasync shutdown(): Promise<void> {\n  const processes = Array.from(this.activeProcesses.keys());\n  await Promise.all(\n    processes.map(id => this.terminateProcess(id, 'SIGTERM'))\n  );\n}\n```\n\n## Tasks\n- [ ] Implement `terminateProcess` method\n- [ ] Implement graceful shutdown with 2s wait\n- [ ] Implement force kill (SIGKILL) fallback\n- [ ] Implement `releaseProcess` method\n- [ ] Implement `shutdown` method to terminate all processes\n\n## Acceptance Criteria\n- SIGTERM sent first\n- 2-second grace period before SIGKILL\n- Status updated to 'terminating'\n- All processes terminated on shutdown\n- Methods are idempotent (safe to call multiple times)","status":"closed","priority":1,"assignee":null,"archived":1,"archived_at":"2025-10-29T08:14:40.956Z","created_at":"2025-10-28 09:04:45","updated_at":"2025-10-29 08:14:40","closed_at":"2025-10-28 22:19:48","parent_id":null,"relationships":[],"tags":["implementation","termination"]}
{"id":"ISSUE-044","uuid":"74989b71-9314-4a3a-a6fc-2a6dbf76c3d1","title":"Implement monitoring and metrics methods","content":"Implement process monitoring and metrics retrieval methods as defined in [[SPEC-003]].\n\n## Methods to Implement\n\n### getProcess\n```typescript\ngetProcess(processId: string): ManagedProcess | null {\n  return this.activeProcesses.get(processId) || null;\n}\n```\n\n### getActiveProcesses\n```typescript\ngetActiveProcesses(): ManagedProcess[] {\n  return Array.from(this.activeProcesses.values());\n}\n```\n\n### getMetrics\n```typescript\ngetMetrics(): ProcessMetrics {\n  return { ...this.metrics };\n}\n```\n\n## Tasks\n- [ ] Implement `getProcess` method\n- [ ] Implement `getActiveProcesses` method\n- [ ] Implement `getMetrics` method\n- [ ] Ensure metrics object is cloned (not mutated)\n\n## Acceptance Criteria\n- getProcess returns process or null\n- getActiveProcesses returns array of all active processes\n- getMetrics returns copy of metrics (not reference)\n- All methods return correct data","status":"closed","priority":2,"assignee":null,"archived":1,"archived_at":"2025-10-29T08:14:40.947Z","created_at":"2025-10-28 09:04:45","updated_at":"2025-10-29 08:14:40","closed_at":"2025-10-28 23:30:20","parent_id":null,"relationships":[],"tags":["implementation","monitoring"]}
{"id":"ISSUE-045","uuid":"3dc7b78c-5427-4d4b-9cc5-289841cdb367","title":"Write unit tests for process spawning","content":"Write comprehensive unit tests for process spawning functionality as outlined in [[SPEC-003]].\n\n## Test Cases\n\n### Process Spawning\n- [ ] Spawns process with correct arguments\n- [ ] Sets working directory correctly\n- [ ] Passes environment variables\n- [ ] Generates unique process ID\n- [ ] Returns ManagedProcess with correct structure\n- [ ] Throws error if spawn fails\n- [ ] Updates metrics on spawn\n\n### Argument Building\n- [ ] Includes `--print` when configured\n- [ ] Includes `--output-format` with correct value\n- [ ] Includes `--dangerously-skip-permissions` when configured\n- [ ] Includes `--permission-mode` when provided\n- [ ] Builds correct argument array\n\n## Test Framework\n- Use Vitest or Jest\n- Mock `child_process.spawn` for controlled testing\n- Test both success and failure paths\n\n## Acceptance Criteria\n- All test cases pass\n- Code coverage > 80% for spawning methods\n- Tests are isolated and don't spawn real processes\n- Tests run quickly (< 1s)","status":"closed","priority":2,"assignee":null,"archived":1,"archived_at":"2025-10-29T08:14:40.954Z","created_at":"2025-10-28 09:04:46","updated_at":"2025-10-29 08:14:40","closed_at":"2025-10-28 23:35:36","parent_id":null,"relationships":[],"tags":["testing","unit-tests"]}
{"id":"ISSUE-046","uuid":"4c81dd30-40ab-4a2b-a2f4-261703f9fd26","title":"Write unit tests for process lifecycle management","content":"Write unit tests for process lifecycle events and state management as outlined in [[SPEC-003]].\n\n## Test Cases\n\n### Lifecycle Management\n- [ ] Tracks process status correctly through lifecycle\n- [ ] Updates status on exit (completed vs crashed)\n- [ ] Updates metrics on successful exit\n- [ ] Updates metrics on failed exit\n- [ ] Cleans up processes after delay\n- [ ] Handles spawn errors\n\n### Event Handlers\n- [ ] Exit event handler updates state\n- [ ] Error event handler updates state\n- [ ] Timeout triggers termination\n- [ ] I/O updates lastActivity timestamp\n\n### State Transitions\n- [ ] spawning → busy → completed\n- [ ] spawning → busy → crashed\n- [ ] busy → terminating → completed\n- [ ] busy → terminating → (force killed)\n\n## Acceptance Criteria\n- All test cases pass\n- Code coverage > 80% for lifecycle methods\n- Tests verify state transitions\n- Async behavior is properly tested","status":"closed","priority":2,"assignee":null,"archived":1,"archived_at":"2025-10-29T08:14:40.953Z","created_at":"2025-10-28 09:04:47","updated_at":"2025-10-29 08:14:40","closed_at":"2025-10-28 23:38:38","parent_id":null,"relationships":[],"tags":["testing","unit-tests"]}
{"id":"ISSUE-047","uuid":"b0097068-c379-4619-bea6-8914894318d8","title":"Write unit tests for I/O handling","content":"Write unit tests for process I/O communication methods as outlined in [[SPEC-003]].\n\n## Test Cases\n\n### sendInput\n- [ ] Writes input to process stdin\n- [ ] Returns promise that resolves on success\n- [ ] Rejects promise on write error\n- [ ] Throws error if process not found\n- [ ] Handles multiple writes\n\n### onOutput\n- [ ] Registers stdout handler\n- [ ] Registers stderr handler\n- [ ] Handler receives correct data\n- [ ] Handler receives correct type ('stdout' or 'stderr')\n- [ ] Returns early if process not found\n- [ ] Supports multiple handlers\n\n### onError\n- [ ] Registers error handler\n- [ ] Handler receives error\n- [ ] Returns early if process not found\n\n## Acceptance Criteria\n- All test cases pass\n- Code coverage > 80% for I/O methods\n- Tests use mocked streams\n- Error cases are tested","status":"closed","priority":2,"assignee":null,"archived":1,"archived_at":"2025-10-29T08:14:40.945Z","created_at":"2025-10-28 09:04:47","updated_at":"2025-10-29 08:14:40","closed_at":"2025-10-28 23:53:20","parent_id":null,"relationships":[],"tags":["testing","unit-tests"]}
{"id":"ISSUE-048","uuid":"40237a96-1990-44b4-8c9a-3518c14808a0","title":"Write unit tests for process termination","content":"Write unit tests for process termination methods as outlined in [[SPEC-003]].\n\n## Test Cases\n\n### terminateProcess\n- [ ] Sends SIGTERM by default\n- [ ] Sends custom signal if provided\n- [ ] Sets status to 'terminating'\n- [ ] Waits 2 seconds for graceful shutdown\n- [ ] Sends SIGKILL if process still running after grace period\n- [ ] Returns early if process not found\n- [ ] Is idempotent (safe to call multiple times)\n\n### releaseProcess\n- [ ] Calls terminateProcess\n- [ ] Passes through correct process ID\n\n### shutdown\n- [ ] Terminates all active processes\n- [ ] Uses SIGTERM signal\n- [ ] Waits for all processes to terminate\n- [ ] Handles empty process list\n\n## Acceptance Criteria\n- All test cases pass\n- Code coverage > 80% for termination methods\n- Timing is tested (2s grace period)\n- Parallel termination tested for shutdown","status":"closed","priority":2,"assignee":null,"archived":1,"archived_at":"2025-10-29T08:14:40.943Z","created_at":"2025-10-28 09:04:48","updated_at":"2025-10-29 08:14:40","closed_at":"2025-10-28 23:55:42","parent_id":null,"relationships":[],"tags":["testing","unit-tests"]}
{"id":"ISSUE-049","uuid":"cc1fd76b-e38d-48c5-9c1f-f8f766fad724","title":"Write integration tests for end-to-end process execution","content":"Write integration tests that test the full process lifecycle with real Claude Code processes as outlined in [[SPEC-003]].\n\n## Test Scenarios\n\n### End-to-End Execution\n- [ ] Spawn → send prompt → receive output → terminate\n  - Spawn process successfully\n  - Send input via stdin\n  - Receive output via stdout\n  - Terminate cleanly\n  - Verify metrics updated\n\n### Multiple Concurrent Processes\n- [ ] Spawn multiple processes simultaneously\n- [ ] Each process executes independently\n- [ ] Metrics track all processes\n- [ ] All processes clean up properly\n\n### Process Crash Recovery\n- [ ] Process exits with non-zero code\n- [ ] Status updates to 'crashed'\n- [ ] Metrics reflect failure\n- [ ] Cleanup happens automatically\n\n### Error Scenarios\n- [ ] Invalid Claude path\n  - Spawn fails with clear error\n  - Metrics not incremented\n  \n- [ ] Process spawn failure\n  - Error event fired\n  - Process marked as crashed\n  \n- [ ] Timeout handling\n  - Process exceeds timeout\n  - SIGTERM sent automatically\n  - SIGKILL sent if needed\n\n## Test Setup\n- Use real `claude` CLI (or mock if not available)\n- Set reasonable timeouts for tests\n- Clean up all processes after tests\n- Use temporary directories for working dirs\n\n## Acceptance Criteria\n- All integration tests pass\n- Tests use real child processes (not mocks)\n- Tests complete in reasonable time (< 30s)\n- No processes left running after tests\n- Tests are reliable and don't flake","status":"closed","priority":3,"assignee":null,"archived":1,"archived_at":"2025-10-29T08:14:40.935Z","created_at":"2025-10-28 09:04:49","updated_at":"2025-10-29 08:14:40","closed_at":"2025-10-29 00:20:24","parent_id":null,"relationships":[],"tags":["integration-tests","testing"]}
{"id":"ISSUE-050","uuid":"21a4913e-2865-4cd1-ba8d-12a8a6dca727","title":"Define Engine Layer core types and interfaces","content":"## Overview\nCreate foundational types and interfaces for the Engine Layer as specified in [[SPEC-004]].\n\n## Tasks\n- [ ] Create `server/src/execution/engine/types.ts`\n  - `ExecutionTask` - unit of work for Claude Code agents\n  - `ExecutionResult` - outcome of task execution\n  - `EngineMetrics` - performance statistics\n  - `TaskStatus` - task state tracking\n  - Helper types: `TaskCompleteHandler`, `TaskFailedHandler`, `EngineConfig`, `RunningTask`, `TaskResolver`\n\n- [ ] Create `server/src/execution/engine/engine.ts`\n  - `IExecutionEngine` interface definition\n  - Method signatures for task submission, control, execution, monitoring, lifecycle\n\n## Acceptance Criteria\n- All types match SPEC-004 specification\n- TypeScript compiles without errors\n- Types exported properly for use by implementations\n- JSDoc comments for public API\n\n## Related\nImplements [[SPEC-004]] - Engine Layer foundation","status":"closed","priority":0,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-29 07:57:16","updated_at":"2025-10-29 08:15:15","closed_at":"2025-10-29 08:15:15","parent_id":null,"relationships":[{"from":"ISSUE-050","from_type":"issue","to":"SPEC-004","to_type":"spec","type":"implements"}],"tags":["engine","foundation","layer-2","types"]}
{"id":"ISSUE-051","uuid":"4793baaf-9717-437d-addd-82a7d213dbfc","title":"Implement task queue with FIFO ordering","content":"## Overview\nImplement the task queueing mechanism for SimpleExecutionEngine as part of [[SPEC-004]].\n\n## Tasks\n- [ ] Create internal queue data structure (array-based FIFO)\n- [ ] Implement `submitTask()` - add task to queue\n- [ ] Implement `submitTasks()` - batch submission\n- [ ] Implement queue processing logic `processQueue()`\n- [ ] Add queue position tracking for status queries\n- [ ] Handle queue metrics (queuedTasks count)\n\n## Implementation Details\n- Use simple array with push/shift for FIFO\n- Check capacity before dequeuing tasks\n- Update metrics when tasks enter/leave queue\n- Support re-queueing for dependency waits and retries\n\n## Acceptance Criteria\n- Tasks execute in submission order (FIFO)\n- Queue respects concurrency limits\n- Metrics accurately reflect queue size\n- Re-queueing works for dependencies and retries\n\n## Dependencies\nRequires [[ISSUE-050]] (core types)\n\n## Related\nImplements [[SPEC-004]] task queueing","status":"closed","priority":1,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-29 07:57:31","updated_at":"2025-10-29 08:25:20","closed_at":"2025-10-29 08:25:20","parent_id":null,"relationships":[{"from":"ISSUE-051","from_type":"issue","to":"SPEC-004","to_type":"spec","type":"implements"}],"tags":["engine","layer-2","queue"]}
{"id":"ISSUE-052","uuid":"97ee5220-151f-4536-a449-0f3d3066a737","title":"Implement concurrency control and capacity management","content":"## Overview\nImplement concurrency limits and capacity tracking for SimpleExecutionEngine per [[SPEC-004]].\n\n## Tasks\n- [ ] Track running tasks with Map<taskId, RunningTask>\n- [ ] Enforce maxConcurrent limit in processQueue()\n- [ ] Update capacity metrics (currentlyRunning, availableSlots)\n- [ ] Prevent queue processing when at capacity\n- [ ] Release capacity when tasks complete\n- [ ] Handle capacity in shutdown scenario\n\n## Implementation Details\n- Default maxConcurrent: 3 (configurable)\n- Check `runningTasks.size < maxConcurrent` before starting tasks\n- Decrement on completion/failure/cancellation\n- Trigger processQueue() when slots become available\n\n## Acceptance Criteria\n- Never exceeds maxConcurrent simultaneous tasks\n- Accurately tracks available slots\n- Starts queued tasks immediately when capacity available\n- Handles concurrent completion correctly\n\n## Dependencies\nRequires [[ISSUE-051]] (task queue)\n\n## Related\nImplements [[SPEC-004]] capacity control","status":"closed","priority":1,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-29 07:57:42","updated_at":"2025-10-29 08:44:04","closed_at":"2025-10-29 08:44:04","parent_id":null,"relationships":[{"from":"ISSUE-052","from_type":"issue","to":"SPEC-004","to_type":"spec","type":"implements"}],"tags":["concurrency","engine","layer-2"]}
{"id":"ISSUE-053","uuid":"0d5776d9-cfab-4e15-85fd-94795a914b4c","title":"Implement task execution and Process Layer integration","content":"## Overview\nImplement core task execution logic that integrates with the Process Layer from [[SPEC-003]].\n\n## Tasks\n- [ ] Implement `executeTask()` method\n- [ ] Acquire process from ProcessManager\n- [ ] Send prompt via `processManager.sendInput()`\n- [ ] Collect stdout/stderr output with `onOutput()`\n- [ ] Wait for process exit\n- [ ] Build ExecutionResult from process output\n- [ ] Parse stream-json metadata (tools used, files changed, tokens)\n- [ ] Release process after completion\n- [ ] Handle execution errors and process crashes\n\n## Implementation Details\n- Use `buildClaudeConfig()` helper for ProcessConfig\n- Set up output handlers before sending input\n- Implement `waitForProcessExit()` helper with polling\n- Extract metadata from stream-json lines\n- Track execution timing (startedAt, completedAt, duration)\n\n## Acceptance Criteria\n- Successfully spawns and manages Claude Code processes\n- Captures all output and errors\n- Correctly parses stream-json metadata\n- Handles process failures gracefully\n- Cleans up processes properly\n\n## Dependencies\nRequires [[ISSUE-052]] (concurrency control)\nDepends on [[SPEC-003]] Process Layer\n\n## Related\nImplements [[SPEC-004]] core execution","status":"closed","priority":1,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-29 07:57:57","updated_at":"2025-10-29 09:37:02","closed_at":"2025-10-29 09:22:53","parent_id":null,"relationships":[{"from":"ISSUE-053","from_type":"issue","to":"SPEC-004","to_type":"spec","type":"implements"}],"tags":["engine","execution","integration","layer-2"]}
{"id":"ISSUE-054","uuid":"abd5a94b-87ca-454d-b119-731adbcffdf9","title":"Implement task dependency resolution","content":"## Overview\nImplement dependency checking and ordering for tasks as specified in [[SPEC-004]].\n\n## Tasks\n- [ ] Implement `areDependenciesMet()` helper\n- [ ] Check all dependencies in completedResults\n- [ ] Verify dependencies completed successfully\n- [ ] Re-queue tasks with unmet dependencies\n- [ ] Prevent infinite loops from circular dependencies\n- [ ] Handle failed dependency scenarios\n\n## Implementation Details\n- Check task.dependencies array before execution\n- Look up each dependency ID in completedResults map\n- Require `result.success === true` for dependency\n- Re-queue at end if dependencies not met\n- Break queue processing loop to prevent infinite re-queuing\n\n## Acceptance Criteria\n- Tasks wait for dependencies before executing\n- Failed dependencies prevent dependent tasks from running\n- No infinite loops from circular or missing dependencies\n- Correct execution order maintained\n\n## Dependencies\nRequires [[ISSUE-053]] (task execution)\n\n## Related\nImplements [[SPEC-004]] dependency resolution","status":"closed","priority":2,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-29 07:58:07","updated_at":"2025-10-29 10:21:38","closed_at":"2025-10-29 10:21:38","parent_id":null,"relationships":[{"from":"ISSUE-054","from_type":"issue","to":"SPEC-004","to_type":"spec","type":"implements"}],"tags":["dependencies","engine","layer-2"]}
{"id":"ISSUE-055","uuid":"2b7a0e1f-cc08-4e58-a1b3-f9a1b2aa4727","title":"Implement task retry logic","content":"## Overview\nImplement automatic retry for failed tasks as specified in [[SPEC-004]].\n\n## Tasks\n- [ ] Check `task.config.maxRetries` setting\n- [ ] Track attempt count in RunningTask\n- [ ] Re-queue failed task if retries remaining\n- [ ] Use priority re-queue (unshift) for retries\n- [ ] Stop retrying after maxRetries reached\n- [ ] Emit failure event after final retry fails\n\n## Implementation Details\n- Default: no retries (maxRetries undefined)\n- Increment `running.attempt` on each retry\n- Re-queue at front: `taskQueue.unshift(task)`\n- Only retry on failure, not on cancellation\n- Track retry count in task metadata\n\n## Acceptance Criteria\n- Tasks retry up to maxRetries times\n- Retries happen immediately (priority)\n- No retries if maxRetries not configured\n- Final failure emits task failed event\n- Retry count visible in metrics/logs\n\n## Dependencies\nRequires [[ISSUE-053]] (task execution)\n\n## Related\nImplements [[SPEC-004]] retry logic","status":"closed","priority":2,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-29 07:58:18","updated_at":"2025-10-29 10:32:44","closed_at":"2025-10-29 10:32:44","parent_id":null,"relationships":[{"from":"ISSUE-055","from_type":"issue","to":"SPEC-004","to_type":"spec","type":"implements"}],"tags":["engine","layer-2","resilience","retry"]}
{"id":"ISSUE-056","uuid":"a1f67530-d2a5-42f1-b616-aba3840d0b42","title":"Implement event emission and handlers","content":"## Overview\nImplement event system for task completion and failure as specified in [[SPEC-004]].\n\n## Tasks\n- [ ] Add handler arrays (completeHandlers, failedHandlers)\n- [ ] Implement `onTaskComplete()` - register completion handlers\n- [ ] Implement `onTaskFailed()` - register failure handlers\n- [ ] Emit events in `handleTaskSuccess()`\n- [ ] Emit events in `handleTaskFailure()`\n- [ ] Ensure all handlers are called for each event\n\n## Implementation Details\n- Store handlers in arrays: `TaskCompleteHandler[]`, `TaskFailedHandler[]`\n- Call all registered handlers when events occur\n- Pass complete ExecutionResult for success events\n- Pass taskId and Error for failure events\n- Don't block execution on handler errors\n\n## Acceptance Criteria\n- Multiple handlers can be registered\n- All handlers called on each event\n- Handlers receive correct data\n- Handler errors don't crash engine\n- Events fire for all completion paths (success, failure, retry exhaustion)\n\n## Dependencies\nRequires [[ISSUE-053]] (task execution)\n\n## Related\nImplements [[SPEC-004]] event emission","status":"closed","priority":2,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-29 07:58:33","updated_at":"2025-10-29 10:45:03","closed_at":"2025-10-29 10:45:03","parent_id":null,"relationships":[{"from":"ISSUE-056","from_type":"issue","to":"SPEC-004","to_type":"spec","type":"implements"}],"tags":["engine","events","layer-2","observability"]}
{"id":"ISSUE-057","uuid":"c6d97642-9885-4e85-bbe4-9435aa49d686","title":"Implement task monitoring and status queries","content":"## Overview\nImplement methods for monitoring task status and progress as specified in [[SPEC-004]].\n\n## Tasks\n- [ ] Implement `getTaskStatus()` - query current task state\n- [ ] Return queued status with position\n- [ ] Return running status with process ID and start time\n- [ ] Return completed status with full result\n- [ ] Return failed/cancelled status as appropriate\n- [ ] Return null for unknown task IDs\n\n## Implementation Details\n- Check completedResults map first\n- Check runningTasks map second\n- Search taskQueue array for position\n- Return discriminated union TaskStatus type\n- Include relevant metadata for each state\n\n## Acceptance Criteria\n- Accurate status for all task states\n- Correct queue position calculation\n- Returns null for non-existent tasks\n- Type-safe discriminated unions\n- Fast lookups (no full array scans except queue)\n\n## Dependencies\nRequires [[ISSUE-051]] (task queue)\n\n## Related\nImplements [[SPEC-004]] monitoring","status":"closed","priority":2,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-29 07:58:46","updated_at":"2025-10-29 17:41:33","closed_at":"2025-10-29 17:41:33","parent_id":null,"relationships":[{"from":"ISSUE-057","from_type":"issue","to":"SPEC-004","to_type":"spec","type":"implements"}],"tags":["engine","layer-2","monitoring","observability"]}
{"id":"ISSUE-058","uuid":"679fa63b-dab5-4c7f-94e6-8e8723cad918","title":"Implement metrics tracking and calculation","content":"## Overview\nImplement comprehensive metrics tracking for the Engine Layer as specified in [[SPEC-004]].\n\n## Tasks\n- [ ] Initialize EngineMetrics structure\n- [ ] Implement `getMetrics()` - return copy of current metrics\n- [ ] Update metrics on task submission (queuedTasks++)\n- [ ] Update metrics on task start (currentlyRunning++, availableSlots--)\n- [ ] Update metrics on completion (completedTasks++, update averages)\n- [ ] Update metrics on failure (failedTasks++)\n- [ ] Calculate rolling averageDuration\n- [ ] Calculate successRate ratio\n- [ ] Calculate throughput (tasks/minute)\n\n## Implementation Details\n- Return defensive copy from getMetrics()\n- Use running averages: `(avg * (n-1) + new) / n`\n- Track totalProcessesSpawned from ProcessManager\n- Update activeProcesses count\n- Calculate throughput over time window\n\n## Acceptance Criteria\n- All metrics accurate and up-to-date\n- Averages calculated correctly\n- Returns defensive copy (immutable)\n- Metrics reflect real-time state\n- No race conditions in updates\n\n## Dependencies\nRequires [[ISSUE-053]] (task execution)\n\n## Related\nImplements [[SPEC-004]] metrics","status":"closed","priority":2,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-29 07:58:58","updated_at":"2025-10-29 17:42:14","closed_at":"2025-10-29 17:42:14","parent_id":null,"relationships":[{"from":"ISSUE-058","from_type":"issue","to":"SPEC-004","to_type":"spec","type":"implements"}],"tags":["engine","layer-2","metrics","observability"]}
{"id":"ISSUE-059","uuid":"fdb2b87a-8e24-4a41-a617-ad2231ad76f0","title":"Implement task cancellation and cleanup","content":"## Overview\nImplement task cancellation and cleanup logic as specified in [[SPEC-004]].\n\n## Tasks\n- [ ] Implement `cancelTask()` method\n- [ ] Remove task from queue if still queued\n- [ ] Terminate running process if task executing\n- [ ] Update metrics on cancellation\n- [ ] Clean up running task tracking\n- [ ] Handle cancellation of unknown task IDs gracefully\n\n## Implementation Details\n- Search queue and remove if found\n- Get running task from runningTasks map\n- Call `processManager.terminateProcess()` for running tasks\n- Decrement appropriate metric counters\n- Don't throw errors for non-existent tasks\n- Release capacity slot on cancellation\n\n## Acceptance Criteria\n- Queued tasks removed without execution\n- Running tasks terminated cleanly\n- Metrics updated correctly\n- Capacity released properly\n- Idempotent (safe to call multiple times)\n- Next queued task starts after cancellation\n\n## Dependencies\nRequires [[ISSUE-053]] (task execution)\n\n## Related\nImplements [[SPEC-004]] task control","status":"closed","priority":2,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-29 07:59:09","updated_at":"2025-10-29 17:44:45","closed_at":"2025-10-29 17:44:45","parent_id":null,"relationships":[{"from":"ISSUE-059","from_type":"issue","to":"SPEC-004","to_type":"spec","type":"implements"}],"tags":["cancellation","engine","layer-2"]}
{"id":"ISSUE-060","uuid":"6cb8aabd-63a0-4182-be5f-b81d0a9b4e41","title":"Implement async task waiting and promises","content":"## Overview\nImplement promise-based waiting for task completion as specified in [[SPEC-004]].\n\n## Tasks\n- [ ] Add taskResolvers map for promise management\n- [ ] Implement `waitForTask()` - return promise that resolves with result\n- [ ] Implement `waitForTasks()` - wait for multiple tasks\n- [ ] Resolve promises in handleTaskSuccess()\n- [ ] Reject promises in handleTaskFailure()\n- [ ] Clean up resolvers after resolution\n- [ ] Handle already-completed tasks\n\n## Implementation Details\n- Store resolve/reject callbacks in taskResolvers Map\n- Check completedResults first (immediate return)\n- Create new promise and store resolver\n- Call resolve() with ExecutionResult on success\n- Call reject() with Error on failure\n- Delete resolver after resolution to prevent memory leak\n- Use Promise.all() for multiple task waiting\n\n## Acceptance Criteria\n- waitForTask() resolves when task completes\n- Already-completed tasks return immediately\n- Promises rejected on failure\n- No memory leaks from unreleased resolvers\n- waitForTasks() waits for all tasks\n- Handles concurrent waiters correctly\n\n## Dependencies\nRequires [[ISSUE-053]] (task execution)\n\n## Related\nImplements [[SPEC-004]] task waiting","status":"closed","priority":2,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-29 07:59:20","updated_at":"2025-10-29 17:53:28","closed_at":"2025-10-29 17:53:28","parent_id":null,"relationships":[{"from":"ISSUE-060","from_type":"issue","to":"SPEC-004","to_type":"spec","type":"implements"}],"tags":["async","engine","layer-2","promises"]}
{"id":"ISSUE-061","uuid":"daefc7d0-5380-49cf-806c-edd5e71e6e0d","title":"Implement engine shutdown and cleanup","content":"## Overview\nImplement graceful shutdown for SimpleExecutionEngine as specified in [[SPEC-004]].\n\n## Tasks\n- [ ] Implement `shutdown()` method\n- [ ] Clear task queue (stop accepting new tasks)\n- [ ] Cancel all running tasks\n- [ ] Call processManager.shutdown()\n- [ ] Clean up all internal state\n- [ ] Wait for or force-terminate active work\n\n## Implementation Details\n- Set queue to empty array\n- Iterate through runningTasks and cancel each\n- Delegate to processManager for process cleanup\n- Clear all maps (runningTasks, taskResolvers, completedResults)\n- Clear event handler arrays\n- Idempotent (safe to call multiple times)\n\n## Acceptance Criteria\n- No new tasks accepted after shutdown\n- All running tasks cancelled\n- Process manager shut down cleanly\n- All resources released\n- Shutdown completes within reasonable time\n- Safe to call multiple times\n\n## Dependencies\nRequires [[ISSUE-059]] (task cancellation)\n\n## Related\nImplements [[SPEC-004]] lifecycle management","status":"closed","priority":2,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-29 07:59:30","updated_at":"2025-10-29 17:48:51","closed_at":"2025-10-29 17:48:51","parent_id":null,"relationships":[{"from":"ISSUE-061","from_type":"issue","to":"SPEC-004","to_type":"spec","type":"implements"}],"tags":["engine","layer-2","lifecycle","shutdown"],"feedback":[{"id":"FB-003","issue_id":"ISSUE-061","spec_id":"SPEC-008","feedback_type":"comment","content":"Test","agent":"user","anchor":null,"dismissed":false,"created_at":"2025-10-30 00:32:53","updated_at":"2025-10-30 00:32:53"}]}
{"id":"ISSUE-062","uuid":"5a94de64-9549-4bad-824d-6dc4530f667e","title":"Write unit tests for Engine Layer components","content":"## Overview\nWrite comprehensive unit tests for SimpleExecutionEngine as specified in [[SPEC-004]].\n\n## Test Coverage\n- [ ] Task queueing - FIFO ordering, queue metrics\n- [ ] Concurrency control - maxConcurrent limits, capacity tracking\n- [ ] Dependency resolution - wait for dependencies, handle failures\n- [ ] Retry logic - retry counts, maxRetries enforcement\n- [ ] Event emission - handlers called, correct data passed\n- [ ] Status queries - all states, queue positions\n- [ ] Metrics - calculations, accuracy, immutability\n- [ ] Cancellation - queue removal, process termination\n- [ ] Promise resolution - waitForTask, already-completed\n- [ ] Shutdown - cleanup, idempotency\n\n## Test Structure\n```\nserver/src/execution/engine/tests/unit/\n├── simple-engine.test.ts    # Core engine tests\n├── queue.test.ts            # Queue behavior\n├── concurrency.test.ts      # Capacity management\n├── dependencies.test.ts     # Dependency resolution\n├── retry.test.ts            # Retry logic\n├── events.test.ts           # Event emission\n├── monitoring.test.ts       # Status and metrics\n└── lifecycle.test.ts        # Shutdown\n```\n\n## Acceptance Criteria\n- All major code paths covered\n- Mock ProcessManager for isolation\n- Test both success and failure scenarios\n- Verify metrics accuracy\n- Test concurrent operations\n- All tests pass\n\n## Dependencies\nRequires [[ISSUE-050]] through [[ISSUE-061]] (implementation)\n\n## Related\nTesting for [[SPEC-004]]","status":"closed","priority":3,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-29 07:59:43","updated_at":"2025-10-29 17:53:28","closed_at":"2025-10-29 17:53:28","parent_id":null,"relationships":[{"from":"ISSUE-062","from_type":"issue","to":"SPEC-004","to_type":"spec","type":"implements"}],"tags":["engine","layer-2","testing","unit-tests"]}
{"id":"ISSUE-063","uuid":"975de8c7-baec-479a-b057-4a53be964c39","title":"Write integration tests for Engine Layer with Process Layer","content":"## Overview\nWrite end-to-end integration tests using real ProcessManager as specified in [[SPEC-004]].\n\n## Test Coverage\n- [ ] End-to-end task execution - submit → queue → execute → complete\n- [ ] Multiple concurrent tasks - verify parallel execution\n- [ ] Task dependencies - ensure correct ordering\n- [ ] Failed task handling - capture errors properly\n- [ ] Task cancellation during execution\n- [ ] Stream-json metadata parsing\n- [ ] Retry on failure\n- [ ] Metrics accuracy over time\n- [ ] Shutdown with active tasks\n- [ ] Real Claude Code process integration (optional, requires Claude)\n\n## Test Structure\n```\nserver/src/execution/engine/tests/integration/\n└── end-to-end.test.ts    # Full stack integration\n```\n\n## Implementation Notes\n- Use real SimpleProcessManager (not mocked)\n- May use mock executables (node -e) instead of Claude\n- Test realistic scenarios\n- Verify actual process spawning and cleanup\n- Check metrics reflect reality\n\n## Acceptance Criteria\n- Complete lifecycle tested with real processes\n- Concurrent execution verified\n- Dependencies work correctly\n- Metrics match actual behavior\n- All tests pass\n- No process leaks\n\n## Dependencies\nRequires [[ISSUE-062]] (unit tests)\nDepends on [[SPEC-003]] Process Layer implementation\n\n## Related\nIntegration testing for [[SPEC-004]]","status":"closed","priority":3,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-29 07:59:56","updated_at":"2025-10-29 19:28:05","closed_at":"2025-10-29 19:28:05","parent_id":null,"relationships":[{"from":"ISSUE-063","from_type":"issue","to":"SPEC-004","to_type":"spec","type":"implements"}],"tags":["engine","integration-tests","layer-2","testing"]}
{"id":"ISSUE-065","uuid":"692a6821-da97-4cc5-b080-e60a404f5002","title":"Implement SimpleExecutionEngine class","content":"## Overview\nCreate the main SimpleExecutionEngine implementation that brings together all Engine Layer components per [[SPEC-004]].\n\n## Tasks\n- [ ] Create `server/src/execution/engine/simple-engine.ts`\n- [ ] Implement SimpleExecutionEngine class\n- [ ] Integrate all component implementations:\n  - Task queue management\n  - Concurrency control\n  - Task execution with Process Layer\n  - Dependency resolution\n  - Retry logic\n  - Event emission\n  - Monitoring and status\n  - Metrics tracking\n  - Task cancellation\n  - Promise-based waiting\n  - Shutdown and cleanup\n- [ ] Add EngineConfig interface\n- [ ] Export class and types\n\n## Integration Points\n- Uses IProcessManager from [[SPEC-003]]\n- Implements IExecutionEngine interface\n- Delegates to ProcessManager for process operations\n- Uses buildClaudeConfig for ProcessConfig creation\n\n## Acceptance Criteria\n- All IExecutionEngine methods implemented\n- Successfully integrates with ProcessManager\n- Passes all unit tests from [[ISSUE-062]]\n- Passes all integration tests from [[ISSUE-063]]\n- Well-structured, maintainable code\n- Follows \"simple first\" design principle\n\n## Dependencies\nRequires all component issues [[ISSUE-050]] through [[ISSUE-061]]\n\n## Related\nMain implementation for [[SPEC-004]]","status":"closed","priority":1,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-29 08:00:19","updated_at":"2025-10-29 10:42:38","closed_at":"2025-10-29 10:42:38","parent_id":null,"relationships":[{"from":"ISSUE-065","from_type":"issue","to":"SPEC-004","to_type":"spec","type":"implements"}],"tags":["core","engine","implementation","layer-2"]}
{"id":"ISSUE-066","uuid":"e5362aba-d9a9-40d6-b824-9a8c768de93f","title":"Create FeedbackMark Tiptap extension for text highlighting","content":"Create a custom Tiptap Mark extension to highlight text that has associated feedback.\n\n## Acceptance Criteria\n\n- [ ] Create `frontend/src/components/specs/extensions/FeedbackMark.ts`\n- [ ] Mark adds `data-feedback-id` attribute to highlighted text\n- [ ] Applies background color styling (bg-yellow-100)\n- [ ] Supports hover state (bg-yellow-200)\n- [ ] Cursor changes to pointer on hover\n- [ ] Properly parses HTML with feedback attributes\n- [ ] Export extension for use in TiptapEditor\n\n## Implementation Details\n\n```typescript\nimport { Mark } from '@tiptap/core'\n\nexport const FeedbackMark = Mark.create({\n  name: 'feedbackHighlight',\n  \n  addAttributes() {\n    return {\n      feedbackId: {\n        default: null,\n        parseHTML: element => element.getAttribute('data-feedback-id'),\n        renderHTML: attributes => ({\n          'data-feedback-id': attributes.feedbackId,\n        }),\n      },\n    }\n  },\n  \n  parseHTML() {\n    return [{ tag: 'mark[data-feedback-id]' }]\n  },\n  \n  renderHTML({ HTMLAttributes }) {\n    return [\n      'mark',\n      {\n        ...HTMLAttributes,\n        class: 'bg-yellow-100 cursor-pointer hover:bg-yellow-200 transition-colors'\n      },\n      0\n    ]\n  },\n})\n```\n\n## Testing\n\n- Test that mark renders with correct attributes\n- Test that styling is applied correctly\n- Test hover states\n\n## Reference\n\nImplementation details in [[SPEC-008]]","status":"closed","priority":1,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-29 10:13:17","updated_at":"2025-10-29 10:42:30","closed_at":"2025-10-29 10:42:30","parent_id":null,"relationships":[],"tags":["frontend","phase-1","tiptap"]}
{"id":"ISSUE-067","uuid":"9f83646f-5693-453b-ac31-204316d850af","title":"Create useFeedbackPositions hook for position tracking","content":"Create a custom React hook to track the vertical positions of feedback anchors in the document.\n\n## Acceptance Criteria\n\n- [ ] Create `frontend/src/hooks/useFeedbackPositions.ts`\n- [ ] Hook accepts feedback array and editor ref as parameters\n- [ ] Returns Map<string, number> of feedback IDs to vertical positions\n- [ ] Updates positions on scroll with 100ms debounce\n- [ ] Updates positions on window resize\n- [ ] Updates positions when feedback changes\n- [ ] Properly cleans up event listeners on unmount\n- [ ] Handles missing elements gracefully\n\n## Implementation Details\n\n```typescript\nexport function useFeedbackPositions(\n  feedback: IssueFeedback[],\n  editorRef: RefObject<HTMLElement>\n): Map<string, number> {\n  const [positions, setPositions] = useState<Map<string, number>>(new Map())\n  \n  useEffect(() => {\n    const updatePositions = () => {\n      const newPositions = new Map<string, number>()\n      const editorRect = editorRef.current?.getBoundingClientRect()\n      \n      if (!editorRect) return\n      \n      feedback.forEach(fb => {\n        if (!fb.anchor?.line_number) return\n        \n        // Find element by feedback ID or line number\n        const element = editorRef.current?.querySelector(\n          `[data-feedback-id=\"${fb.id}\"]`\n        ) || editorRef.current?.querySelector(\n          `[data-line=\"${fb.anchor.line_number}\"]`\n        )\n        \n        if (element) {\n          const rect = element.getBoundingClientRect()\n          const scrollTop = editorRef.current?.scrollTop || 0\n          const top = rect.top - editorRect.top + scrollTop\n          newPositions.set(fb.id, top)\n        }\n      })\n      \n      setPositions(newPositions)\n    }\n    \n    // Debounce helper\n    const debouncedUpdate = debounce(updatePositions, 100)\n    \n    // Setup listeners\n    const editor = editorRef.current\n    editor?.addEventListener('scroll', debouncedUpdate)\n    window.addEventListener('resize', debouncedUpdate)\n    \n    // Initial update\n    updatePositions()\n    \n    return () => {\n      editor?.removeEventListener('scroll', debouncedUpdate)\n      window.removeEventListener('resize', debouncedUpdate)\n    }\n  }, [feedback, editorRef])\n  \n  return positions\n}\n```\n\n## Testing\n\n- Test position calculation accuracy\n- Test scroll event handling\n- Test resize event handling\n- Test cleanup on unmount\n- Test with no feedback\n- Test with feedback without anchors\n\n## Dependencies\n\n- [[ISSUE-066]] - FeedbackMark extension for data-feedback-id attributes\n\n## Reference\n\nImplementation details in [[SPEC-008]]","status":"closed","priority":1,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-29 10:13:33","updated_at":"2025-10-29 10:42:19","closed_at":"2025-10-29 10:42:19","parent_id":null,"relationships":[],"tags":["frontend","phase-1","react-hooks"]}
{"id":"ISSUE-068","uuid":"0ee198e3-44f5-4b05-a79f-30a12de9f078","title":"Create AlignedFeedbackPanel component","content":"Create a new component to display feedback aligned with document positions using absolute positioning.\n\n## Acceptance Criteria\n\n- [ ] Create `frontend/src/components/specs/AlignedFeedbackPanel.tsx`\n- [ ] Component accepts feedback array and positions map\n- [ ] Separates general comments (no anchor) from anchored comments\n- [ ] General comments shown in sticky section at top\n- [ ] Anchored comments positioned absolutely based on positions map\n- [ ] Renders FeedbackCard for each comment\n- [ ] Supports onClick, onDismiss, onDelete callbacks\n- [ ] Properly handles missing positions (don't render)\n- [ ] Applies smooth transitions for position changes\n\n## Implementation Details\n\n```typescript\ninterface AlignedFeedbackPanelProps {\n  feedback: IssueFeedback[]\n  positions: Map<string, number>\n  onFeedbackClick?: (feedback: IssueFeedback) => void\n  onDismiss?: (id: string) => void\n  onDelete?: (id: string) => void\n  className?: string\n}\n\nexport function AlignedFeedbackPanel({\n  feedback,\n  positions,\n  onFeedbackClick,\n  onDismiss,\n  onDelete,\n  className = '',\n}: AlignedFeedbackPanelProps) {\n  // Separate general vs. anchored comments\n  const { generalComments, anchoredComments } = useMemo(() => {\n    const general: IssueFeedback[] = []\n    const anchored: IssueFeedback[] = []\n    \n    feedback.forEach(fb => {\n      if (fb.anchor?.line_number) {\n        anchored.push(fb)\n      } else {\n        general.push(fb)\n      }\n    })\n    \n    return { generalComments: general, anchoredComments: anchored }\n  }, [feedback])\n  \n  return (\n    <div className={`feedback-panel w-80 border-l bg-background ${className}`}>\n      {/* General comments section */}\n      {generalComments.length > 0 && (\n        <section className=\"border-b bg-muted/30 p-4\">\n          <h3 className=\"mb-2 text-sm font-semibold\">💭 General Comments</h3>\n          <div className=\"space-y-2\">\n            {generalComments.map(fb => (\n              <FeedbackCard\n                key={fb.id}\n                feedback={fb}\n                onClick={() => onFeedbackClick?.(fb)}\n                onDismiss={() => onDismiss?.(fb.id)}\n                onDelete={() => onDelete?.(fb.id)}\n              />\n            ))}\n          </div>\n        </section>\n      )}\n      \n      {/* Positioned comments */}\n      <div className=\"relative min-h-screen\">\n        {anchoredComments.map(fb => {\n          const top = positions.get(fb.id)\n          if (top === undefined) return null\n          \n          return (\n            <div\n              key={fb.id}\n              className=\"absolute w-full px-2 transition-all duration-200\"\n              style={{ top: `${top}px` }}\n            >\n              <FeedbackCard\n                feedback={fb}\n                onClick={() => onFeedbackClick?.(fb)}\n                onDismiss={() => onDismiss?.(fb.id)}\n                onDelete={() => onDelete?.(fb.id)}\n              />\n            </div>\n          )\n        })}\n      </div>\n    </div>\n  )\n}\n```\n\n## Testing\n\n- Test rendering with general comments only\n- Test rendering with anchored comments only\n- Test rendering with mixed comments\n- Test position updates trigger re-render\n- Test callbacks fire correctly\n- Test with empty feedback array\n\n## Dependencies\n\n- [[ISSUE-067]] - useFeedbackPositions hook for positions map\n- Existing FeedbackCard component\n\n## Reference\n\nImplementation details in [[SPEC-008]]","status":"closed","priority":1,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-29 10:13:51","updated_at":"2025-10-29 10:41:18","closed_at":"2025-10-29 10:41:18","parent_id":null,"relationships":[{"from":"ISSUE-068","from_type":"issue","to":"ISSUE-067","to_type":"issue","type":"depends-on"}],"tags":["frontend","phase-1","react"]}
{"id":"ISSUE-069","uuid":"dfc5d090-b95e-4925-bd7e-d97a1d0fc917","title":"Integrate FeedbackMark extension into TiptapEditor","content":"Add the FeedbackMark extension to the TiptapEditor and wire it up with feedback data.\n\n## Acceptance Criteria\n\n- [ ] Import FeedbackMark extension in TiptapEditor\n- [ ] Add FeedbackMark to editor extensions array\n- [ ] Add feedback prop to TiptapEditor interface\n- [ ] Apply marks to content based on feedback anchors\n- [ ] Update editor content when feedback changes\n- [ ] Handle click events on marked text\n- [ ] Ensure marks persist through editor updates\n- [ ] Don't interfere with existing editing functionality\n\n## Implementation Details\n\n**Update TiptapEditor props:**\n```typescript\ninterface TiptapEditorProps {\n  content: string\n  editable?: boolean\n  onSave?: (markdown: string) => void\n  onChange?: (markdown: string) => void\n  onCancel?: () => void\n  className?: string\n  showToolbar?: boolean\n  feedback?: IssueFeedback[]  // NEW\n  onFeedbackClick?: (feedbackId: string) => void  // NEW\n}\n```\n\n**Add extension:**\n```typescript\nconst editor = useEditor({\n  extensions: [\n    StarterKit,\n    CodeBlockLowlight.configure({ lowlight }),\n    TabHandler,\n    // ... other extensions\n    FeedbackMark,  // NEW\n  ],\n  // ...\n})\n```\n\n**Apply marks on feedback change:**\n```typescript\nuseEffect(() => {\n  if (!editor || !feedback) return\n  \n  feedback.forEach(fb => {\n    if (fb.anchor?.line_number) {\n      // Find position and apply mark\n      // This might need helper function to find position by line\n    }\n  })\n}, [editor, feedback])\n```\n\n## Testing\n\n- Test marks appear when feedback is added\n- Test marks update when feedback changes\n- Test marks are removed when feedback is deleted\n- Test click events fire correctly\n- Test editor remains editable with marks present\n\n## Dependencies\n\n- [[ISSUE-066]] - FeedbackMark extension must be created first\n\n## Reference\n\nImplementation details in [[SPEC-008]]","status":"closed","priority":1,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-29 10:14:07","updated_at":"2025-10-29 10:41:51","closed_at":"2025-10-29 10:41:51","parent_id":null,"relationships":[],"tags":["frontend","phase-1","tiptap"]}
{"id":"ISSUE-070","uuid":"60ebdcaf-1342-4c58-b576-eca49ac8961b","title":"Update SpecDetailPage to use AlignedFeedbackPanel with position tracking","content":"Integrate the new AlignedFeedbackPanel and position tracking system into SpecDetailPage, replacing the current sidebar layout.\n\n## Acceptance Criteria\n\n- [ ] Update layout to side-by-side (editor + aligned panel)\n- [ ] Create ref for editor container\n- [ ] Use useFeedbackPositions hook with feedback and editor ref\n- [ ] Pass feedback and positions to AlignedFeedbackPanel\n- [ ] Pass feedback to TiptapEditor for highlighting\n- [ ] Wire up all callback handlers (click, dismiss, delete)\n- [ ] Ensure existing feedback functionality still works\n- [ ] Test with view mode toggle (Formatted/Markdown)\n- [ ] Responsive behavior on mobile (consider stacking)\n- [ ] Remove or deprecate old SpecFeedbackPanel (if no longer needed)\n\n## Implementation Details\n\n**Update SpecDetailPage layout:**\n```typescript\nexport function SpecDetailPage() {\n  const { id } = useParams()\n  const editorRef = useRef<HTMLDivElement>(null)\n  \n  const { spec } = useSpec(id)\n  const { feedback } = useSpecFeedback(id)\n  \n  // Use position tracking hook\n  const positions = useFeedbackPositions(feedback, editorRef)\n  \n  return (\n    <div className=\"flex h-full\">\n      {/* Editor column */}\n      <div className=\"flex-1 overflow-auto\" ref={editorRef}>\n        <TiptapEditor\n          content={spec.content}\n          feedback={feedback}\n          onFeedbackClick={handleFeedbackClick}\n          // ... other props\n        />\n      </div>\n      \n      {/* Aligned feedback panel */}\n      <AlignedFeedbackPanel\n        feedback={feedback}\n        positions={positions}\n        onFeedbackClick={handleFeedbackClick}\n        onDismiss={handleDismiss}\n        onDelete={handleDelete}\n      />\n    </div>\n  )\n}\n```\n\n## Testing\n\n- Test layout renders correctly\n- Test positions update on scroll\n- Test clicking feedback focuses comment\n- Test dismissing/deleting feedback\n- Test with no feedback\n- Test with general comments only\n- Test with anchored comments only\n- Test view mode switching\n- Test mobile responsive behavior\n\n## Dependencies\n\n- [[ISSUE-066]] - FeedbackMark extension\n- [[ISSUE-067]] - useFeedbackPositions hook\n- [[ISSUE-068]] - AlignedFeedbackPanel component\n- [[ISSUE-069]] - TiptapEditor integration\n\n## Reference\n\nImplementation details in [[SPEC-008]]","status":"closed","priority":1,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-29 10:14:23","updated_at":"2025-10-29 10:42:52","closed_at":"2025-10-29 10:42:52","parent_id":null,"relationships":[{"from":"ISSUE-070","from_type":"issue","to":"ISSUE-067","to_type":"issue","type":"depends-on"},{"from":"ISSUE-070","from_type":"issue","to":"ISSUE-068","to_type":"issue","type":"depends-on"},{"from":"ISSUE-070","from_type":"issue","to":"ISSUE-069","to_type":"issue","type":"depends-on"}],"tags":["frontend","integration","phase-1"]}
{"id":"ISSUE-071","uuid":"dd71ec35-4e80-4066-9eab-e63fb2adea5f","title":"Phase 1: Test and validate inline feedback visualization","content":"Comprehensive testing and validation of Phase 1 implementation to ensure all components work together correctly.\n\n## Acceptance Criteria\n\n- [ ] Manual testing with sample feedback data\n- [ ] Test all user interactions (click, hover, scroll)\n- [ ] Test position accuracy with different document lengths\n- [ ] Test performance with many comments (10+, 50+)\n- [ ] Verify no visual regressions in existing UI\n- [ ] Test on different screen sizes (desktop, tablet, mobile)\n- [ ] Test with both view modes (Formatted/Markdown)\n- [ ] Write/update unit tests for new components\n- [ ] Write integration tests for full flow\n- [ ] Document any known issues or limitations\n\n## Test Scenarios\n\n### Basic Functionality\n- [ ] General comments appear in top section\n- [ ] Anchored comments align with correct lines\n- [ ] Highlights appear on referenced text\n- [ ] Clicking highlight focuses comment\n- [ ] Scrolling updates comment positions smoothly\n\n### Edge Cases\n- [ ] Empty feedback list\n- [ ] Feedback without anchors only\n- [ ] Very long document (1000+ lines)\n- [ ] Many comments on same line\n- [ ] Comments on first and last lines\n- [ ] Rapid scrolling doesn't cause jank\n\n### Responsive Design\n- [ ] Desktop layout (side-by-side)\n- [ ] Tablet layout\n- [ ] Mobile layout (consider stacking)\n\n### Performance\n- [ ] No noticeable lag when scrolling\n- [ ] Position updates are debounced\n- [ ] Memory cleanup on unmount\n\n## Bugs to Watch For\n\n- Position drift after multiple scrolls\n- Overlapping comments in panel\n- Missing highlights for some feedback\n- Event listener leaks\n- Race conditions in position updates\n\n## Dependencies\n\n- [[ISSUE-066]] - FeedbackMark extension\n- [[ISSUE-067]] - useFeedbackPositions hook\n- [[ISSUE-068]] - AlignedFeedbackPanel component\n- [[ISSUE-069]] - TiptapEditor integration\n- [[ISSUE-070]] - SpecDetailPage integration\n\n## Reference\n\nImplementation details in [[SPEC-008]]","status":"closed","priority":1,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-29 10:14:40","updated_at":"2025-10-29 10:41:34","closed_at":"2025-10-29 10:41:34","parent_id":null,"relationships":[],"tags":["frontend","phase-1","testing"],"feedback":[{"id":"FB-002","issue_id":"ISSUE-071","spec_id":"SPEC-008","feedback_type":"comment","content":"Test message2","agent":"alexngai","anchor":{"section_heading":"Goals","section_level":2,"line_number":10,"line_offset":2,"text_snippet":"- **Contextual Feedback**: Show feedback aligned w...","context_before":"tegrated, contextual feedback experience.  ## Goals","context_after":"- **Visual Clarity**: Use highlights and indicator","content_hash":"d004d4312f0a589f","anchor_status":"valid","last_verified_at":"2025-10-29T17:36:57.981Z","original_location":{"line_number":10,"section_heading":"Goals"}},"dismissed":false,"created_at":"2025-10-30 00:32:53","updated_at":"2025-10-30 00:32:53"}]}
{"id":"ISSUE-072","uuid":"167b56f4-761a-4eb3-847f-ae207912eb56","title":"Define Resilience Layer core types and interfaces","content":"## Overview\nCreate foundational types and interfaces for the Resilience Layer as specified in [[SPEC-005]].\n\n## Tasks\n- [ ] Create `server/src/execution/resilience/types.ts`\n  - `RetryPolicy` - configuration for retry behavior with backoff strategy\n  - `CircuitBreaker` - circuit breaker state and configuration\n  - `CircuitState` - 'closed' | 'open' | 'half-open'\n  - `ExecutionAttempt` - record of single execution attempt\n  - `ResilientExecutionResult` - enhanced result with retry information\n  - `RetryMetrics` - aggregate metrics for retry behavior\n  - Helper types: `RetryAttemptHandler`, `CircuitOpenHandler`\n\n- [ ] Create `server/src/execution/resilience/executor.ts`\n  - `IResilientExecutor` interface definition\n  - Method signatures for resilient execution, circuit breaker management, monitoring\n\n## Acceptance Criteria\n- All types match SPEC-005 specification\n- TypeScript compiles without errors\n- Types exported properly for use by implementations\n- JSDoc comments for public API\n\n## Related\nImplements [[SPEC-005]] - Resilience Layer foundation","status":"closed","priority":0,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-30 00:48:28","updated_at":"2025-10-30 01:17:00","closed_at":"2025-10-30 01:17:00","parent_id":null,"relationships":[{"from":"ISSUE-072","from_type":"issue","to":"SPEC-005","to_type":"spec","type":"implements"}],"tags":["foundation","layer-3","resilience","types"]}
{"id":"ISSUE-073","uuid":"2f0df85b-5816-43b1-97f6-7c09a2b743a6","title":"Implement retry logic with exponential backoff and jitter","content":"## Overview\nImplement retry logic with multiple backoff strategies as specified in [[SPEC-005]].\n\n## Tasks\n- [ ] Create `server/src/execution/resilience/retry.ts`\n  - `calculateBackoff()` function with support for exponential, linear, fixed strategies\n  - Implement exponential backoff: baseDelay * 2^(attempt-1)\n  - Implement linear backoff: baseDelay * attempt\n  - Implement fixed backoff: constant delay\n  - Add jitter support (±10% randomness)\n  - Enforce maxDelay cap\n\n- [ ] Create helper functions\n  - `isRetryableError()` - check if error should be retried\n  - `isRetryableExitCode()` - check if exit code should be retried\n  - `sleep()` - promise-based delay utility\n\n## Acceptance Criteria\n- All backoff strategies work correctly\n- Jitter adds randomness without exceeding bounds\n- maxDelay cap is enforced\n- Retryable error detection works for common cases\n- TypeScript compiles without errors\n\n## Dependencies\nRequires previous issue (types and interfaces)\n\n## Related\nImplements [[SPEC-005]] retry logic","status":"closed","priority":0,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-30 00:48:29","updated_at":"2025-10-30 01:28:06","closed_at":"2025-10-30 01:28:06","parent_id":null,"relationships":[{"from":"ISSUE-073","from_type":"issue","to":"SPEC-005","to_type":"spec","type":"implements"}],"tags":["backoff","layer-3","resilience","retry"]}
{"id":"ISSUE-074","uuid":"4285b738-2eb6-46d4-a43a-b19e61449110","title":"Implement circuit breaker","content":"## Overview\nImplement circuit breaker pattern for preventing cascading failures as specified in [[SPEC-005]].\n\n## Tasks\n- [ ] Create `server/src/execution/resilience/circuit-breaker.ts`\n  - `CircuitBreakerManager` class for managing multiple circuit breakers\n  - State transitions: closed → open → half-open → closed\n  - Failure tracking with threshold detection\n  - Success tracking for recovery\n  - Half-open timeout logic\n\n- [ ] Implement core methods\n  - `recordSuccess()` - record successful execution\n  - `recordFailure()` - record failed execution, check thresholds\n  - `canExecute()` - check if circuit allows execution\n  - `shouldTransitionToHalfOpen()` - check timeout for retry\n  - `reset()` - manually reset circuit breaker\n\n## Acceptance Criteria\n- Circuit opens after reaching failure threshold\n- Circuit transitions to half-open after timeout\n- Circuit closes after reaching success threshold in half-open\n- Requests rejected when circuit is open (before timeout)\n- Metrics accurately track request counts\n- TypeScript compiles without errors\n\n## Dependencies\nRequires previous issue (types and interfaces)\n\n## Related\nImplements [[SPEC-005]] circuit breaker pattern","status":"closed","priority":0,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-30 00:48:30","updated_at":"2025-10-30 02:07:17","closed_at":"2025-10-30 01:39:57","parent_id":null,"relationships":[{"from":"ISSUE-074","from_type":"issue","to":"SPEC-005","to_type":"spec","type":"implements"}],"tags":["circuit-breaker","layer-3","resilience"]}
{"id":"ISSUE-075","uuid":"f22e5188-b90e-4f6f-a4c5-b65e80220783","title":"Implement ResilientExecutor","content":"## Overview\nImplement main ResilientExecutor class that integrates retry logic and circuit breaker as specified in [[SPEC-005]].\n\n## Tasks\n- [ ] Create `server/src/execution/resilience/resilient-executor.ts`\n  - `ResilientExecutor` class implementing `IResilientExecutor`\n  - Integration with `IExecutionEngine` from Layer 2\n  - Default retry policy configuration\n\n- [ ] Implement core methods\n  - `executeTask()` - execute single task with retry and circuit breaker\n  - `executeTasks()` - execute multiple tasks with resilience\n  - `getCircuitBreaker()` - get circuit breaker by name\n  - `resetCircuitBreaker()` - manually reset circuit breaker\n  - `getRetryMetrics()` - get aggregate metrics\n  - `onRetryAttempt()` - register retry event handler\n  - `onCircuitOpen()` - register circuit open event handler\n\n- [ ] Implement execution flow\n  - Check circuit breaker state before execution\n  - Execute task via engine\n  - Handle success: record in circuit breaker, return result\n  - Handle failure: check if retryable, calculate backoff, retry or fail\n  - Track all attempts in ExecutionAttempt array\n  - Update metrics throughout\n\n## Acceptance Criteria\n- Successfully wraps engine execution with resilience\n- Retry logic works correctly with all backoff strategies\n- Circuit breaker integration works correctly\n- Metrics accurately tracked\n- Event handlers called at appropriate times\n- TypeScript compiles without errors\n\n## Dependencies\nRequires all previous issues (types, retry logic, circuit breaker)\n\n## Related\nImplements [[SPEC-005]] main executor implementation","status":"closed","priority":1,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-30 00:48:30","updated_at":"2025-10-30 02:47:39","closed_at":"2025-10-30 02:47:39","parent_id":null,"relationships":[{"from":"ISSUE-075","from_type":"issue","to":"SPEC-005","to_type":"spec","type":"implements"}],"tags":["executor","implementation","layer-3","resilience"]}
{"id":"ISSUE-076","uuid":"0d4ad26a-657d-483d-8505-cbda26234141","title":"Write unit tests for retry logic","content":"## Overview\nWrite comprehensive unit tests for retry and backoff logic as specified in [[SPEC-005]].\n\n## Test Coverage\n- [ ] Exponential backoff calculation\n  - Verify: 1s, 2s, 4s, 8s, 16s progression\n  - Test with different base delays\n  - Verify cap at maxDelay\n\n- [ ] Linear backoff calculation\n  - Verify: 1s, 2s, 3s, 4s, 5s progression\n  - Test with different base delays\n\n- [ ] Fixed backoff calculation\n  - Verify constant delay\n  \n- [ ] Jitter functionality\n  - Verify jitter adds randomness within bounds\n  - Verify jitter doesn't exceed delay limits\n\n- [ ] Retryable error detection\n  - Test common retryable errors (ECONNREFUSED, timeout, etc.)\n  - Test non-retryable errors\n  - Test retryable exit codes\n\n## Test Structure\n```\nserver/src/execution/resilience/tests/unit/\n├── backoff.test.ts          # Backoff calculations\n├── retry-detection.test.ts  # Retryable error detection\n└── sleep.test.ts            # Sleep utility\n```\n\n## Acceptance Criteria\n- All tests pass\n- Code coverage > 90% for retry logic\n- Tests verify edge cases (maxDelay, zero jitter, etc.)\n- TypeScript compiles without errors\n\n## Dependencies\nRequires retry logic implementation\n\n## Related\nTesting for [[SPEC-005]] retry logic","status":"closed","priority":2,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-30 00:48:31","updated_at":"2025-10-30 04:39:39","closed_at":"2025-10-30 04:39:39","parent_id":null,"relationships":[{"from":"ISSUE-076","from_type":"issue","to":"SPEC-005","to_type":"spec","type":"implements"}],"tags":["layer-3","resilience","testing","unit-tests"]}
{"id":"ISSUE-077","uuid":"f2cc4414-f711-45b4-a2bb-2571923bce4e","title":"Write unit tests for circuit breaker","content":"## Overview\nWrite comprehensive unit tests for circuit breaker logic as specified in [[SPEC-005]].\n\n## Test Coverage\n- [ ] State transitions\n  - Test closed → open (after failure threshold)\n  - Test open → half-open (after timeout)\n  - Test half-open → closed (after success threshold)\n  - Test half-open → open (on failure)\n\n- [ ] Failure threshold\n  - Test circuit opens after N failures\n  - Test failures below threshold don't open circuit\n\n- [ ] Success threshold\n  - Test circuit closes after N successes in half-open\n  - Test successes below threshold keep circuit half-open\n\n- [ ] Half-open timeout\n  - Test circuit stays open until timeout\n  - Test circuit allows retry after timeout\n\n- [ ] Request rejection\n  - Test requests rejected when circuit open\n  - Test requests allowed when circuit closed/half-open\n\n- [ ] Metrics tracking\n  - Test success/failure counts\n  - Test timestamps updated correctly\n\n## Test Structure\n```\nserver/src/execution/resilience/tests/unit/\n├── circuit-breaker-states.test.ts   # State machine tests\n├── circuit-breaker-thresholds.test.ts # Threshold tests\n└── circuit-breaker-metrics.test.ts  # Metrics tests\n```\n\n## Acceptance Criteria\n- All tests pass\n- Code coverage > 90% for circuit breaker\n- Tests verify all state transitions\n- TypeScript compiles without errors\n\n## Dependencies\nRequires circuit breaker implementation\n\n## Related\nTesting for [[SPEC-005]] circuit breaker","status":"closed","priority":2,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-30 00:48:31","updated_at":"2025-10-30 04:39:39","closed_at":"2025-10-30 04:39:39","parent_id":null,"relationships":[{"from":"ISSUE-077","from_type":"issue","to":"SPEC-005","to_type":"spec","type":"implements"}],"tags":["circuit-breaker","layer-3","resilience","testing","unit-tests"]}
{"id":"ISSUE-078","uuid":"20faba2b-27ff-4990-ac04-95fc6b7d698a","title":"Write unit tests for ResilientExecutor","content":"## Overview\nWrite comprehensive unit tests for ResilientExecutor as specified in [[SPEC-005]].\n\n## Test Coverage\n- [ ] Retry on transient errors\n  - Test task retried on retryable error\n  - Test backoff delay between retries\n  - Test eventual success after retries\n\n- [ ] No retry on permanent errors\n  - Test task not retried on non-retryable error\n  - Test immediate failure\n\n- [ ] Circuit breaker integration\n  - Test circuit breaker checked before execution\n  - Test execution blocked when circuit open\n  - Test execution allowed when circuit closed\n\n- [ ] Metrics tracking\n  - Test totalRetries incremented\n  - Test successfulRetries incremented on success\n  - Test failedRetries incremented on failure\n  - Test averageAttemptsToSuccess calculated correctly\n\n- [ ] Event emission\n  - Test onRetryAttempt called for each retry\n  - Test onCircuitOpen called when circuit opens\n\n- [ ] Multiple tasks\n  - Test executeTasks() runs all tasks\n  - Test separate circuit breakers per task type\n\n## Test Structure\n```\nserver/src/execution/resilience/tests/unit/\n├── resilient-executor-retry.test.ts      # Retry behavior\n├── resilient-executor-circuit.test.ts    # Circuit breaker integration\n├── resilient-executor-metrics.test.ts    # Metrics tracking\n└── resilient-executor-events.test.ts     # Event emission\n```\n\n## Implementation Notes\n- Use MockExecutionEngine (similar to Engine Layer tests)\n- Mock engine can simulate transient vs permanent failures\n\n## Acceptance Criteria\n- All tests pass\n- Code coverage > 85% for ResilientExecutor\n- Tests use mocked engine for isolation\n- TypeScript compiles without errors\n\n## Dependencies\nRequires ResilientExecutor implementation\n\n## Related\nTesting for [[SPEC-005]] main executor","status":"closed","priority":2,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-30 00:48:32","updated_at":"2025-10-30 04:39:39","closed_at":"2025-10-30 04:39:39","parent_id":null,"relationships":[{"from":"ISSUE-078","from_type":"issue","to":"SPEC-005","to_type":"spec","type":"implements"}],"tags":["layer-3","resilience","testing","unit-tests"]}
{"id":"ISSUE-079","uuid":"93b1bbf0-48b1-438d-a841-01c75b6bf560","title":"Write integration tests for Resilience Layer with Engine Layer","content":"## Overview\nWrite end-to-end integration tests using real ExecutionEngine as specified in [[SPEC-005]].\n\n## Test Coverage\n- [ ] End-to-end retry flow\n  - Submit task that fails transiently\n  - Verify retry attempts\n  - Verify eventual success\n  - Verify attempt tracking\n\n- [ ] Circuit breaker with real engine\n  - Cause multiple task failures\n  - Verify circuit breaker opens\n  - Verify requests blocked\n  - Verify circuit recovery after timeout\n\n- [ ] Multiple task types\n  - Submit tasks of different types\n  - Verify separate circuit breakers\n  - Verify one type's failures don't affect others\n\n- [ ] Real process execution (optional)\n  - Use mock executables (node -e) that fail/succeed\n  - Verify retry behavior with actual processes\n\n- [ ] Metrics accuracy\n  - Verify metrics reflect reality across retry cycles\n  - Verify circuit breaker states match behavior\n\n## Test Structure\n```\nserver/src/execution/resilience/tests/integration/\n└── end-to-end.test.ts    # Full stack integration\n```\n\n## Implementation Notes\n- Use real SimpleExecutionEngine\n- Use real SimpleProcessManager\n- May use mock executables instead of Claude for reliability\n- Verify no resource leaks after retries\n\n## Acceptance Criteria\n- Complete lifecycle tested with real engine\n- Retry and circuit breaker verified end-to-end\n- All tests pass\n- No process/resource leaks\n- Tests complete in reasonable time\n\n## Dependencies\nRequires [[SPEC-004]] Engine Layer and all Resilience Layer components\n\n## Related\nIntegration testing for [[SPEC-005]]","status":"closed","priority":3,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-30 00:48:33","updated_at":"2025-10-30 04:55:35","closed_at":"2025-10-30 04:55:35","parent_id":null,"relationships":[{"from":"ISSUE-079","from_type":"issue","to":"SPEC-005","to_type":"spec","type":"implements"}],"tags":["integration-tests","layer-3","resilience","testing"]}
{"id":"ISSUE-080","uuid":"defd612f-048e-413d-b5ce-78c97680d07e","title":"Define core types and interfaces for Workflow Layer","content":"## Overview\nDefine all core TypeScript types and interfaces for the Workflow Layer (Layer 4) as specified in [[SPEC-006]].\n\n## Implementation Steps\n\n### 1. Create `server/src/execution/workflow/types.ts`\n\nDefine the following types in order:\n\n#### WorkflowDefinition\n```typescript\ninterface WorkflowDefinition {\n  id: string;\n  name: string;\n  version: string;\n  steps: WorkflowStep[];\n  config: {\n    checkpointInterval?: number;\n    continueOnStepFailure?: boolean;\n    timeout?: number;\n  };\n  metadata?: Record<string, any>;\n}\n```\n\n#### WorkflowStep\n```typescript\ninterface WorkflowStep {\n  id: string;\n  name: string;\n  taskType: 'issue' | 'spec' | 'custom';\n  promptTemplate: string;\n  dependsOn: string[];\n  retryPolicy?: RetryPolicy;  // From Layer 3\n  timeout?: number;\n  condition?: (context: WorkflowContext) => boolean;\n  outputMapping?: Record<string, string>;\n}\n```\n\n#### WorkflowExecution\n```typescript\ninterface WorkflowExecution {\n  id: string;\n  workflowId: string;\n  status: WorkflowStatus;\n  currentStep?: string;\n  completedSteps: string[];\n  failedSteps: string[];\n  skippedSteps: string[];\n  context: WorkflowContext;\n  stepResults: Map<string, ExecutionResult>;\n  startedAt: Date;\n  completedAt?: Date;\n  lastCheckpointAt?: Date;\n  metadata?: Record<string, any>;\n}\n```\n\n#### WorkflowContext\n```typescript\ninterface WorkflowContext {\n  variables: Record<string, any>;\n  outputs: Record<string, any>;\n  shared: Record<string, any>;\n}\n```\n\n#### WorkflowCheckpoint\n```typescript\ninterface WorkflowCheckpoint {\n  executionId: string;\n  workflowId: string;\n  timestamp: Date;\n  execution: WorkflowExecution;\n  nextStep?: string;\n}\n```\n\n#### WorkflowStatus\n```typescript\ntype WorkflowStatus = \n  | 'pending'\n  | 'running'\n  | 'paused'\n  | 'completed'\n  | 'failed'\n  | 'cancelled';\n```\n\n#### StepStatus\n```typescript\ninterface StepStatus {\n  stepId: string;\n  status: 'pending' | 'running' | 'completed' | 'failed' | 'skipped';\n  result?: ExecutionResult;\n  attempts: number;\n}\n```\n\n#### WorkflowResult\n```typescript\ninterface WorkflowResult {\n  executionId: string;\n  success: boolean;\n  completedSteps: number;\n  failedSteps: number;\n  outputs: Record<string, any>;\n  duration: number;\n}\n```\n\n#### Event Handlers\n```typescript\ntype StepCompleteHandler = (\n  executionId: string,\n  stepId: string,\n  result: ExecutionResult\n) => void;\n\ntype WorkflowCompleteHandler = (result: WorkflowResult) => void;\n\ntype CheckpointHandler = (checkpoint: WorkflowCheckpoint) => void;\n```\n\n### 2. Create `server/src/execution/workflow/orchestrator.ts`\n\nDefine the IWorkflowOrchestrator interface:\n\n```typescript\ninterface IWorkflowOrchestrator {\n  // Workflow execution\n  startWorkflow(\n    workflow: WorkflowDefinition,\n    initialContext?: Partial<WorkflowContext>\n  ): Promise<string>;\n  \n  resumeWorkflow(checkpointId: string): Promise<string>;\n  \n  // Control\n  pauseWorkflow(executionId: string): Promise<void>;\n  cancelWorkflow(executionId: string): Promise<void>;\n  \n  // Monitoring\n  getExecution(executionId: string): WorkflowExecution | null;\n  getStepStatus(executionId: string, stepId: string): StepStatus | null;\n  \n  // Waiting\n  waitForWorkflow(executionId: string): Promise<WorkflowResult>;\n  \n  // Checkpointing\n  saveCheckpoint(executionId: string): Promise<string>;\n  listCheckpoints(workflowId: string): Promise<WorkflowCheckpoint[]>;\n  \n  // Events\n  onStepComplete(handler: StepCompleteHandler): void;\n  onWorkflowComplete(handler: WorkflowCompleteHandler): void;\n  onCheckpoint(handler: CheckpointHandler): void;\n}\n```\n\nDefine the IWorkflowStorage interface:\n\n```typescript\ninterface IWorkflowStorage {\n  saveCheckpoint(id: string, checkpoint: WorkflowCheckpoint): Promise<void>;\n  loadCheckpoint(id: string): Promise<WorkflowCheckpoint | null>;\n  listCheckpoints(workflowId: string): Promise<WorkflowCheckpoint[]>;\n}\n```\n\n### 3. Create `server/src/execution/workflow/index.ts`\n\nExport all types and interfaces:\n\n```typescript\nexport type {\n  WorkflowDefinition,\n  WorkflowStep,\n  WorkflowExecution,\n  WorkflowContext,\n  WorkflowCheckpoint,\n  WorkflowStatus,\n  StepStatus,\n  WorkflowResult,\n  StepCompleteHandler,\n  WorkflowCompleteHandler,\n  CheckpointHandler,\n} from './types.js';\n\nexport type { IWorkflowOrchestrator, IWorkflowStorage } from './orchestrator.js';\n```\n\n## Acceptance Criteria\n- [ ] All types defined with proper TypeScript syntax\n- [ ] Types properly reference Layer 3 types (RetryPolicy, ExecutionResult)\n- [ ] Interfaces properly defined with all required methods\n- [ ] All types exported from index.ts\n- [ ] TypeScript compiles without errors\n- [ ] No circular dependencies\n\n## Dependencies\nRequires [[SPEC-005]] Resilience Layer types\n\n## Related\nImplements types for [[SPEC-006]]","status":"closed","priority":0,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-30 05:07:09","updated_at":"2025-10-30 05:43:55","closed_at":"2025-10-30 05:43:55","parent_id":null,"relationships":[],"tags":["foundation","layer-4","types","workflow"]}
{"id":"ISSUE-081","uuid":"6c63589c-5637-4310-91b8-bde05141b5d4","title":"Implement template rendering utilities","content":"## Overview\nImplement utility functions for template rendering, path extraction, and ID generation as specified in [[SPEC-006]].\n\n## Implementation Steps\n\n### 1. Create `server/src/execution/workflow/utils.ts`\n\n#### generateId Function\n```typescript\nexport function generateId(prefix: string): string {\n  // Generate unique ID with timestamp and random component\n  const timestamp = Date.now();\n  const random = Math.random().toString(36).substring(2, 9);\n  return `${prefix}-${timestamp}-${random}`;\n}\n```\n\n**Steps:**\n- Use current timestamp for uniqueness\n- Add random component for collision avoidance\n- Prefix with type identifier (e.g., 'execution', 'checkpoint')\n\n#### renderTemplate Function\n```typescript\nexport function renderTemplate(\n  template: string,\n  context: WorkflowContext\n): string {\n  let rendered = template;\n  \n  // Replace variables: {{variable}}\n  for (const [key, value] of Object.entries(context.variables)) {\n    rendered = rendered.replace(\n      new RegExp(`{{${key}}}`, 'g'),\n      String(value)\n    );\n  }\n  \n  // Replace outputs: {{output}}\n  for (const [key, value] of Object.entries(context.outputs)) {\n    rendered = rendered.replace(\n      new RegExp(`{{${key}}}`, 'g'),\n      String(value)\n    );\n  }\n  \n  return rendered;\n}\n```\n\n**Steps:**\n1. Create copy of template string\n2. Iterate through context.variables\n3. Replace all occurrences of `{{variableName}}` with actual value\n4. Convert values to strings\n5. Iterate through context.outputs  \n6. Replace all occurrences of `{{outputName}}` with actual value\n7. Use global regex replacement for multiple occurrences\n8. Return rendered template\n\n**Test cases:**\n- Simple variable replacement: `\"Hello {{name}}\"` → `\"Hello World\"`\n- Multiple variables: `\"{{greeting}} {{name}}!\"` → `\"Hello World!\"`\n- Outputs: `\"Files: {{filesChanged}}\"` → `\"Files: src/main.ts\"`\n- Missing variables: Should leave `{{missing}}` as-is or replace with empty string\n- Special characters: Handle values with special regex characters\n\n#### extractValue Function\n```typescript\nexport function extractValue(obj: any, path: string): any {\n  // Handle simple paths like \"output\" or nested like \"metadata.filesChanged\"\n  const parts = path.split('.');\n  let value: any = obj;\n  \n  for (const part of parts) {\n    if (value === null || value === undefined) {\n      return undefined;\n    }\n    value = value[part];\n  }\n  \n  return value;\n}\n```\n\n**Steps:**\n1. Split path by '.' to get array of keys\n2. Start with root object\n3. For each key in path:\n   - Check if current value is null/undefined → return undefined\n   - Navigate to next level using key\n4. Return final value\n\n**Test cases:**\n- Simple path: `extractValue(obj, 'output')` → `obj.output`\n- Nested path: `extractValue(obj, 'metadata.filesChanged')` → `obj.metadata.filesChanged`\n- Missing intermediate: `extractValue(obj, 'missing.value')` → `undefined`\n- Null handling: `extractValue(null, 'any')` → `undefined`\n- Array access: `extractValue(obj, 'items.0')` → `obj.items[0]` (optional enhancement)\n\n#### mergeContext Function (Optional Helper)\n```typescript\nexport function mergeContext(\n  base: WorkflowContext,\n  updates: Partial<WorkflowContext>\n): WorkflowContext {\n  return {\n    variables: { ...base.variables, ...updates.variables },\n    outputs: { ...base.outputs, ...updates.outputs },\n    shared: { ...base.shared, ...updates.shared },\n  };\n}\n```\n\n**Steps:**\n1. Create new context object\n2. Merge variables using spread operator\n3. Merge outputs using spread operator\n4. Merge shared state using spread operator\n5. Return new context (immutable update)\n\n### 2. Add tests in `server/src/execution/workflow/tests/unit/utils.test.ts`\n\nCreate comprehensive tests for each utility function:\n\n```typescript\ndescribe('Workflow Utilities', () => {\n  describe('generateId', () => {\n    it('should generate unique IDs with prefix', () => {\n      const id1 = generateId('test');\n      const id2 = generateId('test');\n      assert.notStrictEqual(id1, id2);\n      assert.ok(id1.startsWith('test-'));\n    });\n  });\n\n  describe('renderTemplate', () => {\n    it('should replace variables', () => {\n      const context = {\n        variables: { name: 'World' },\n        outputs: {},\n        shared: {},\n      };\n      const result = renderTemplate('Hello {{name}}', context);\n      assert.strictEqual(result, 'Hello World');\n    });\n    \n    it('should replace multiple occurrences', () => {\n      const context = {\n        variables: { value: 'test' },\n        outputs: {},\n        shared: {},\n      };\n      const result = renderTemplate('{{value}} and {{value}}', context);\n      assert.strictEqual(result, 'test and test');\n    });\n    \n    it('should replace outputs', () => {\n      const context = {\n        variables: {},\n        outputs: { result: 'success' },\n        shared: {},\n      };\n      const result = renderTemplate('Result: {{result}}', context);\n      assert.strictEqual(result, 'Result: success');\n    });\n  });\n\n  describe('extractValue', () => {\n    it('should extract simple values', () => {\n      const obj = { output: 'test' };\n      assert.strictEqual(extractValue(obj, 'output'), 'test');\n    });\n    \n    it('should extract nested values', () => {\n      const obj = { metadata: { filesChanged: ['file.ts'] } };\n      assert.deepStrictEqual(\n        extractValue(obj, 'metadata.filesChanged'),\n        ['file.ts']\n      );\n    });\n    \n    it('should return undefined for missing paths', () => {\n      const obj = { a: { b: 1 } };\n      assert.strictEqual(extractValue(obj, 'a.c'), undefined);\n    });\n  });\n});\n```\n\n### 3. Export from index.ts\n\n```typescript\nexport {\n  generateId,\n  renderTemplate,\n  extractValue,\n  mergeContext,\n} from './utils.js';\n```\n\n## Acceptance Criteria\n- [ ] generateId creates unique IDs with prefix\n- [ ] renderTemplate replaces {{variables}} correctly\n- [ ] renderTemplate handles multiple occurrences\n- [ ] renderTemplate handles both variables and outputs\n- [ ] extractValue handles simple paths\n- [ ] extractValue handles nested paths (dot notation)\n- [ ] extractValue returns undefined for missing paths\n- [ ] All utility functions have comprehensive tests\n- [ ] All tests pass\n- [ ] TypeScript compiles without errors\n\n## Dependencies\nRequires ISSUE-080 (types)\n\n## Related\nImplements utilities for [[SPEC-006]]","status":"closed","priority":0,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-30 05:08:06","updated_at":"2025-10-30 05:51:02","closed_at":"2025-10-30 05:51:02","parent_id":null,"relationships":[],"tags":["layer-4","templates","utilities","workflow"]}
{"id":"ISSUE-082","uuid":"4643d7ea-5bd3-47df-a2bc-b85f438e116d","title":"Implement LinearOrchestrator base structure","content":"## Overview\nCreate the LinearOrchestrator class skeleton with constructor, storage, and basic methods as specified in [[SPEC-006]].\n\n## Implementation Steps\n\n### 1. Create `server/src/execution/workflow/linear-orchestrator.ts`\n\n#### Class Structure\n```typescript\nimport type { IWorkflowOrchestrator, IWorkflowStorage } from './orchestrator.js';\nimport type { IResilientExecutor } from '../resilience/executor.js';\nimport type {\n  WorkflowDefinition,\n  WorkflowExecution,\n  WorkflowCheckpoint,\n  WorkflowContext,\n  WorkflowResult,\n  StepStatus,\n  StepCompleteHandler,\n  WorkflowCompleteHandler,\n  CheckpointHandler,\n} from './types.js';\n\nexport class LinearOrchestrator implements IWorkflowOrchestrator {\n  // Internal state\n  private executions = new Map<string, WorkflowExecution>();\n  private checkpoints = new Map<string, WorkflowCheckpoint>();\n  private workflows = new Map<string, WorkflowDefinition>();\n  \n  // Event handlers\n  private stepCompleteHandlers: StepCompleteHandler[] = [];\n  private workflowCompleteHandlers: WorkflowCompleteHandler[] = [];\n  private checkpointHandlers: CheckpointHandler[] = [];\n  \n  constructor(\n    private executor: IResilientExecutor,\n    private storage?: IWorkflowStorage\n  ) {}\n  \n  // Methods to implement in later issues\n  async startWorkflow(...) { }\n  async resumeWorkflow(...) { }\n  async pauseWorkflow(...) { }\n  async cancelWorkflow(...) { }\n  getExecution(...) { }\n  getStepStatus(...) { }\n  async waitForWorkflow(...) { }\n  async saveCheckpoint(...) { }\n  async listCheckpoints(...) { }\n  onStepComplete(...) { }\n  onWorkflowComplete(...) { }\n  onCheckpoint(...) { }\n}\n```\n\n**Steps:**\n1. Import all required types from types.ts and orchestrator.ts\n2. Import IResilientExecutor from Layer 3\n3. Declare class implementing IWorkflowOrchestrator\n4. Add private Maps for executions, checkpoints, workflows\n5. Add private arrays for event handlers\n6. Add constructor accepting executor and optional storage\n7. Add method stubs for all interface methods\n\n#### Implement Event Handler Registration\n\n```typescript\nonStepComplete(handler: StepCompleteHandler): void {\n  this.stepCompleteHandlers.push(handler);\n}\n\nonWorkflowComplete(handler: WorkflowCompleteHandler): void {\n  this.workflowCompleteHandlers.push(handler);\n}\n\nonCheckpoint(handler: CheckpointHandler): void {\n  this.checkpointHandlers.push(handler);\n}\n```\n\n**Steps:**\n1. Simply push handler to respective array\n2. No validation needed - handlers are optional\n3. Handlers will be called in registration order\n\n#### Implement getExecution\n\n```typescript\ngetExecution(executionId: string): WorkflowExecution | null {\n  return this.executions.get(executionId) || null;\n}\n```\n\n**Steps:**\n1. Look up execution by ID in Map\n2. Return execution or null if not found\n3. Return defensive copy to prevent external modifications (optional)\n\n#### Implement getStepStatus\n\n```typescript\ngetStepStatus(executionId: string, stepId: string): StepStatus | null {\n  const execution = this.executions.get(executionId);\n  if (!execution) {\n    return null;\n  }\n  \n  const result = execution.stepResults.get(stepId);\n  \n  // Determine status\n  let status: StepStatus['status'];\n  if (execution.completedSteps.includes(stepId)) {\n    status = 'completed';\n  } else if (execution.failedSteps.includes(stepId)) {\n    status = 'failed';\n  } else if (execution.skippedSteps.includes(stepId)) {\n    status = 'skipped';\n  } else if (execution.currentStep === stepId) {\n    status = 'running';\n  } else {\n    status = 'pending';\n  }\n  \n  return {\n    stepId,\n    status,\n    result,\n    attempts: 1, // TODO: Track attempts properly\n  };\n}\n```\n\n**Steps:**\n1. Get execution by ID → return null if not found\n2. Get result from stepResults Map\n3. Determine status by checking:\n   - Is step in completedSteps array? → 'completed'\n   - Is step in failedSteps array? → 'failed'\n   - Is step in skippedSteps array? → 'skipped'\n   - Is step the currentStep? → 'running'\n   - Otherwise → 'pending'\n4. Return StepStatus object with status, result, attempts\n\n#### Implement pauseWorkflow and cancelWorkflow\n\n```typescript\nasync pauseWorkflow(executionId: string): Promise<void> {\n  const execution = this.executions.get(executionId);\n  if (execution && execution.status === 'running') {\n    execution.status = 'paused';\n  }\n}\n\nasync cancelWorkflow(executionId: string): Promise<void> {\n  const execution = this.executions.get(executionId);\n  if (execution && execution.status !== 'completed') {\n    execution.status = 'cancelled';\n    execution.completedAt = new Date();\n  }\n}\n```\n\n**Steps for pauseWorkflow:**\n1. Get execution by ID\n2. Check if execution exists and is running\n3. Set status to 'paused'\n4. Workflow execution loop will check status and stop\n\n**Steps for cancelWorkflow:**\n1. Get execution by ID\n2. Check if execution exists and not already completed\n3. Set status to 'cancelled'\n4. Set completedAt timestamp\n5. Workflow execution loop will check status and stop\n\n### 2. Export from index.ts\n\n```typescript\nexport { LinearOrchestrator } from './linear-orchestrator.js';\n```\n\n### 3. Add basic tests\n\nCreate `server/src/execution/workflow/tests/unit/linear-orchestrator-base.test.ts`:\n\n```typescript\ndescribe('LinearOrchestrator Base', () => {\n  let mockExecutor: any;\n  let orchestrator: LinearOrchestrator;\n\n  beforeEach(() => {\n    mockExecutor = {\n      executeTask: async () => ({ success: true }),\n    };\n    orchestrator = new LinearOrchestrator(mockExecutor);\n  });\n\n  describe('Event Handlers', () => {\n    it('should register step complete handlers', () => {\n      const handler = () => {};\n      orchestrator.onStepComplete(handler);\n      // Handler registered (verified in later tests)\n    });\n    \n    it('should register workflow complete handlers', () => {\n      const handler = () => {};\n      orchestrator.onWorkflowComplete(handler);\n      // Handler registered\n    });\n  });\n\n  describe('getExecution', () => {\n    it('should return null for non-existent execution', () => {\n      const result = orchestrator.getExecution('non-existent');\n      assert.strictEqual(result, null);\n    });\n  });\n\n  describe('pauseWorkflow', () => {\n    it('should not throw for non-existent execution', async () => {\n      await orchestrator.pauseWorkflow('non-existent');\n      // Should not throw\n    });\n  });\n\n  describe('cancelWorkflow', () => {\n    it('should not throw for non-existent execution', async () => {\n      await orchestrator.cancelWorkflow('non-existent');\n      // Should not throw\n    });\n  });\n});\n```\n\n## Acceptance Criteria\n- [ ] LinearOrchestrator class created with all required fields\n- [ ] Constructor accepts executor and optional storage\n- [ ] Event handler registration methods work\n- [ ] getExecution returns execution or null\n- [ ] getStepStatus correctly determines step status\n- [ ] pauseWorkflow sets status to paused\n- [ ] cancelWorkflow sets status to cancelled\n- [ ] Basic tests pass\n- [ ] TypeScript compiles without errors\n- [ ] Class exported from index.ts\n\n## Dependencies\nRequires ISSUE-080 (types), ISSUE-081 (utils)\n\n## Related\nImplements base structure for [[SPEC-006]] LinearOrchestrator","status":"closed","priority":1,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-30 05:08:07","updated_at":"2025-10-30 06:01:15","closed_at":"2025-10-30 06:01:15","parent_id":null,"relationships":[],"tags":["implementation","layer-4","orchestrator","workflow"]}
{"id":"ISSUE-083","uuid":"2a81bb22-0207-466d-a2d5-7f2feda47f96","title":"Implement step execution logic","content":"## Overview\nImplement the step execution logic that creates tasks from workflow steps and executes them via the ResilientExecutor as specified in [[SPEC-006]].\n\n## Implementation Steps\n\n### 1. Add executeStep method to LinearOrchestrator\n\n```typescript\nprivate async executeStep(\n  step: WorkflowStep,\n  execution: WorkflowExecution,\n  workflow: WorkflowDefinition\n): Promise<ExecutionResult> {\n  // 1. Render prompt template with context\n  const prompt = renderTemplate(step.promptTemplate, execution.context);\n  \n  // 2. Build execution task\n  const task: ExecutionTask = {\n    id: generateId('task'),\n    type: step.taskType,\n    entityId: undefined,\n    prompt,\n    workDir: process.cwd(), // TODO: Make configurable via workflow metadata\n    priority: 0,\n    dependencies: [],\n    createdAt: new Date(),\n    config: {\n      timeout: step.timeout,\n    },\n  };\n  \n  // 3. Execute with resilience (includes retry logic)\n  const result = await this.executor.executeTask(task, step.retryPolicy);\n  \n  return result;\n}\n```\n\n**Implementation Steps:**\n\n1. **Render Prompt Template**\n   - Call renderTemplate utility with step.promptTemplate\n   - Pass execution.context for variable replacement\n   - Result is prompt string with all {{variables}} replaced\n\n2. **Build ExecutionTask**\n   - Create task ID using generateId utility\n   - Set type from step.taskType ('issue', 'spec', or 'custom')\n   - Set entityId to undefined (or extract from context if needed)\n   - Use rendered prompt\n   - Set workDir to process.cwd() (later make configurable)\n   - Set priority to 0 (or extract from workflow config)\n   - Empty dependencies (step dependencies handled by orchestrator)\n   - Set createdAt to current time\n   - Add config with timeout from step\n\n3. **Execute via ResilientExecutor**\n   - Call this.executor.executeTask with task\n   - Pass step.retryPolicy for step-specific retry behavior\n   - Await result\n   - Return ExecutionResult (includes success, output, error, etc.)\n\n**Error Handling:**\n- Let errors bubble up to workflow execution loop\n- ResilientExecutor handles retries automatically\n- Workflow loop will catch and handle based on continueOnStepFailure\n\n### 2. Add helper method for output mapping\n\n```typescript\nprivate applyOutputMapping(\n  step: WorkflowStep,\n  result: ExecutionResult,\n  context: WorkflowContext\n): void {\n  if (!step.outputMapping) {\n    return;\n  }\n  \n  for (const [contextKey, resultPath] of Object.entries(step.outputMapping)) {\n    const value = extractValue(result, resultPath);\n    context.outputs[contextKey] = value;\n  }\n}\n```\n\n**Implementation Steps:**\n\n1. **Check if outputMapping exists**\n   - If step.outputMapping is undefined/null, return early\n\n2. **Iterate through mapping entries**\n   - Each entry is [contextKey, resultPath]\n   - contextKey: Key to store in context.outputs\n   - resultPath: Path to extract from result (e.g., \"output\", \"metadata.filesChanged\")\n\n3. **Extract and store values**\n   - Call extractValue(result, resultPath)\n   - Store extracted value in context.outputs[contextKey]\n   - Values become available to subsequent steps via {{contextKey}}\n\n**Examples:**\n- `{ analysis: \"output\" }` → Stores result.output as context.outputs.analysis\n- `{ files: \"metadata.filesChanged\" }` → Stores result.metadata.filesChanged as context.outputs.files\n\n### 3. Add dependency checking helper\n\n```typescript\nprivate areDependenciesMet(\n  step: WorkflowStep,\n  execution: WorkflowExecution\n): boolean {\n  for (const depId of step.dependsOn) {\n    if (!execution.completedSteps.includes(depId)) {\n      return false;\n    }\n  }\n  return true;\n}\n```\n\n**Implementation Steps:**\n\n1. **Iterate through step dependencies**\n   - step.dependsOn is array of step IDs that must complete first\n\n2. **Check if each dependency is completed**\n   - Look in execution.completedSteps array\n   - If any dependency not found → return false\n\n3. **Return true if all dependencies met**\n   - All dependencies in completedSteps → return true\n   - Empty dependsOn array → return true (no dependencies)\n\n**Usage in workflow loop:**\n```typescript\nif (!this.areDependenciesMet(step, execution)) {\n  // Dependency not met - fail or skip step\n  execution.failedSteps.push(step.id);\n  if (!workflow.config.continueOnStepFailure) {\n    execution.status = 'failed';\n    return;\n  }\n  continue;\n}\n```\n\n### 4. Add tests\n\nCreate `server/src/execution/workflow/tests/unit/step-execution.test.ts`:\n\n```typescript\ndescribe('Step Execution', () => {\n  let mockExecutor: any;\n  let orchestrator: LinearOrchestrator;\n\n  beforeEach(() => {\n    mockExecutor = {\n      executeTask: jest.fn().mockResolvedValue({\n        taskId: 'task-1',\n        executionId: 'exec-1',\n        success: true,\n        exitCode: 0,\n        output: 'Test output',\n        startedAt: new Date(),\n        completedAt: new Date(),\n        duration: 100,\n        metadata: {\n          filesChanged: ['file1.ts', 'file2.ts'],\n        },\n      }),\n    };\n    orchestrator = new LinearOrchestrator(mockExecutor);\n  });\n\n  describe('executeStep', () => {\n    it('should render template and execute task', async () => {\n      const step: WorkflowStep = {\n        id: 'step-1',\n        name: 'Test Step',\n        taskType: 'issue',\n        promptTemplate: 'Fix issue {{issueId}}',\n        dependsOn: [],\n      };\n      \n      const execution: WorkflowExecution = {\n        id: 'exec-1',\n        workflowId: 'wf-1',\n        status: 'running',\n        completedSteps: [],\n        failedSteps: [],\n        skippedSteps: [],\n        context: {\n          variables: { issueId: 'ISSUE-001' },\n          outputs: {},\n          shared: {},\n        },\n        stepResults: new Map(),\n        startedAt: new Date(),\n      };\n      \n      const result = await orchestrator['executeStep'](step, execution, workflow);\n      \n      assert.strictEqual(result.success, true);\n      assert.ok(mockExecutor.executeTask.called);\n      \n      const taskArg = mockExecutor.executeTask.args[0][0];\n      assert.strictEqual(taskArg.prompt, 'Fix issue ISSUE-001');\n      assert.strictEqual(taskArg.type, 'issue');\n    });\n  });\n\n  describe('applyOutputMapping', () => {\n    it('should map result values to context', () => {\n      const step: WorkflowStep = {\n        id: 'step-1',\n        name: 'Test',\n        taskType: 'issue',\n        promptTemplate: 'Test',\n        dependsOn: [],\n        outputMapping: {\n          analysis: 'output',\n          files: 'metadata.filesChanged',\n        },\n      };\n      \n      const result: ExecutionResult = {\n        taskId: 'task-1',\n        executionId: 'exec-1',\n        success: true,\n        exitCode: 0,\n        output: 'Analysis result',\n        startedAt: new Date(),\n        completedAt: new Date(),\n        duration: 100,\n        metadata: {\n          filesChanged: ['file1.ts'],\n        },\n      };\n      \n      const context: WorkflowContext = {\n        variables: {},\n        outputs: {},\n        shared: {},\n      };\n      \n      orchestrator['applyOutputMapping'](step, result, context);\n      \n      assert.strictEqual(context.outputs.analysis, 'Analysis result');\n      assert.deepStrictEqual(context.outputs.files, ['file1.ts']);\n    });\n  });\n\n  describe('areDependenciesMet', () => {\n    it('should return true when all dependencies completed', () => {\n      const step: WorkflowStep = {\n        id: 'step-2',\n        name: 'Test',\n        taskType: 'issue',\n        promptTemplate: 'Test',\n        dependsOn: ['step-1'],\n      };\n      \n      const execution: WorkflowExecution = {\n        completedSteps: ['step-1'],\n        // ... other fields\n      };\n      \n      const result = orchestrator['areDependenciesMet'](step, execution);\n      assert.strictEqual(result, true);\n    });\n    \n    it('should return false when dependencies not met', () => {\n      const step: WorkflowStep = {\n        id: 'step-2',\n        name: 'Test',\n        taskType: 'issue',\n        promptTemplate: 'Test',\n        dependsOn: ['step-1'],\n      };\n      \n      const execution: WorkflowExecution = {\n        completedSteps: [],\n        // ... other fields\n      };\n      \n      const result = orchestrator['areDependenciesMet'](step, execution);\n      assert.strictEqual(result, false);\n    });\n  });\n});\n```\n\n## Acceptance Criteria\n- [ ] executeStep method renders template correctly\n- [ ] executeStep creates ExecutionTask with correct fields\n- [ ] executeStep calls executor.executeTask with retry policy\n- [ ] executeStep returns ExecutionResult\n- [ ] applyOutputMapping extracts values correctly\n- [ ] applyOutputMapping handles nested paths\n- [ ] applyOutputMapping stores values in context.outputs\n- [ ] areDependenciesMet returns true when all dependencies met\n- [ ] areDependenciesMet returns false when dependencies missing\n- [ ] All tests pass\n- [ ] TypeScript compiles without errors\n\n## Dependencies\nRequires ISSUE-082 (LinearOrchestrator base)\n\n## Related\nImplements step execution for [[SPEC-006]]","status":"closed","priority":1,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-30 05:09:48","updated_at":"2025-10-30 06:49:17","closed_at":"2025-10-30 06:39:23","parent_id":null,"relationships":[],"tags":["execution","layer-4","steps","workflow"]}
{"id":"ISSUE-084","uuid":"12a4adde-6c2a-42ee-a42a-bc6b0afed815","title":"Implement workflow execution flow","content":"## Overview\nImplement the main workflow execution loop including startWorkflow, sequential step execution, and completion handling as specified in [[SPEC-006]].\n\n## Implementation Steps\n\n### 1. Implement startWorkflow method\n\n```typescript\nasync startWorkflow(\n  workflow: WorkflowDefinition,\n  initialContext?: Partial<WorkflowContext>\n): Promise<string> {\n  // 1. Create execution\n  const execution: WorkflowExecution = {\n    id: generateId('execution'),\n    workflowId: workflow.id,\n    status: 'pending',\n    completedSteps: [],\n    failedSteps: [],\n    skippedSteps: [],\n    context: {\n      variables: initialContext?.variables || {},\n      outputs: initialContext?.outputs || {},\n      shared: initialContext?.shared || {},\n    },\n    stepResults: new Map(),\n    startedAt: new Date(),\n  };\n  \n  // 2. Store execution and workflow\n  this.executions.set(execution.id, execution);\n  this.workflows.set(workflow.id, workflow);\n  \n  // 3. Start execution in background (non-blocking)\n  this.executeWorkflow(workflow, execution).catch(error => {\n    execution.status = 'failed';\n    execution.completedAt = new Date();\n    console.error('Workflow execution failed:', error);\n  });\n  \n  // 4. Return execution ID immediately\n  return execution.id;\n}\n```\n\n**Implementation Steps:**\n\n1. **Create WorkflowExecution object**\n   - Generate unique execution ID\n   - Set workflowId from workflow\n   - Initialize status as 'pending'\n   - Initialize empty arrays for step tracking\n   - Merge initialContext with defaults\n   - Create empty stepResults Map\n   - Set startedAt timestamp\n\n2. **Store execution and workflow**\n   - Store execution in executions Map\n   - Store workflow in workflows Map (for later resume)\n\n3. **Start background execution**\n   - Call executeWorkflow asynchronously (don't await)\n   - Catch errors and update execution status\n   - Log errors for debugging\n\n4. **Return execution ID**\n   - Return immediately (non-blocking)\n   - Caller can use ID to monitor progress\n\n### 2. Implement executeWorkflow method (main loop)\n\n```typescript\nprivate async executeWorkflow(\n  workflow: WorkflowDefinition,\n  execution: WorkflowExecution,\n  startFromStep?: string\n): Promise<void> {\n  execution.status = 'running';\n  \n  // 1. Find starting point\n  let startIndex = 0;\n  if (startFromStep) {\n    startIndex = workflow.steps.findIndex(s => s.id === startFromStep);\n    if (startIndex === -1) {\n      throw new Error(`Step ${startFromStep} not found in workflow`);\n    }\n  }\n  \n  // 2. Execute steps sequentially\n  for (let i = startIndex; i < workflow.steps.length; i++) {\n    const step = workflow.steps[i];\n    \n    // Check if paused or cancelled\n    if (execution.status === 'paused' || execution.status === 'cancelled') {\n      return;\n    }\n    \n    // Check dependencies\n    if (!this.areDependenciesMet(step, execution)) {\n      execution.failedSteps.push(step.id);\n      if (!workflow.config.continueOnStepFailure) {\n        execution.status = 'failed';\n        execution.completedAt = new Date();\n        return;\n      }\n      continue;\n    }\n    \n    // Check condition\n    if (step.condition && !step.condition(execution.context)) {\n      execution.skippedSteps.push(step.id);\n      continue;\n    }\n    \n    // Execute step\n    execution.currentStep = step.id;\n    \n    try {\n      const result = await this.executeStep(step, execution, workflow);\n      \n      // Store result\n      execution.stepResults.set(step.id, result);\n      execution.completedSteps.push(step.id);\n      \n      // Apply output mapping\n      this.applyOutputMapping(step, result, execution.context);\n      \n      // Emit step complete event\n      for (const handler of this.stepCompleteHandlers) {\n        handler(execution.id, step.id, result);\n      }\n      \n      // Checkpoint if configured\n      if (\n        workflow.config.checkpointInterval &&\n        execution.completedSteps.length % workflow.config.checkpointInterval === 0\n      ) {\n        await this.saveCheckpoint(execution.id);\n      }\n    } catch (error) {\n      execution.failedSteps.push(step.id);\n      \n      if (!workflow.config.continueOnStepFailure) {\n        execution.status = 'failed';\n        execution.completedAt = new Date();\n        throw error;\n      }\n    }\n  }\n  \n  // 3. Workflow completed\n  execution.status = 'completed';\n  execution.completedAt = new Date();\n  \n  // 4. Emit workflow complete event\n  const result: WorkflowResult = {\n    executionId: execution.id,\n    success: execution.failedSteps.length === 0,\n    completedSteps: execution.completedSteps.length,\n    failedSteps: execution.failedSteps.length,\n    outputs: execution.context.outputs,\n    duration: execution.completedAt.getTime() - execution.startedAt.getTime(),\n  };\n  \n  for (const handler of this.workflowCompleteHandlers) {\n    handler(result);\n  }\n}\n```\n\n**Implementation Steps:**\n\n1. **Set status to running**\n   - Change from 'pending' to 'running'\n\n2. **Find starting index**\n   - If startFromStep provided (for resume), find its index\n   - Throw error if step not found\n   - Default to 0 for new workflows\n\n3. **Execute steps sequentially in for loop**\n   \n   For each step:\n   \n   a. **Check pause/cancel**\n      - If status changed to 'paused' or 'cancelled', exit early\n   \n   b. **Check dependencies**\n      - Call areDependenciesMet\n      - If not met:\n        - Add to failedSteps\n        - If continueOnStepFailure=false, fail workflow\n        - Otherwise continue to next step\n   \n   c. **Check condition**\n      - If step.condition exists, evaluate with context\n      - If returns false, add to skippedSteps and continue\n   \n   d. **Execute step**\n      - Set currentStep\n      - Call executeStep\n      - Store result in stepResults Map\n      - Add step ID to completedSteps\n      - Apply output mapping\n      - Emit step complete event to all handlers\n      - Checkpoint if interval reached\n   \n   e. **Handle errors**\n      - Catch exceptions from executeStep\n      - Add to failedSteps\n      - If continueOnStepFailure=false, fail workflow\n      - Otherwise continue to next step\n\n4. **Mark workflow as completed**\n   - Set status to 'completed'\n   - Set completedAt timestamp\n\n5. **Emit workflow complete event**\n   - Create WorkflowResult\n   - Call all workflow complete handlers\n\n### 3. Add tests\n\nCreate `server/src/execution/workflow/tests/unit/workflow-execution.test.ts`:\n\n```typescript\ndescribe('Workflow Execution', () => {\n  it('should execute simple linear workflow', async () => {\n    const mockExecutor = createMockExecutor();\n    const orchestrator = new LinearOrchestrator(mockExecutor);\n    \n    const workflow: WorkflowDefinition = {\n      id: 'test-workflow',\n      name: 'Test',\n      version: '1.0',\n      steps: [\n        {\n          id: 'step-1',\n          name: 'First Step',\n          taskType: 'custom',\n          promptTemplate: 'Do step 1',\n          dependsOn: [],\n        },\n        {\n          id: 'step-2',\n          name: 'Second Step',\n          taskType: 'custom',\n          promptTemplate: 'Do step 2',\n          dependsOn: ['step-1'],\n        },\n      ],\n      config: {},\n    };\n    \n    const executionId = await orchestrator.startWorkflow(workflow);\n    const result = await orchestrator.waitForWorkflow(executionId);\n    \n    assert.strictEqual(result.success, true);\n    assert.strictEqual(result.completedSteps, 2);\n    assert.strictEqual(result.failedSteps, 0);\n  });\n  \n  it('should pass context between steps', async () => {\n    // Test that outputs from step 1 are available in step 2\n  });\n  \n  it('should skip steps when dependencies not met', async () => {\n    // Test dependency checking\n  });\n  \n  it('should skip conditional steps', async () => {\n    // Test step.condition evaluation\n  });\n  \n  it('should fail workflow on step failure when continueOnStepFailure=false', async () => {\n    // Test error handling\n  });\n  \n  it('should continue on step failure when continueOnStepFailure=true', async () => {\n    // Test continue on failure\n  });\n  \n  it('should emit step complete events', async () => {\n    // Test event emission\n  });\n  \n  it('should emit workflow complete event', async () => {\n    // Test event emission\n  });\n});\n```\n\n## Acceptance Criteria\n- [ ] startWorkflow creates execution and stores it\n- [ ] startWorkflow returns execution ID immediately\n- [ ] startWorkflow starts background execution\n- [ ] executeWorkflow executes steps in sequence\n- [ ] executeWorkflow checks dependencies before each step\n- [ ] executeWorkflow evaluates step conditions\n- [ ] executeWorkflow updates execution state correctly\n- [ ] executeWorkflow handles pause/cancel\n- [ ] executeWorkflow emits events correctly\n- [ ] continueOnStepFailure works correctly\n- [ ] All tests pass\n- [ ] TypeScript compiles without errors\n\n## Dependencies\nRequires ISSUE-083 (step execution logic)\n\n## Related\nImplements main execution loop for [[SPEC-006]]","status":"closed","priority":1,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-30 05:09:48","updated_at":"2025-10-30 07:10:03","closed_at":"2025-10-30 07:10:03","parent_id":null,"relationships":[],"tags":["execution","layer-4","orchestration","workflow"]}
{"id":"ISSUE-085","uuid":"dd6294d2-c1cd-496c-8554-5e7353283880","title":"Implement checkpointing and resumption in LinearOrchestrator","content":"## Overview\nImplement the checkpointing and resumption logic in LinearOrchestrator to enable crash recovery and workflow resumption from saved state.\n\nReferences: [[SPEC-006]]\nDepends on: [[ISSUE-084]]\n\n## Implementation Steps\n\n### 1. Implement checkpoint creation\nIn `linear-orchestrator.ts`, add checkpoint creation logic:\n\n```typescript\nprivate async _createCheckpoint(execution: WorkflowExecution): Promise<void> {\n  const checkpoint: WorkflowCheckpoint = {\n    workflowId: execution.workflowId,\n    executionId: execution.executionId,\n    definition: execution.definition,\n    state: {\n      status: execution.status,\n      currentStepIndex: execution.currentStepIndex,\n      context: { ...execution.context },\n      stepResults: [...execution.stepResults],\n      error: execution.error,\n      startedAt: execution.startedAt,\n      completedAt: execution.completedAt,\n    },\n    createdAt: new Date(),\n  };\n\n  if (this._storage) {\n    await this._storage.saveCheckpoint(checkpoint);\n  }\n\n  // Emit checkpoint event\n  this._checkpointHandlers.forEach(handler => {\n    handler(checkpoint);\n  });\n}\n```\n\n### 2. Add checkpoint intervals\nModify executeWorkflow to checkpoint at intervals:\n\n```typescript\n// In executeWorkflow, after each successful step:\nif (checkpointInterval && \n    (i + 1) % checkpointInterval === 0 && \n    i < steps.length - 1) {\n  await this._createCheckpoint(execution);\n}\n```\n\n### 3. Implement resumeWorkflow\nAdd workflow resumption from checkpoint:\n\n```typescript\nasync resumeWorkflow(\n  executionId: string,\n  options?: { checkpointInterval?: number }\n): Promise<string> {\n  if (!this._storage) {\n    throw new Error('Cannot resume workflow: no storage configured');\n  }\n\n  // Load checkpoint\n  const checkpoint = await this._storage.loadCheckpoint(executionId);\n  if (!checkpoint) {\n    throw new Error(`No checkpoint found for execution ${executionId}`);\n  }\n\n  // Restore execution state\n  const execution: WorkflowExecution = {\n    workflowId: checkpoint.workflowId,\n    executionId: checkpoint.executionId,\n    definition: checkpoint.definition,\n    status: 'running',\n    currentStepIndex: checkpoint.state.currentStepIndex,\n    context: { ...checkpoint.state.context },\n    stepResults: [...checkpoint.state.stepResults],\n    startedAt: checkpoint.state.startedAt,\n    resumedAt: new Date(),\n  };\n\n  this._executions.set(executionId, execution);\n\n  // Emit resume event\n  this._resumeHandlers.forEach(handler => {\n    handler(executionId, checkpoint);\n  });\n\n  // Continue execution from saved point\n  await this.executeWorkflow(execution, options);\n\n  return executionId;\n}\n```\n\n### 4. Add event handlers\nAdd checkpoint and resume event handlers:\n\n```typescript\nonCheckpoint(handler: WorkflowCheckpointHandler): void {\n  this._checkpointHandlers.push(handler);\n}\n\nonResume(handler: WorkflowResumeHandler): void {\n  this._resumeHandlers.push(handler);\n}\n```\n\n### 5. Update types\nAdd event handler types in `types.ts`:\n\n```typescript\nexport type WorkflowCheckpointHandler = (checkpoint: WorkflowCheckpoint) => void;\nexport type WorkflowResumeHandler = (executionId: string, checkpoint: WorkflowCheckpoint) => void;\n```\n\n### 6. Implement in-memory storage (for testing)\nCreate `memory-storage.ts`:\n\n```typescript\nexport class InMemoryWorkflowStorage implements IWorkflowStorage {\n  private checkpoints = new Map<string, WorkflowCheckpoint>();\n\n  async saveCheckpoint(checkpoint: WorkflowCheckpoint): Promise<void> {\n    this.checkpoints.set(checkpoint.executionId, checkpoint);\n  }\n\n  async loadCheckpoint(executionId: string): Promise<WorkflowCheckpoint | null> {\n    return this.checkpoints.get(executionId) || null;\n  }\n\n  async listCheckpoints(workflowId?: string): Promise<WorkflowCheckpoint[]> {\n    const all = Array.from(this.checkpoints.values());\n    if (workflowId) {\n      return all.filter(cp => cp.workflowId === workflowId);\n    }\n    return all;\n  }\n\n  async deleteCheckpoint(executionId: string): Promise<void> {\n    this.checkpoints.delete(executionId);\n  }\n\n  clear(): void {\n    this.checkpoints.clear();\n  }\n}\n```\n\n## Test Cases\n\n### Basic checkpoint creation\n```typescript\nit('should create checkpoint after specified interval', async () => {\n  const storage = new InMemoryWorkflowStorage();\n  const orchestrator = new LinearOrchestrator(resilientExecutor, storage);\n  \n  const workflow: WorkflowDefinition = {\n    id: 'test-workflow',\n    steps: [\n      { id: 'step1', taskType: 'issue', prompt: 'Step 1' },\n      { id: 'step2', taskType: 'issue', prompt: 'Step 2' },\n      { id: 'step3', taskType: 'issue', prompt: 'Step 3' },\n    ],\n  };\n\n  await orchestrator.startWorkflow(workflow, '/test', { checkpointInterval: 2 });\n  \n  const checkpoints = await storage.listCheckpoints();\n  assert.ok(checkpoints.length > 0);\n});\n```\n\n### Resume from checkpoint\n```typescript\nit('should resume workflow from checkpoint', async () => {\n  const storage = new InMemoryWorkflowStorage();\n  const orchestrator = new LinearOrchestrator(resilientExecutor, storage);\n  \n  // Start workflow that will be interrupted\n  const executionId = await orchestrator.startWorkflow(workflow, '/test', { \n    checkpointInterval: 1 \n  });\n  \n  // Simulate interruption after step 1\n  await orchestrator.pauseWorkflow(executionId);\n  \n  // Resume from checkpoint\n  await orchestrator.resumeWorkflow(executionId);\n  \n  const execution = orchestrator.getExecution(executionId);\n  assert.strictEqual(execution?.status, 'completed');\n});\n```\n\n### Resume continues from correct step\n```typescript\nit('should resume from correct step index', async () => {\n  const storage = new InMemoryWorkflowStorage();\n  const orchestrator = new LinearOrchestrator(resilientExecutor, storage);\n  \n  const workflow: WorkflowDefinition = {\n    id: 'test-workflow',\n    steps: [\n      { id: 'step1', taskType: 'issue', prompt: 'Step 1' },\n      { id: 'step2', taskType: 'issue', prompt: 'Step 2' },\n      { id: 'step3', taskType: 'issue', prompt: 'Step 3' },\n    ],\n  };\n\n  const executionId = await orchestrator.startWorkflow(workflow, '/test', { \n    checkpointInterval: 1 \n  });\n  \n  // Wait for step 1 to complete\n  await new Promise(resolve => setTimeout(resolve, 100));\n  await orchestrator.pauseWorkflow(executionId);\n  \n  // Check checkpoint has step 1 completed\n  const checkpoint = await storage.loadCheckpoint(executionId);\n  assert.strictEqual(checkpoint?.state.currentStepIndex, 1);\n  assert.strictEqual(checkpoint?.state.stepResults.length, 1);\n  \n  // Resume should continue from step 2\n  await orchestrator.resumeWorkflow(executionId);\n  \n  const execution = orchestrator.getExecution(executionId);\n  assert.strictEqual(execution?.stepResults.length, 3);\n});\n```\n\n## Acceptance Criteria\n- [ ] Checkpoints created at specified intervals\n- [ ] Checkpoints contain complete execution state\n- [ ] resumeWorkflow restores state from checkpoint\n- [ ] Resumed workflows continue from correct step\n- [ ] Checkpoint and resume events emitted\n- [ ] InMemoryWorkflowStorage implemented\n- [ ] All test cases pass","status":"closed","priority":0,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-30 05:11:09","updated_at":"2025-10-30 07:24:39","closed_at":"2025-10-30 07:24:39","parent_id":null,"relationships":[],"tags":["checkpointing","implementation","workflow"]}
{"id":"ISSUE-086","uuid":"174cca17-d341-46b9-91a0-dc397c0b9984","title":"Implement control and monitoring methods in LinearOrchestrator","content":"## Overview\nImplement control methods (pause, cancel, waitForWorkflow) and monitoring methods (listCheckpoints, getStepStatus) in LinearOrchestrator for workflow management.\n\nReferences: [[SPEC-006]]\nDepends on: [[ISSUE-084]], [[ISSUE-085]]\n\n## Implementation Steps\n\n### 1. Implement waitForWorkflow\nAdd method to wait for workflow completion:\n\n```typescript\nasync waitForWorkflow(executionId: string): Promise<WorkflowExecution> {\n  const execution = this._executions.get(executionId);\n  if (!execution) {\n    throw new Error(`Workflow execution ${executionId} not found`);\n  }\n\n  // If already completed/failed/cancelled, return immediately\n  if (['completed', 'failed', 'cancelled'].includes(execution.status)) {\n    return execution;\n  }\n\n  // Wait for completion by polling or using events\n  return new Promise((resolve, reject) => {\n    const checkInterval = setInterval(() => {\n      const current = this._executions.get(executionId);\n      if (!current) {\n        clearInterval(checkInterval);\n        reject(new Error(`Workflow execution ${executionId} not found`));\n        return;\n      }\n\n      if (['completed', 'failed', 'cancelled'].includes(current.status)) {\n        clearInterval(checkInterval);\n        resolve(current);\n      }\n    }, 100);\n\n    // Timeout after 5 minutes\n    setTimeout(() => {\n      clearInterval(checkInterval);\n      reject(new Error(`Timeout waiting for workflow ${executionId}`));\n    }, 300000);\n  });\n}\n```\n\n### 2. Enhance pauseWorkflow\nUpdate pause method to handle running workflows:\n\n```typescript\nasync pauseWorkflow(executionId: string): Promise<void> {\n  const execution = this._executions.get(executionId);\n  if (!execution) {\n    throw new Error(`Workflow execution ${executionId} not found`);\n  }\n\n  if (execution.status !== 'running') {\n    throw new Error(\n      `Cannot pause workflow in ${execution.status} state`\n    );\n  }\n\n  execution.status = 'paused';\n  execution.pausedAt = new Date();\n\n  // Create checkpoint when pausing\n  await this._createCheckpoint(execution);\n\n  // Emit pause event\n  this._pauseHandlers.forEach(handler => {\n    handler(executionId);\n  });\n}\n```\n\n### 3. Enhance cancelWorkflow\nUpdate cancel method with cleanup:\n\n```typescript\nasync cancelWorkflow(executionId: string): Promise<void> {\n  const execution = this._executions.get(executionId);\n  if (!execution) {\n    throw new Error(`Workflow execution ${executionId} not found`);\n  }\n\n  if (['completed', 'cancelled'].includes(execution.status)) {\n    return; // Already done\n  }\n\n  execution.status = 'cancelled';\n  execution.completedAt = new Date();\n\n  // Create final checkpoint\n  await this._createCheckpoint(execution);\n\n  // Emit cancel event\n  this._cancelHandlers.forEach(handler => {\n    handler(executionId);\n  });\n}\n```\n\n### 4. Implement listCheckpoints\nAdd method to list checkpoints:\n\n```typescript\nasync listCheckpoints(workflowId?: string): Promise<WorkflowCheckpoint[]> {\n  if (!this._storage) {\n    return [];\n  }\n\n  return this._storage.listCheckpoints(workflowId);\n}\n```\n\n### 5. Enhance getStepStatus\nImprove step status retrieval:\n\n```typescript\ngetStepStatus(executionId: string, stepId: string): {\n  status: 'pending' | 'running' | 'completed' | 'failed' | 'skipped';\n  result?: ResilientExecutionResult;\n  error?: string;\n} | null {\n  const execution = this._executions.get(executionId);\n  if (!execution) {\n    return null;\n  }\n\n  const stepIndex = execution.definition.steps.findIndex(s => s.id === stepId);\n  if (stepIndex === -1) {\n    return null;\n  }\n\n  const result = execution.stepResults[stepIndex];\n  \n  if (stepIndex < execution.currentStepIndex) {\n    // Step already executed\n    return {\n      status: result?.success ? 'completed' : 'failed',\n      result,\n      error: result?.error,\n    };\n  } else if (stepIndex === execution.currentStepIndex) {\n    // Currently executing\n    return {\n      status: 'running',\n      result,\n    };\n  } else {\n    // Not yet executed\n    return {\n      status: 'pending',\n    };\n  }\n}\n```\n\n### 6. Add event handlers\nAdd missing event handler registration methods:\n\n```typescript\nonPause(handler: WorkflowPauseHandler): void {\n  this._pauseHandlers.push(handler);\n}\n\nonCancel(handler: WorkflowCancelHandler): void {\n  this._cancelHandlers.push(handler);\n}\n```\n\n### 7. Update types\nAdd event handler types in `types.ts`:\n\n```typescript\nexport type WorkflowPauseHandler = (executionId: string) => void;\nexport type WorkflowCancelHandler = (executionId: string) => void;\n```\n\n## Test Cases\n\n### waitForWorkflow completes\n```typescript\nit('should wait for workflow to complete', async () => {\n  const orchestrator = new LinearOrchestrator(resilientExecutor);\n  \n  const workflow: WorkflowDefinition = {\n    id: 'test-workflow',\n    steps: [\n      { id: 'step1', taskType: 'issue', prompt: 'Step 1' },\n      { id: 'step2', taskType: 'issue', prompt: 'Step 2' },\n    ],\n  };\n\n  const executionId = await orchestrator.startWorkflow(workflow, '/test');\n  const execution = await orchestrator.waitForWorkflow(executionId);\n  \n  assert.strictEqual(execution.status, 'completed');\n  assert.strictEqual(execution.stepResults.length, 2);\n});\n```\n\n### pauseWorkflow creates checkpoint\n```typescript\nit('should create checkpoint when pausing', async () => {\n  const storage = new InMemoryWorkflowStorage();\n  const orchestrator = new LinearOrchestrator(resilientExecutor, storage);\n  \n  const executionId = await orchestrator.startWorkflow(workflow, '/test');\n  \n  // Wait a bit for execution to start\n  await new Promise(resolve => setTimeout(resolve, 50));\n  \n  await orchestrator.pauseWorkflow(executionId);\n  \n  const checkpoints = await storage.listCheckpoints();\n  assert.strictEqual(checkpoints.length, 1);\n  assert.strictEqual(checkpoints[0].state.status, 'paused');\n});\n```\n\n### cancelWorkflow stops execution\n```typescript\nit('should cancel running workflow', async () => {\n  const orchestrator = new LinearOrchestrator(resilientExecutor);\n  \n  const workflow: WorkflowDefinition = {\n    id: 'test-workflow',\n    steps: [\n      { id: 'step1', taskType: 'issue', prompt: 'Step 1' },\n      { id: 'step2', taskType: 'issue', prompt: 'Step 2' },\n      { id: 'step3', taskType: 'issue', prompt: 'Step 3' },\n    ],\n  };\n\n  const executionId = await orchestrator.startWorkflow(workflow, '/test');\n  \n  // Cancel after short delay\n  await new Promise(resolve => setTimeout(resolve, 50));\n  await orchestrator.cancelWorkflow(executionId);\n  \n  const execution = orchestrator.getExecution(executionId);\n  assert.strictEqual(execution?.status, 'cancelled');\n});\n```\n\n### listCheckpoints filters by workflowId\n```typescript\nit('should list checkpoints filtered by workflowId', async () => {\n  const storage = new InMemoryWorkflowStorage();\n  const orchestrator = new LinearOrchestrator(resilientExecutor, storage);\n  \n  const workflow1: WorkflowDefinition = {\n    id: 'workflow-1',\n    steps: [{ id: 'step1', taskType: 'issue', prompt: 'Step 1' }],\n  };\n  \n  const workflow2: WorkflowDefinition = {\n    id: 'workflow-2',\n    steps: [{ id: 'step1', taskType: 'issue', prompt: 'Step 1' }],\n  };\n\n  await orchestrator.startWorkflow(workflow1, '/test', { checkpointInterval: 1 });\n  await orchestrator.startWorkflow(workflow2, '/test', { checkpointInterval: 1 });\n  \n  await new Promise(resolve => setTimeout(resolve, 200));\n  \n  const checkpoints1 = await orchestrator.listCheckpoints('workflow-1');\n  const checkpoints2 = await orchestrator.listCheckpoints('workflow-2');\n  \n  assert.ok(checkpoints1.every(cp => cp.workflowId === 'workflow-1'));\n  assert.ok(checkpoints2.every(cp => cp.workflowId === 'workflow-2'));\n});\n```\n\n### getStepStatus returns correct status\n```typescript\nit('should return correct step status', async () => {\n  const orchestrator = new LinearOrchestrator(resilientExecutor);\n  \n  const workflow: WorkflowDefinition = {\n    id: 'test-workflow',\n    steps: [\n      { id: 'step1', taskType: 'issue', prompt: 'Step 1' },\n      { id: 'step2', taskType: 'issue', prompt: 'Step 2' },\n      { id: 'step3', taskType: 'issue', prompt: 'Step 3' },\n    ],\n  };\n\n  const executionId = await orchestrator.startWorkflow(workflow, '/test');\n  \n  // Wait for step 1 to complete\n  await new Promise(resolve => setTimeout(resolve, 100));\n  \n  const step1Status = orchestrator.getStepStatus(executionId, 'step1');\n  const step3Status = orchestrator.getStepStatus(executionId, 'step3');\n  \n  assert.strictEqual(step1Status?.status, 'completed');\n  assert.strictEqual(step3Status?.status, 'pending');\n});\n```\n\n## Acceptance Criteria\n- [ ] waitForWorkflow correctly waits for completion\n- [ ] pauseWorkflow creates checkpoint before pausing\n- [ ] cancelWorkflow stops execution and creates final checkpoint\n- [ ] listCheckpoints returns all checkpoints, optionally filtered\n- [ ] getStepStatus returns accurate step status\n- [ ] Pause and cancel events emitted correctly\n- [ ] All test cases pass","status":"closed","priority":0,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-30 05:11:42","updated_at":"2025-10-30 07:42:30","closed_at":"2025-10-30 07:42:30","parent_id":null,"relationships":[],"tags":["control","implementation","workflow"]}
{"id":"ISSUE-087","uuid":"a0636f7e-a291-4336-9b6e-d414de2a7f87","title":"Write comprehensive unit tests for Workflow Layer components","content":"## Overview\nWrite comprehensive unit tests for all Workflow Layer components including utilities, LinearOrchestrator methods, and checkpointing logic.\n\nReferences: [[SPEC-006]]\nDepends on: [[ISSUE-081]], [[ISSUE-082]], [[ISSUE-083]], [[ISSUE-084]], [[ISSUE-085]], [[ISSUE-086]]\n\n## Implementation Steps\n\n### 1. Create utils.test.ts\nTest all utility functions in `tests/unit/utils.test.ts`:\n\n```typescript\nimport { describe, it } from 'node:test';\nimport assert from 'node:assert';\nimport { generateId, renderTemplate, extractValue, mergeContext } from '../../utils.js';\n\ndescribe('Workflow Utilities', () => {\n  describe('generateId', () => {\n    it('should generate unique IDs', () => {\n      const id1 = generateId();\n      const id2 = generateId();\n      assert.notStrictEqual(id1, id2);\n    });\n\n    it('should generate IDs with correct format', () => {\n      const id = generateId();\n      assert.match(id, /^[a-z0-9-]+$/);\n      assert.ok(id.length > 10);\n    });\n  });\n\n  describe('renderTemplate', () => {\n    it('should replace single variable', () => {\n      const result = renderTemplate('Hello {{name}}', { name: 'World' });\n      assert.strictEqual(result, 'Hello World');\n    });\n\n    it('should replace multiple variables', () => {\n      const result = renderTemplate(\n        'Hello {{name}}, you are {{age}} years old',\n        { name: 'Alice', age: '30' }\n      );\n      assert.strictEqual(result, 'Hello Alice, you are 30 years old');\n    });\n\n    it('should handle missing variables', () => {\n      const result = renderTemplate('Hello {{name}}', {});\n      assert.strictEqual(result, 'Hello {{name}}');\n    });\n\n    it('should handle nested context paths', () => {\n      const result = renderTemplate(\n        'User: {{user.name}}, Email: {{user.email}}',\n        { user: { name: 'Bob', email: 'bob@test.com' } }\n      );\n      assert.strictEqual(result, 'User: Bob, Email: bob@test.com');\n    });\n  });\n\n  describe('extractValue', () => {\n    it('should extract value from simple path', () => {\n      const result = extractValue({ name: 'Alice' }, 'name');\n      assert.strictEqual(result, 'Alice');\n    });\n\n    it('should extract value from nested path', () => {\n      const result = extractValue(\n        { user: { profile: { name: 'Bob' } } },\n        'user.profile.name'\n      );\n      assert.strictEqual(result, 'Bob');\n    });\n\n    it('should return undefined for non-existent path', () => {\n      const result = extractValue({ name: 'Alice' }, 'age');\n      assert.strictEqual(result, undefined);\n    });\n\n    it('should handle array indexing', () => {\n      const result = extractValue({ items: ['a', 'b', 'c'] }, 'items.1');\n      assert.strictEqual(result, 'b');\n    });\n  });\n\n  describe('mergeContext', () => {\n    it('should merge two contexts', () => {\n      const result = mergeContext({ a: 1 }, { b: 2 });\n      assert.deepStrictEqual(result, { a: 1, b: 2 });\n    });\n\n    it('should override existing keys', () => {\n      const result = mergeContext({ a: 1, b: 2 }, { b: 3, c: 4 });\n      assert.deepStrictEqual(result, { a: 1, b: 3, c: 4 });\n    });\n\n    it('should handle empty contexts', () => {\n      const result = mergeContext({}, { a: 1 });\n      assert.deepStrictEqual(result, { a: 1 });\n    });\n  });\n});\n```\n\n### 2. Create linear-orchestrator-base.test.ts\nTest LinearOrchestrator initialization and basic methods:\n\n```typescript\nimport { describe, it, beforeEach } from 'node:test';\nimport assert from 'node:assert';\nimport { LinearOrchestrator } from '../../linear-orchestrator.js';\nimport type { IResilientExecutor } from '../../../resilience/executor.js';\nimport type { WorkflowDefinition } from '../../types.js';\n\n// Mock ResilientExecutor\nclass MockResilientExecutor implements IResilientExecutor {\n  async executeTask() {\n    return {\n      taskId: 'mock-task',\n      executionId: 'mock-exec',\n      success: true,\n      exitCode: 0,\n      output: 'Success',\n      startedAt: new Date(),\n      completedAt: new Date(),\n      duration: 10,\n      attempts: [],\n      totalAttempts: 1,\n      finalAttempt: { attemptNumber: 1, success: true, timestamp: new Date() },\n    };\n  }\n  async executeTasks() { return []; }\n  getCircuitBreaker() { return null; }\n  resetCircuitBreaker() {}\n  getRetryMetrics() {\n    return {\n      totalRetries: 0,\n      successfulRetries: 0,\n      failedRetries: 0,\n      averageAttemptsToSuccess: 0,\n      circuitBreakers: new Map(),\n    };\n  }\n  onRetryAttempt() {}\n  onCircuitOpen() {}\n}\n\ndescribe('LinearOrchestrator Base', () => {\n  let mockExecutor: MockResilientExecutor;\n  let orchestrator: LinearOrchestrator;\n\n  beforeEach(() => {\n    mockExecutor = new MockResilientExecutor();\n    orchestrator = new LinearOrchestrator(mockExecutor);\n  });\n\n  describe('constructor', () => {\n    it('should initialize with executor', () => {\n      assert.ok(orchestrator);\n    });\n\n    it('should initialize with executor and storage', () => {\n      const storage = new InMemoryWorkflowStorage();\n      const orch = new LinearOrchestrator(mockExecutor, storage);\n      assert.ok(orch);\n    });\n  });\n\n  describe('getExecution', () => {\n    it('should return null for non-existent execution', () => {\n      const result = orchestrator.getExecution('non-existent');\n      assert.strictEqual(result, null);\n    });\n\n    it('should return execution after workflow start', async () => {\n      const workflow: WorkflowDefinition = {\n        id: 'test-workflow',\n        steps: [{ id: 'step1', taskType: 'issue', prompt: 'Test' }],\n      };\n\n      const executionId = await orchestrator.startWorkflow(workflow, '/test');\n      const execution = orchestrator.getExecution(executionId);\n      \n      assert.ok(execution);\n      assert.strictEqual(execution.workflowId, 'test-workflow');\n    });\n  });\n\n  describe('getStepStatus', () => {\n    it('should return null for non-existent execution', () => {\n      const result = orchestrator.getStepStatus('non-existent', 'step1');\n      assert.strictEqual(result, null);\n    });\n\n    it('should return null for non-existent step', async () => {\n      const workflow: WorkflowDefinition = {\n        id: 'test-workflow',\n        steps: [{ id: 'step1', taskType: 'issue', prompt: 'Test' }],\n      };\n\n      const executionId = await orchestrator.startWorkflow(workflow, '/test');\n      const result = orchestrator.getStepStatus(executionId, 'non-existent');\n      \n      assert.strictEqual(result, null);\n    });\n  });\n\n  describe('event handlers', () => {\n    it('should register start handler', () => {\n      let called = false;\n      orchestrator.onWorkflowStart(() => { called = true; });\n      // Would need to trigger start to verify\n      assert.ok(orchestrator);\n    });\n\n    it('should register complete handler', () => {\n      let called = false;\n      orchestrator.onWorkflowComplete(() => { called = true; });\n      assert.ok(orchestrator);\n    });\n\n    it('should register step start handler', () => {\n      let called = false;\n      orchestrator.onStepStart(() => { called = true; });\n      assert.ok(orchestrator);\n    });\n\n    it('should register step complete handler', () => {\n      let called = false;\n      orchestrator.onStepComplete(() => { called = true; });\n      assert.ok(orchestrator);\n    });\n  });\n});\n```\n\n### 3. Create step-execution.test.ts\nTest step execution logic:\n\n```typescript\nimport { describe, it, beforeEach } from 'node:test';\nimport assert from 'node:assert';\nimport { LinearOrchestrator } from '../../linear-orchestrator.js';\nimport type { WorkflowDefinition } from '../../types.js';\n\ndescribe('Step Execution Logic', () => {\n  let orchestrator: LinearOrchestrator;\n\n  beforeEach(() => {\n    const mockExecutor = new MockResilientExecutor();\n    orchestrator = new LinearOrchestrator(mockExecutor);\n  });\n\n  describe('output mapping', () => {\n    it('should map step output to context', async () => {\n      const workflow: WorkflowDefinition = {\n        id: 'test-workflow',\n        steps: [\n          {\n            id: 'step1',\n            taskType: 'issue',\n            prompt: 'Get user',\n            outputMapping: { userId: 'result.output' },\n          },\n          {\n            id: 'step2',\n            taskType: 'issue',\n            prompt: 'Process {{userId}}',\n          },\n        ],\n      };\n\n      const executionId = await orchestrator.startWorkflow(workflow, '/test');\n      await orchestrator.waitForWorkflow(executionId);\n      \n      const execution = orchestrator.getExecution(executionId);\n      assert.ok(execution?.context.userId);\n    });\n  });\n\n  describe('conditional execution', () => {\n    it('should skip step when condition is false', async () => {\n      const workflow: WorkflowDefinition = {\n        id: 'test-workflow',\n        steps: [\n          { id: 'step1', taskType: 'issue', prompt: 'Step 1' },\n          {\n            id: 'step2',\n            taskType: 'issue',\n            prompt: 'Step 2',\n            condition: '{{shouldRun}}',\n          },\n        ],\n        initialContext: { shouldRun: false },\n      };\n\n      const executionId = await orchestrator.startWorkflow(workflow, '/test');\n      await orchestrator.waitForWorkflow(executionId);\n      \n      const step2Status = orchestrator.getStepStatus(executionId, 'step2');\n      assert.strictEqual(step2Status?.status, 'skipped');\n    });\n  });\n\n  describe('template rendering', () => {\n    it('should render templates in prompt', async () => {\n      const workflow: WorkflowDefinition = {\n        id: 'test-workflow',\n        steps: [\n          {\n            id: 'step1',\n            taskType: 'issue',\n            prompt: 'Hello {{name}}',\n          },\n        ],\n        initialContext: { name: 'World' },\n      };\n\n      const executionId = await orchestrator.startWorkflow(workflow, '/test');\n      await orchestrator.waitForWorkflow(executionId);\n      \n      // Verify the rendered prompt was used\n      const execution = orchestrator.getExecution(executionId);\n      assert.ok(execution);\n    });\n  });\n});\n```\n\n### 4. Create checkpointing.test.ts\nTest checkpointing and resumption:\n\n```typescript\nimport { describe, it, beforeEach } from 'node:test';\nimport assert from 'node:assert';\nimport { LinearOrchestrator } from '../../linear-orchestrator.js';\nimport { InMemoryWorkflowStorage } from '../../memory-storage.js';\nimport type { WorkflowDefinition } from '../../types.js';\n\ndescribe('Checkpointing and Resumption', () => {\n  let orchestrator: LinearOrchestrator;\n  let storage: InMemoryWorkflowStorage;\n\n  beforeEach(() => {\n    const mockExecutor = new MockResilientExecutor();\n    storage = new InMemoryWorkflowStorage();\n    orchestrator = new LinearOrchestrator(mockExecutor, storage);\n  });\n\n  describe('checkpoint creation', () => {\n    it('should create checkpoint at interval', async () => {\n      const workflow: WorkflowDefinition = {\n        id: 'test-workflow',\n        steps: [\n          { id: 'step1', taskType: 'issue', prompt: 'Step 1' },\n          { id: 'step2', taskType: 'issue', prompt: 'Step 2' },\n        ],\n      };\n\n      await orchestrator.startWorkflow(workflow, '/test', { checkpointInterval: 1 });\n      await new Promise(resolve => setTimeout(resolve, 200));\n      \n      const checkpoints = await storage.listCheckpoints();\n      assert.ok(checkpoints.length > 0);\n    });\n\n    it('should include execution state in checkpoint', async () => {\n      const workflow: WorkflowDefinition = {\n        id: 'test-workflow',\n        steps: [\n          { id: 'step1', taskType: 'issue', prompt: 'Step 1' },\n        ],\n      };\n\n      const executionId = await orchestrator.startWorkflow(workflow, '/test', { \n        checkpointInterval: 1 \n      });\n      await orchestrator.waitForWorkflow(executionId);\n      \n      const checkpoints = await storage.listCheckpoints();\n      const checkpoint = checkpoints[0];\n      \n      assert.ok(checkpoint.state);\n      assert.ok(checkpoint.state.context);\n      assert.ok(Array.isArray(checkpoint.state.stepResults));\n    });\n  });\n\n  describe('workflow resumption', () => {\n    it('should resume from checkpoint', async () => {\n      const workflow: WorkflowDefinition = {\n        id: 'test-workflow',\n        steps: [\n          { id: 'step1', taskType: 'issue', prompt: 'Step 1' },\n          { id: 'step2', taskType: 'issue', prompt: 'Step 2' },\n        ],\n      };\n\n      const executionId = await orchestrator.startWorkflow(workflow, '/test', { \n        checkpointInterval: 1 \n      });\n      \n      await new Promise(resolve => setTimeout(resolve, 100));\n      await orchestrator.pauseWorkflow(executionId);\n      \n      await orchestrator.resumeWorkflow(executionId);\n      \n      const execution = orchestrator.getExecution(executionId);\n      assert.strictEqual(execution?.status, 'completed');\n    });\n\n    it('should continue from correct step', async () => {\n      const workflow: WorkflowDefinition = {\n        id: 'test-workflow',\n        steps: [\n          { id: 'step1', taskType: 'issue', prompt: 'Step 1' },\n          { id: 'step2', taskType: 'issue', prompt: 'Step 2' },\n          { id: 'step3', taskType: 'issue', prompt: 'Step 3' },\n        ],\n      };\n\n      const executionId = await orchestrator.startWorkflow(workflow, '/test', { \n        checkpointInterval: 1 \n      });\n      \n      await new Promise(resolve => setTimeout(resolve, 150));\n      await orchestrator.pauseWorkflow(executionId);\n      \n      const checkpointBefore = await storage.loadCheckpoint(executionId);\n      const stepIndex = checkpointBefore?.state.currentStepIndex || 0;\n      \n      await orchestrator.resumeWorkflow(executionId);\n      await orchestrator.waitForWorkflow(executionId);\n      \n      const execution = orchestrator.getExecution(executionId);\n      assert.strictEqual(execution?.stepResults.length, 3);\n      assert.ok(execution?.stepResults.length > stepIndex);\n    });\n  });\n});\n```\n\n## Test Coverage Goals\n- [ ] Utility functions: 100% coverage\n- [ ] LinearOrchestrator methods: >90% coverage\n- [ ] Edge cases: error handling, boundary conditions\n- [ ] Event emission: all handlers triggered correctly\n\n## Acceptance Criteria\n- [ ] All utility function tests pass\n- [ ] LinearOrchestrator base tests pass\n- [ ] Step execution tests pass\n- [ ] Checkpointing tests pass\n- [ ] Test coverage meets goals\n- [ ] All edge cases covered","status":"closed","priority":0,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-30 05:12:36","updated_at":"2025-10-30 08:05:45","closed_at":"2025-10-30 08:05:45","parent_id":null,"relationships":[],"tags":["testing","unit-tests","workflow"]}
{"id":"ISSUE-088","uuid":"d96ea7cf-03d3-463e-bab1-8591137b74b7","title":"Write integration tests for end-to-end workflow scenarios","content":"## Overview\nWrite comprehensive integration tests that verify end-to-end workflow execution scenarios, including multi-step workflows, checkpointing, resumption, and integration with the Resilience Layer.\n\nReferences: [[SPEC-006]]\nDepends on: [[ISSUE-087]]\n\n## Implementation Steps\n\n### 1. Create end-to-end.test.ts\nCreate integration test file in `tests/integration/end-to-end.test.ts`:\n\n```typescript\n/**\n * Integration Tests for Workflow Layer with Resilience Layer\n *\n * Tests complete workflow execution scenarios from start to finish.\n * Uses mock resilient executor to verify integration without actual process execution.\n */\n\nimport { describe, it, beforeEach } from 'node:test';\nimport assert from 'node:assert';\nimport { LinearOrchestrator } from '../../linear-orchestrator.js';\nimport { InMemoryWorkflowStorage } from '../../memory-storage.js';\nimport type { IResilientExecutor } from '../../../resilience/executor.js';\nimport type { WorkflowDefinition } from '../../types.js';\nimport type { ExecutionTask, ResilientExecutionResult } from '../../../resilience/types.js';\n\n/**\n * Mock Resilient Executor for Integration Testing\n */\nclass MockResilientExecutor implements IResilientExecutor {\n  private taskCounter = 0;\n  private executedTasks: ExecutionTask[] = [];\n  public failTaskIds: string[] = []; // Tasks that should fail\n\n  async executeTask(task: ExecutionTask): Promise<ResilientExecutionResult> {\n    this.executedTasks.push(task);\n    \n    const shouldFail = this.failTaskIds.includes(task.id);\n    \n    // Simulate async execution\n    await new Promise(resolve => setTimeout(resolve, 10));\n    \n    return {\n      taskId: task.id,\n      executionId: `exec-${this.taskCounter++}`,\n      success: !shouldFail,\n      exitCode: shouldFail ? 1 : 0,\n      output: shouldFail ? '' : `Output from ${task.id}`,\n      error: shouldFail ? 'Task failed' : undefined,\n      startedAt: new Date(),\n      completedAt: new Date(),\n      duration: 10,\n      attempts: [],\n      totalAttempts: 1,\n      finalAttempt: {\n        attemptNumber: 1,\n        success: !shouldFail,\n        timestamp: new Date(),\n      },\n    };\n  }\n\n  async executeTasks(tasks: ExecutionTask[]): Promise<ResilientExecutionResult[]> {\n    return Promise.all(tasks.map(t => this.executeTask(t)));\n  }\n\n  getCircuitBreaker() { return null; }\n  resetCircuitBreaker() {}\n  getRetryMetrics() {\n    return {\n      totalRetries: 0,\n      successfulRetries: 0,\n      failedRetries: 0,\n      averageAttemptsToSuccess: 0,\n      circuitBreakers: new Map(),\n    };\n  }\n  onRetryAttempt() {}\n  onCircuitOpen() {}\n\n  getExecutedTasks(): ExecutionTask[] {\n    return this.executedTasks;\n  }\n\n  reset(): void {\n    this.executedTasks = [];\n    this.taskCounter = 0;\n    this.failTaskIds = [];\n  }\n}\n\ndescribe('Workflow Layer Integration with Resilience Layer', () => {\n  let mockExecutor: MockResilientExecutor;\n  let orchestrator: LinearOrchestrator;\n  let storage: InMemoryWorkflowStorage;\n\n  beforeEach(() => {\n    mockExecutor = new MockResilientExecutor();\n    storage = new InMemoryWorkflowStorage();\n    orchestrator = new LinearOrchestrator(mockExecutor, storage);\n  });\n\n  describe('Complete Workflow Execution', () => {\n    it('should execute simple sequential workflow', async () => {\n      const workflow: WorkflowDefinition = {\n        id: 'simple-workflow',\n        steps: [\n          { id: 'step1', taskType: 'issue', prompt: 'First step' },\n          { id: 'step2', taskType: 'issue', prompt: 'Second step' },\n          { id: 'step3', taskType: 'issue', prompt: 'Third step' },\n        ],\n      };\n\n      const executionId = await orchestrator.startWorkflow(workflow, '/test');\n      await orchestrator.waitForWorkflow(executionId);\n\n      const execution = orchestrator.getExecution(executionId);\n      assert.strictEqual(execution?.status, 'completed');\n      assert.strictEqual(execution?.stepResults.length, 3);\n      assert.ok(execution?.stepResults.every(r => r.success));\n    });\n\n    it('should pass context between steps', async () => {\n      const workflow: WorkflowDefinition = {\n        id: 'context-workflow',\n        steps: [\n          {\n            id: 'step1',\n            taskType: 'issue',\n            prompt: 'Get user ID',\n            outputMapping: { userId: 'result.output' },\n          },\n          {\n            id: 'step2',\n            taskType: 'issue',\n            prompt: 'Process user {{userId}}',\n          },\n        ],\n        initialContext: { environment: 'test' },\n      };\n\n      const executionId = await orchestrator.startWorkflow(workflow, '/test');\n      await orchestrator.waitForWorkflow(executionId);\n\n      const execution = orchestrator.getExecution(executionId);\n      assert.ok(execution?.context.userId);\n      assert.strictEqual(execution?.context.environment, 'test');\n    });\n\n    it('should handle workflow with conditional steps', async () => {\n      const workflow: WorkflowDefinition = {\n        id: 'conditional-workflow',\n        steps: [\n          {\n            id: 'step1',\n            taskType: 'issue',\n            prompt: 'Check condition',\n            outputMapping: { shouldContinue: 'result.success' },\n          },\n          {\n            id: 'step2',\n            taskType: 'issue',\n            prompt: 'Conditional step',\n            condition: '{{shouldContinue}}',\n          },\n          {\n            id: 'step3',\n            taskType: 'issue',\n            prompt: 'Final step',\n          },\n        ],\n      };\n\n      const executionId = await orchestrator.startWorkflow(workflow, '/test');\n      await orchestrator.waitForWorkflow(executionId);\n\n      const execution = orchestrator.getExecution(executionId);\n      assert.strictEqual(execution?.status, 'completed');\n    });\n  });\n\n  describe('Checkpointing and Resumption', () => {\n    it('should checkpoint and resume multi-step workflow', async () => {\n      const workflow: WorkflowDefinition = {\n        id: 'checkpoint-workflow',\n        steps: [\n          { id: 'step1', taskType: 'issue', prompt: 'Step 1' },\n          { id: 'step2', taskType: 'issue', prompt: 'Step 2' },\n          { id: 'step3', taskType: 'issue', prompt: 'Step 3' },\n          { id: 'step4', taskType: 'issue', prompt: 'Step 4' },\n        ],\n      };\n\n      const executionId = await orchestrator.startWorkflow(workflow, '/test', {\n        checkpointInterval: 2,\n      });\n\n      // Wait for partial execution\n      await new Promise(resolve => setTimeout(resolve, 100));\n      await orchestrator.pauseWorkflow(executionId);\n\n      // Verify checkpoint was created\n      const checkpoints = await storage.listCheckpoints('checkpoint-workflow');\n      assert.ok(checkpoints.length > 0);\n\n      const checkpoint = checkpoints[0];\n      const stepsCompleted = checkpoint.state.stepResults.length;\n\n      // Resume execution\n      await orchestrator.resumeWorkflow(executionId);\n      await orchestrator.waitForWorkflow(executionId);\n\n      const execution = orchestrator.getExecution(executionId);\n      assert.strictEqual(execution?.status, 'completed');\n      assert.strictEqual(execution?.stepResults.length, 4);\n      assert.ok(execution?.resumedAt instanceof Date);\n    });\n\n    it('should restore context after resumption', async () => {\n      const workflow: WorkflowDefinition = {\n        id: 'context-resume-workflow',\n        steps: [\n          {\n            id: 'step1',\n            taskType: 'issue',\n            prompt: 'Get data',\n            outputMapping: { data: 'result.output' },\n          },\n          { id: 'step2', taskType: 'issue', prompt: 'Step 2' },\n          {\n            id: 'step3',\n            taskType: 'issue',\n            prompt: 'Use {{data}}',\n          },\n        ],\n      };\n\n      const executionId = await orchestrator.startWorkflow(workflow, '/test', {\n        checkpointInterval: 1,\n      });\n\n      await new Promise(resolve => setTimeout(resolve, 100));\n      await orchestrator.pauseWorkflow(executionId);\n\n      const checkpointBefore = await storage.loadCheckpoint(executionId);\n      const contextBefore = checkpointBefore?.state.context;\n\n      await orchestrator.resumeWorkflow(executionId);\n      await orchestrator.waitForWorkflow(executionId);\n\n      const execution = orchestrator.getExecution(executionId);\n      assert.deepStrictEqual(execution?.context.data, contextBefore?.data);\n    });\n  });\n\n  describe('Error Handling and Recovery', () => {\n    it('should handle step failure gracefully', async () => {\n      mockExecutor.failTaskIds = ['step2'];\n\n      const workflow: WorkflowDefinition = {\n        id: 'error-workflow',\n        steps: [\n          { id: 'step1', taskType: 'issue', prompt: 'Step 1' },\n          { id: 'step2', taskType: 'issue', prompt: 'Step 2 (will fail)' },\n          { id: 'step3', taskType: 'issue', prompt: 'Step 3' },\n        ],\n      };\n\n      const executionId = await orchestrator.startWorkflow(workflow, '/test');\n      await orchestrator.waitForWorkflow(executionId);\n\n      const execution = orchestrator.getExecution(executionId);\n      assert.strictEqual(execution?.status, 'failed');\n      assert.ok(execution?.error);\n      assert.strictEqual(execution?.stepResults.length, 2); // Only step1 and failed step2\n    });\n\n    it('should create checkpoint before failure', async () => {\n      mockExecutor.failTaskIds = ['step3'];\n\n      const workflow: WorkflowDefinition = {\n        id: 'failure-checkpoint-workflow',\n        steps: [\n          { id: 'step1', taskType: 'issue', prompt: 'Step 1' },\n          { id: 'step2', taskType: 'issue', prompt: 'Step 2' },\n          { id: 'step3', taskType: 'issue', prompt: 'Step 3 (will fail)' },\n        ],\n      };\n\n      const executionId = await orchestrator.startWorkflow(workflow, '/test', {\n        checkpointInterval: 1,\n      });\n      await orchestrator.waitForWorkflow(executionId);\n\n      const checkpoints = await storage.listCheckpoints('failure-checkpoint-workflow');\n      assert.ok(checkpoints.length > 0);\n      \n      const lastCheckpoint = checkpoints[checkpoints.length - 1];\n      assert.strictEqual(lastCheckpoint.state.status, 'failed');\n    });\n  });\n\n  describe('Workflow Control', () => {\n    it('should pause and resume workflow', async () => {\n      const workflow: WorkflowDefinition = {\n        id: 'pause-workflow',\n        steps: [\n          { id: 'step1', taskType: 'issue', prompt: 'Step 1' },\n          { id: 'step2', taskType: 'issue', prompt: 'Step 2' },\n          { id: 'step3', taskType: 'issue', prompt: 'Step 3' },\n        ],\n      };\n\n      const executionId = await orchestrator.startWorkflow(workflow, '/test');\n      \n      await new Promise(resolve => setTimeout(resolve, 50));\n      await orchestrator.pauseWorkflow(executionId);\n\n      let execution = orchestrator.getExecution(executionId);\n      assert.strictEqual(execution?.status, 'paused');\n\n      await orchestrator.resumeWorkflow(executionId);\n      await orchestrator.waitForWorkflow(executionId);\n\n      execution = orchestrator.getExecution(executionId);\n      assert.strictEqual(execution?.status, 'completed');\n    });\n\n    it('should cancel running workflow', async () => {\n      const workflow: WorkflowDefinition = {\n        id: 'cancel-workflow',\n        steps: [\n          { id: 'step1', taskType: 'issue', prompt: 'Step 1' },\n          { id: 'step2', taskType: 'issue', prompt: 'Step 2' },\n          { id: 'step3', taskType: 'issue', prompt: 'Step 3' },\n        ],\n      };\n\n      const executionId = await orchestrator.startWorkflow(workflow, '/test');\n      \n      await new Promise(resolve => setTimeout(resolve, 50));\n      await orchestrator.cancelWorkflow(executionId);\n\n      const execution = orchestrator.getExecution(executionId);\n      assert.strictEqual(execution?.status, 'cancelled');\n      assert.ok(execution?.completedAt instanceof Date);\n    });\n  });\n\n  describe('Event Emission', () => {\n    it('should emit all lifecycle events', async () => {\n      const events: string[] = [];\n\n      orchestrator.onWorkflowStart(() => events.push('start'));\n      orchestrator.onWorkflowComplete(() => events.push('complete'));\n      orchestrator.onStepStart(() => events.push('step-start'));\n      orchestrator.onStepComplete(() => events.push('step-complete'));\n\n      const workflow: WorkflowDefinition = {\n        id: 'event-workflow',\n        steps: [\n          { id: 'step1', taskType: 'issue', prompt: 'Step 1' },\n          { id: 'step2', taskType: 'issue', prompt: 'Step 2' },\n        ],\n      };\n\n      const executionId = await orchestrator.startWorkflow(workflow, '/test');\n      await orchestrator.waitForWorkflow(executionId);\n\n      assert.ok(events.includes('start'));\n      assert.ok(events.includes('complete'));\n      assert.ok(events.includes('step-start'));\n      assert.ok(events.includes('step-complete'));\n      assert.strictEqual(events.filter(e => e === 'step-start').length, 2);\n      assert.strictEqual(events.filter(e => e === 'step-complete').length, 2);\n    });\n\n    it('should emit checkpoint events', async () => {\n      let checkpointEmitted = false;\n\n      orchestrator.onCheckpoint(() => {\n        checkpointEmitted = true;\n      });\n\n      const workflow: WorkflowDefinition = {\n        id: 'checkpoint-event-workflow',\n        steps: [\n          { id: 'step1', taskType: 'issue', prompt: 'Step 1' },\n          { id: 'step2', taskType: 'issue', prompt: 'Step 2' },\n        ],\n      };\n\n      const executionId = await orchestrator.startWorkflow(workflow, '/test', {\n        checkpointInterval: 1,\n      });\n      await orchestrator.waitForWorkflow(executionId);\n\n      assert.strictEqual(checkpointEmitted, true);\n    });\n  });\n\n  describe('Integration with Resilience Layer', () => {\n    it('should correctly pass task configuration to executor', async () => {\n      const workflow: WorkflowDefinition = {\n        id: 'config-workflow',\n        steps: [\n          {\n            id: 'step1',\n            taskType: 'issue',\n            prompt: 'Test step',\n            taskConfig: {\n              timeout: 30000,\n              maxRetries: 3,\n              env: { TEST_VAR: 'value' },\n            },\n          },\n        ],\n      };\n\n      const executionId = await orchestrator.startWorkflow(workflow, '/test');\n      await orchestrator.waitForWorkflow(executionId);\n\n      const executedTasks = mockExecutor.getExecutedTasks();\n      assert.strictEqual(executedTasks.length, 1);\n      assert.deepStrictEqual(executedTasks[0].config, {\n        timeout: 30000,\n        maxRetries: 3,\n        env: { TEST_VAR: 'value' },\n      });\n    });\n\n    it('should handle dependencies between steps', async () => {\n      const workflow: WorkflowDefinition = {\n        id: 'dependency-workflow',\n        steps: [\n          { id: 'step1', taskType: 'issue', prompt: 'Step 1' },\n          {\n            id: 'step2',\n            taskType: 'issue',\n            prompt: 'Step 2',\n            dependencies: ['step1'],\n          },\n        ],\n      };\n\n      const executionId = await orchestrator.startWorkflow(workflow, '/test');\n      await orchestrator.waitForWorkflow(executionId);\n\n      const execution = orchestrator.getExecution(executionId);\n      assert.strictEqual(execution?.status, 'completed');\n      \n      // Verify step2 only executed after step1\n      const executedTasks = mockExecutor.getExecutedTasks();\n      assert.strictEqual(executedTasks[0].id, 'step1');\n      assert.strictEqual(executedTasks[1].id, 'step2');\n    });\n  });\n});\n```\n\n## Test Scenarios\n\n### Positive Flows\n- [ ] Simple sequential workflow execution\n- [ ] Context passing between steps\n- [ ] Output mapping and template rendering\n- [ ] Conditional step execution\n- [ ] Checkpointing at intervals\n- [ ] Successful workflow resumption\n- [ ] Complete workflow lifecycle\n\n### Error Handling\n- [ ] Step failure handling\n- [ ] Checkpoint on failure\n- [ ] Workflow cancellation\n- [ ] Invalid execution ID\n- [ ] Missing checkpoint for resumption\n\n### Edge Cases\n- [ ] Single-step workflow\n- [ ] Empty initial context\n- [ ] All steps skipped by conditions\n- [ ] Pause immediately after start\n- [ ] Cancel before first step completes\n\n### Integration Points\n- [ ] Task submission to ResilientExecutor\n- [ ] Task configuration propagation\n- [ ] Dependency resolution\n- [ ] Event emission timing\n- [ ] Storage operations\n\n## Acceptance Criteria\n- [ ] All integration tests pass\n- [ ] Tests cover complete workflow lifecycle\n- [ ] Error scenarios handled correctly\n- [ ] Integration with Resilience Layer verified\n- [ ] Checkpointing and resumption work end-to-end\n- [ ] All event handlers triggered correctly","status":"closed","priority":0,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-30 05:13:37","updated_at":"2025-10-30 07:50:18","closed_at":"2025-10-30 07:50:18","parent_id":null,"relationships":[],"tags":["integration-tests","testing","workflow"]}
{"id":"ISSUE-090","uuid":"fe23986d-d574-41db-9255-976eb692a42f","title":"Foundation: Types and Interface for Output Processing Layer","content":"Implements [[SPEC-007]] - Output Processing Layer foundation with core types and interfaces.\n\n## Overview\nCreate the foundational types and interfaces for the Output Processing Layer (Layer 5). This layer is responsible for parsing Claude Code's stream-json output in real-time.\n\n## Requirements\n\n### Core Types\nDefine the following types in `src/execution/output/types.ts`:\n\n1. **OutputMessage**: Discriminated union for all message types\n   - `text`: Plain text output\n   - `tool_use`: Tool invocation\n   - `tool_result`: Tool execution result\n   - `usage`: Token/cost metadata\n   - `error`: Error messages\n\n2. **FileChange**: Track file modifications\n   - `path`: File path\n   - `operation`: read | write | edit\n   - `timestamp`: When change occurred\n\n3. **ToolCall**: Represent tool invocations\n   - `id`: Unique identifier\n   - `name`: Tool name (Bash, Read, Edit, etc.)\n   - `input`: Tool parameters\n   - `status`: pending | success | error\n   - `result`: Tool output (optional)\n\n4. **ProcessingMetrics**: Aggregate statistics\n   - `totalMessages`: Count of messages processed\n   - `toolCalls`: Array of ToolCall\n   - `fileChanges`: Array of FileChange\n   - `usage`: Token counts and costs\n   - `errors`: Error tracking\n\n### Interface\nDefine `IOutputProcessor` interface with:\n- `processLine(line: string): Promise<void>` - Parse single stream-json line\n- `getMetrics(): ProcessingMetrics` - Get current metrics\n- `getToolCalls(): ToolCall[]` - Get all tool calls\n- `getFileChanges(): FileChange[]` - Get all file changes\n- Event handlers: `onToolCall`, `onFileChange`, `onProgress`, `onError`\n\n## Acceptance Criteria\n- [ ] All types defined in `src/execution/output/types.ts`\n- [ ] `IOutputProcessor` interface defined\n- [ ] Types export cleanly from main module\n- [ ] TypeScript compilation passes with no errors\n- [ ] Follow existing project patterns (e.g., resilience types)\n\n## Implementation Notes\n- Reference `src/execution/resilience/types.ts` for pattern consistency\n- Use discriminated unions for message types (like `AttemptResult`)\n- Include JSDoc comments for all public types\n\n## Dependencies\nNone - this is the foundation issue\n\n## Estimated Effort\nSmall (2-3 hours)","status":"closed","priority":1,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-30 08:34:05","updated_at":"2025-10-30 08:46:06","closed_at":"2025-10-30 08:46:06","parent_id":null,"relationships":[{"from":"ISSUE-090","from_type":"issue","to":"SPEC-007","to_type":"spec","type":"implements"}],"tags":[]}
{"id":"ISSUE-091","uuid":"d1fb7e6f-67cc-4bb1-a1c0-72b69c3d7da7","title":"Basic Parser: StreamJsonProcessor Skeleton","content":"Implements [[SPEC-007]] - Create basic StreamJsonProcessor class structure with line parsing.\n\n## Overview\nBuild the skeleton of the `StreamJsonProcessor` class that implements the `IOutputProcessor` interface. This class will parse stream-json output line-by-line.\n\n## Requirements\n\n### Class Structure\nCreate `src/execution/output/stream-json-processor.ts`:\n\n```typescript\nexport class StreamJsonProcessor implements IOutputProcessor {\n  private _metrics: ProcessingMetrics;\n  private _toolCalls: Map<string, ToolCall>;\n  private _fileChanges: FileChange[];\n  \n  // Event handlers\n  private _toolCallHandlers: Array<(toolCall: ToolCall) => void>;\n  private _fileChangeHandlers: Array<(change: FileChange) => void>;\n  private _progressHandlers: Array<(metrics: ProcessingMetrics) => void>;\n  private _errorHandlers: Array<(error: Error) => void>;\n  \n  constructor() {\n    // Initialize state\n  }\n  \n  async processLine(line: string): Promise<void> {\n    // Parse JSON from line\n    // Determine message type\n    // Route to appropriate handler\n  }\n  \n  // Getter methods\n  getMetrics(): ProcessingMetrics { /* ... */ }\n  getToolCalls(): ToolCall[] { /* ... */ }\n  getFileChanges(): FileChange[] { /* ... */ }\n  \n  // Event registration\n  onToolCall(handler: (toolCall: ToolCall) => void): void { /* ... */ }\n  onFileChange(handler: (change: FileChange) => void): void { /* ... */ }\n  onProgress(handler: (metrics: ProcessingMetrics) => void): void { /* ... */ }\n  onError(handler: (error: Error) => void): void { /* ... */ }\n}\n```\n\n### Line Parsing\n- Handle malformed JSON gracefully\n- Skip empty lines\n- Detect message type from parsed object\n- Track line numbers for error reporting\n\n## Acceptance Criteria\n- [ ] `StreamJsonProcessor` class implements `IOutputProcessor`\n- [ ] Constructor initializes all internal state\n- [ ] `processLine` can parse JSON and identify message type\n- [ ] All getter methods return current state\n- [ ] Event handler registration works\n- [ ] TypeScript compilation passes\n- [ ] Basic error handling for malformed input\n\n## Implementation Notes\n- Use `JSON.parse()` with try-catch for parsing\n- Store tool calls in Map for fast lookup by ID\n- Follow event handler pattern from `LinearOrchestrator`\n- Don't implement message-specific logic yet (that's ISSUE-091)\n\n## Dependencies\n- Depends on: ISSUE-089 (types and interface)\n\n## Estimated Effort\nMedium (4-5 hours)","status":"closed","priority":1,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-30 08:34:06","updated_at":"2025-10-30 09:34:00","closed_at":"2025-10-30 09:34:00","parent_id":null,"relationships":[{"from":"ISSUE-091","from_type":"issue","to":"ISSUE-090","to_type":"issue","type":"depends-on"},{"from":"ISSUE-091","from_type":"issue","to":"SPEC-007","to_type":"spec","type":"implements"}],"tags":[]}
{"id":"ISSUE-092","uuid":"f6224174-e87c-4224-b0e1-50c249f4646d","title":"Message Handlers: Parse Different Message Types","content":"Implements [[SPEC-007]] - Add specific handlers for each stream-json message type.\n\n## Overview\nImplement the core parsing logic for different message types in Claude Code's stream-json output: text, tool_use, tool_result, usage, and error messages.\n\n## Requirements\n\n### Message Type Handlers\nAdd private methods to `StreamJsonProcessor`:\n\n1. **`_handleTextMessage(message: any)`**\n   - Extract text content\n   - Emit progress event if needed\n   - Track message count\n\n2. **`_handleToolUseMessage(message: any)`**\n   - Create `ToolCall` object\n   - Set status to 'pending'\n   - Store in tool calls map\n   - Emit `onToolCall` event\n\n3. **`_handleToolResultMessage(message: any)`**\n   - Find corresponding tool call by ID\n   - Update status (success/error)\n   - Store result output\n   - Detect file changes from tool results\n   - Emit `onToolCall` event (updated)\n\n4. **`_handleUsageMessage(message: any)`**\n   - Extract token counts (input/output)\n   - Calculate costs if pricing available\n   - Update metrics.usage\n   - Emit progress event\n\n5. **`_handleErrorMessage(message: any)`**\n   - Track error in metrics\n   - Emit `onError` event\n\n### File Change Detection\nImplement `_detectFileChanges(toolCall: ToolCall)`:\n- Detect Read tool → read operation\n- Detect Write tool → write operation\n- Detect Edit tool → edit operation\n- Extract file path from tool input\n- Create FileChange object\n- Emit `onFileChange` event\n\n### processLine Integration\nUpdate `processLine` to route to appropriate handler:\n```typescript\nasync processLine(line: string): Promise<void> {\n  const message = JSON.parse(line);\n  \n  switch (message.type) {\n    case 'text':\n      this._handleTextMessage(message);\n      break;\n    case 'tool_use':\n      this._handleToolUseMessage(message);\n      break;\n    case 'tool_result':\n      this._handleToolResultMessage(message);\n      break;\n    case 'usage':\n      this._handleUsageMessage(message);\n      break;\n    case 'error':\n      this._handleErrorMessage(message);\n      break;\n  }\n  \n  this._metrics.totalMessages++;\n}\n```\n\n## Acceptance Criteria\n- [ ] All 5 message type handlers implemented\n- [ ] File change detection works for Read/Write/Edit tools\n- [ ] Tool calls tracked from invocation through completion\n- [ ] Events emitted at appropriate times\n- [ ] Metrics updated correctly for each message type\n- [ ] TypeScript compilation passes\n- [ ] Error handling for unexpected message formats\n\n## Implementation Notes\n- Tool IDs are used to match tool_use with tool_result\n- File paths may need normalization (absolute vs relative)\n- Consider batching progress events (don't emit on every message)\n- Reference actual stream-json format from Claude Code docs if needed\n\n## Dependencies\n- Depends on: ISSUE-090 (basic parser skeleton)\n\n## Estimated Effort\nLarge (6-8 hours)","status":"closed","priority":1,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-30 08:34:07","updated_at":"2025-10-30 10:23:56","closed_at":"2025-10-30 10:23:56","parent_id":null,"relationships":[],"tags":[]}
{"id":"ISSUE-093","uuid":"56700d48-094d-47ec-bb43-01c8557f5d69","title":"Message Handlers: Implement Type-Specific Processing","content":"Implements [[SPEC-007]] - Add message type handlers for tool calls, file changes, and other stream-json messages.\n\n## Overview\nImplement the specific handlers for each message type that Claude Code outputs. This is where we extract tool calls, detect file changes, and track usage.\n\n## Requirements\n\n### Message Handler Methods\nAdd private handler methods to `StreamJsonProcessor`:\n\n1. **`_handleToolUse(message: any): void`**\n   - Extract tool name, id, and input parameters\n   - Create `ToolCall` object with status='pending'\n   - Add to `_toolCalls` map\n   - Emit `onToolCall` event\n\n2. **`_handleToolResult(message: any): void`**\n   - Find matching tool call by ID\n   - Update status (success/error)\n   - Store result/error message\n   - If tool is Read/Write/Edit, create `FileChange` entry\n   - Emit `onFileChange` event for file operations\n\n3. **`_handleText(message: any): void`**\n   - Track text message in metrics\n   - Optional: emit progress event\n\n4. **`_handleUsage(message: any): void`**\n   - Extract token counts (input/output/cache)\n   - Calculate costs (if pricing info available)\n   - Update metrics\n\n5. **`_handleError(message: any): void`**\n   - Extract error details\n   - Track in metrics\n   - Emit `onError` event\n\n### File Change Detection\nLogic to detect file operations from tool results:\n- Tool name: `Read` → operation: 'read'\n- Tool name: `Write` → operation: 'write'\n- Tool name: `Edit` → operation: 'edit'\n- Extract file path from tool input parameters\n- Timestamp the change\n\n### Route in processLine\nUpdate `processLine` to route to handlers:\n```typescript\nasync processLine(line: string): Promise<void> {\n  const message = JSON.parse(line);\n  \n  switch (message.type) {\n    case 'tool_use':\n      this._handleToolUse(message);\n      break;\n    case 'tool_result':\n      this._handleToolResult(message);\n      break;\n    case 'text':\n      this._handleText(message);\n      break;\n    case 'usage':\n      this._handleUsage(message);\n      break;\n    case 'error':\n      this._handleError(message);\n      break;\n  }\n  \n  this._metrics.totalMessages++;\n}\n```\n\n## Acceptance Criteria\n- [ ] All 5 handler methods implemented\n- [ ] `processLine` routes to correct handler\n- [ ] Tool calls tracked with unique IDs\n- [ ] File changes detected from Read/Write/Edit tools\n- [ ] Usage metrics updated correctly\n- [ ] Events emitted at appropriate times\n- [ ] Metrics counter incremented per message\n- [ ] TypeScript compilation passes\n\n## Implementation Notes\n- Tool result messages contain `tool_use_id` to match back to tool_use\n- File path typically in `tool.input.file_path` or similar\n- Consider edge cases: missing IDs, unknown tools, malformed params\n- Emit progress events periodically (e.g., every 10 messages)\n\n## Dependencies\n- Depends on: ISSUE-091 (StreamJsonProcessor skeleton)\n\n## Estimated Effort\nMedium (5-6 hours)","status":"closed","priority":1,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-30 08:36:33","updated_at":"2025-10-30 09:40:31","closed_at":"2025-10-30 09:40:31","parent_id":null,"relationships":[{"from":"ISSUE-093","from_type":"issue","to":"SPEC-007","to_type":"spec","type":"implements"},{"from":"ISSUE-093","from_type":"issue","to":"ISSUE-091","to_type":"issue","type":"depends-on"}],"tags":[]}
{"id":"ISSUE-094","uuid":"32596dc6-5267-4424-bea3-1fe4d400d25d","title":"Extraction & Metadata: Data Aggregation and Queries","content":"Implements [[SPEC-007]] - Add query methods and metadata aggregation for processed output.\n\n## Overview\nEnhance `StreamJsonProcessor` with methods to query and aggregate the parsed data. This makes it easy for consumers to get specific information about tool usage, file changes, and execution metrics.\n\n## Requirements\n\n### Query Methods\nAdd public query methods to `StreamJsonProcessor`:\n\n1. **`getToolCallsByName(toolName: string): ToolCall[]`**\n   - Filter tool calls by name\n   - Example: Get all Bash commands, all Read operations\n\n2. **`getFileChangesByPath(path: string): FileChange[]`**\n   - Filter file changes by path\n   - Useful for tracking modifications to specific files\n\n3. **`getFileChangesByOperation(operation: 'read' | 'write' | 'edit'): FileChange[]`**\n   - Filter by operation type\n   - Example: Get all files written\n\n4. **`getFailedToolCalls(): ToolCall[]`**\n   - Return only tool calls with status='error'\n   - Useful for error analysis\n\n5. **`getSuccessfulToolCalls(): ToolCall[]`**\n   - Return only tool calls with status='success'\n\n6. **`getTotalCost(): number`**\n   - Calculate total cost from usage metrics\n   - Return in dollars (or appropriate currency)\n\n7. **`getExecutionSummary(): ExecutionSummary`**\n   - Aggregate view of execution:\n     - Total messages processed\n     - Tool call counts by type\n     - File operation counts by type\n     - Success/failure rates\n     - Total tokens used\n     - Total cost\n\n### Metadata Aggregation\nTrack additional metadata in `_metrics`:\n- Tool call success/failure counts\n- File operation counts by type\n- Timestamp of first/last message\n- Processing duration\n\n### ExecutionSummary Type\nDefine new type for summary data:\n```typescript\nexport interface ExecutionSummary {\n  totalMessages: number;\n  toolCallsByType: Record<string, number>;\n  fileOperationsByType: Record<string, number>;\n  successRate: number; // percentage\n  totalTokens: {\n    input: number;\n    output: number;\n    cache: number;\n  };\n  totalCost: number;\n  duration: number; // milliseconds\n  startTime: Date;\n  endTime?: Date;\n}\n```\n\n## Acceptance Criteria\n- [ ] All 7 query methods implemented and tested\n- [ ] `ExecutionSummary` type defined\n- [ ] `getExecutionSummary()` returns complete aggregate view\n- [ ] Metadata tracks first/last message timestamps\n- [ ] Cost calculation accurate (based on token pricing)\n- [ ] All methods handle empty state gracefully\n- [ ] TypeScript compilation passes\n- [ ] Methods are performant (no unnecessary iterations)\n\n## Implementation Notes\n- Use `Array.filter()` for query methods\n- Cache aggregated data where possible to avoid recomputation\n- Consider adding method to reset/clear state\n- Token pricing can be configurable (pass in constructor?)\n\n## Dependencies\n- Depends on: ISSUE-092 (message handlers)\n\n## Estimated Effort\nMedium (4-5 hours)","status":"closed","priority":1,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-30 08:36:34","updated_at":"2025-10-30 10:26:46","closed_at":"2025-10-30 10:26:46","parent_id":null,"relationships":[{"from":"ISSUE-094","from_type":"issue","to":"SPEC-007","to_type":"spec","type":"implements"},{"from":"ISSUE-094","from_type":"issue","to":"ISSUE-093","to_type":"issue","type":"depends-on"}],"tags":[]}
{"id":"ISSUE-095","uuid":"a87b95a5-7df5-49b4-b08c-e807d46fa55e","title":"Unit Tests: Comprehensive Testing for Output Processing","content":"Implements [[SPEC-007]] - Create comprehensive unit tests for the Output Processing Layer.\n\n## Overview\nCreate unit tests covering all functionality of the Output Processing Layer, including types, parsing, handlers, and queries.\n\n## Requirements\n\n### Test File Structure\nCreate test files in `tests/unit/execution/output/`:\n\n1. **`stream-json-processor.test.ts`**\n   - Core parsing functionality\n   - Message routing\n   - State management\n\n2. **`message-handlers.test.ts`**\n   - Individual message type handlers\n   - Tool call tracking\n   - File change detection\n\n3. **`queries.test.ts`**\n   - Query method functionality\n   - Data aggregation\n   - Summary generation\n\n### Test Coverage\n\n#### stream-json-processor.test.ts (15+ tests)\n- Constructor initialization\n- `processLine` with valid JSON\n- `processLine` with invalid JSON (error handling)\n- `processLine` with empty lines\n- Message type routing\n- Event handler registration\n- Event emission\n- Getter methods return correct state\n- Multiple lines processed in sequence\n\n#### message-handlers.test.ts (20+ tests)\n**Tool Use Handler:**\n- Creates tool call with pending status\n- Extracts tool name and parameters\n- Assigns unique ID\n- Emits onToolCall event\n\n**Tool Result Handler:**\n- Updates matching tool call status\n- Stores result data\n- Handles success case\n- Handles error case\n- Detects file changes from Read tool\n- Detects file changes from Write tool\n- Detects file changes from Edit tool\n- Emits onFileChange event\n- Handles missing tool call ID gracefully\n\n**Usage Handler:**\n- Extracts token counts\n- Calculates costs\n- Updates metrics\n\n**Error Handler:**\n- Tracks error details\n- Emits onError event\n\n**Text Handler:**\n- Updates message count\n- Optional progress events\n\n#### queries.test.ts (15+ tests)\n- `getToolCallsByName` filters correctly\n- `getFileChangesByPath` filters correctly\n- `getFileChangesByOperation` filters correctly\n- `getFailedToolCalls` returns only errors\n- `getSuccessfulToolCalls` returns only successes\n- `getTotalCost` calculates correctly\n- `getExecutionSummary` aggregates all data\n- Query methods handle empty state\n- Query methods handle partial data\n- Summary includes correct counts\n\n### Test Data\nCreate fixtures with sample stream-json messages:\n- Tool use messages for various tools (Bash, Read, Write, Edit)\n- Tool result messages (success and error)\n- Usage messages with token counts\n- Error messages\n- Text messages\n\n## Acceptance Criteria\n- [ ] 50+ unit tests total across all files\n- [ ] All test files in `tests/unit/execution/output/`\n- [ ] 100% code coverage of public methods\n- [ ] Tests use Vitest framework\n- [ ] Mock data fixtures for common scenarios\n- [ ] All tests pass: `npm --prefix server test -- --run tests/unit/execution/output/`\n- [ ] TypeScript compilation passes\n- [ ] Tests follow existing patterns (e.g., workflow tests)\n\n## Implementation Notes\n- Reference existing test files in `tests/unit/execution/workflow/` for patterns\n- Use `beforeEach` to create fresh processor instances\n- Test edge cases: malformed data, missing fields, unexpected types\n- Verify event handlers receive correct data\n- Use `vi.fn()` for event handler mocks\n\n## Dependencies\n- Depends on: ISSUE-093 (extraction and metadata)\n\n## Estimated Effort\nLarge (8-10 hours)","status":"closed","priority":1,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-30 08:36:34","updated_at":"2025-10-30 10:28:12","closed_at":"2025-10-30 10:28:12","parent_id":null,"relationships":[{"from":"ISSUE-095","from_type":"issue","to":"SPEC-007","to_type":"spec","type":"implements"},{"from":"ISSUE-095","from_type":"issue","to":"ISSUE-094","to_type":"issue","type":"depends-on"}],"tags":[]}
{"id":"ISSUE-096","uuid":"206194f7-210b-41c4-ab18-57624e056c7a","title":"Integration Tests: End-to-End Output Processing Scenarios","content":"Implements [[SPEC-007]] - Create integration tests for complete output processing workflows.\n\n## Overview\nCreate integration tests that validate the Output Processing Layer with realistic Claude Code output streams. These tests ensure the layer works correctly with real-world data.\n\n## Requirements\n\n### Test File\nCreate `tests/integration/execution/output/end-to-end.test.ts`\n\n### Integration Test Scenarios\n\n#### 1. Simple Tool Execution (3 tests)\n- Process stream with single Bash command\n- Verify tool call created and completed\n- Verify metrics updated correctly\n\n#### 2. File Operations (5 tests)\n- Process stream with Read operation\n- Process stream with Write operation\n- Process stream with Edit operation\n- Verify file changes tracked for each\n- Verify multiple file operations in sequence\n\n#### 3. Error Handling (4 tests)\n- Process stream with failed tool call\n- Verify error state captured\n- Verify error event emitted\n- Verify metrics include failure count\n\n#### 4. Complex Multi-Tool Workflow (3 tests)\n- Process stream with multiple different tools\n- Verify all tool calls tracked in order\n- Verify correct success/failure counts\n- Verify execution summary accurate\n\n#### 5. Usage Tracking (3 tests)\n- Process stream with usage messages\n- Verify token counts accumulated\n- Verify cost calculated correctly\n\n#### 6. Large Stream Processing (2 tests)\n- Process 100+ messages\n- Verify performance acceptable (< 1s)\n- Verify memory usage reasonable\n\n#### 7. Event-Driven Integration (4 tests)\n- Register all event handlers\n- Process diverse stream\n- Verify events fired in correct order\n- Verify event data matches processed data\n\n#### 8. Query Integration (3 tests)\n- Process realistic stream\n- Query data in various ways\n- Verify query results match expectations\n\n### Test Data\nUse actual Claude Code output captures:\n- Capture real stream-json output from sample commands\n- Store in `tests/fixtures/output/` directory\n- Examples:\n  - `simple-bash.jsonl` - Basic bash command\n  - `file-operations.jsonl` - Read/Write/Edit sequence\n  - `complex-workflow.jsonl` - Multi-tool execution\n  - `error-case.jsonl` - Failed tool execution\n\n### Helper Functions\nCreate test utilities:\n```typescript\nasync function processStream(\n  processor: IOutputProcessor,\n  lines: string[]\n): Promise<void> {\n  for (const line of lines) {\n    await processor.processLine(line);\n  }\n}\n\nfunction loadFixture(name: string): string[] {\n  // Load .jsonl file and split into lines\n}\n```\n\n## Acceptance Criteria\n- [ ] 27+ integration tests covering all scenarios\n- [ ] Test file in `tests/integration/execution/output/`\n- [ ] Real stream-json fixtures in `tests/fixtures/output/`\n- [ ] Tests validate complete workflows\n- [ ] Tests verify event-driven behavior\n- [ ] Performance benchmarks met\n- [ ] All tests pass: `npm --prefix server test -- --run tests/integration/execution/output/`\n- [ ] TypeScript compilation passes\n\n## Implementation Notes\n- Use `beforeEach` to create fresh processor and event handlers\n- Accumulate event data in test to verify against final state\n- Consider adding benchmark tests with `test.concurrent`\n- Validate that events fire before method returns (synchronous behavior)\n- Test realistic scenarios that might occur in production\n\n## Dependencies\n- Depends on: ISSUE-094 (unit tests)\n- Soft dependency: Real Claude Code output captures (can use synthetic data initially)\n\n## Estimated Effort\nLarge (8-10 hours)","status":"closed","priority":1,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-30 08:36:34","updated_at":"2025-10-30 10:36:18","closed_at":"2025-10-30 10:36:18","parent_id":null,"relationships":[{"from":"ISSUE-096","from_type":"issue","to":"SPEC-007","to_type":"spec","type":"implements"},{"from":"ISSUE-096","from_type":"issue","to":"ISSUE-095","to_type":"issue","type":"depends-on"}],"tags":[]}
{"id":"ISSUE-097","uuid":"77bce1e8-7852-4abd-97ac-300b11e0d85f","title":"Implement AG-UI Event Types and Schemas","content":"# Overview\n\nImplement the AG-UI event type system and Zod validation schemas as specified in [[SPEC-009]].\n\n## Tasks\n\n- [ ] Create `server/src/execution/output/ag-ui-types.ts`\n- [ ] Define `AgUiEventType` enum with all 17 event types\n- [ ] Implement Zod schemas for each event type\n- [ ] Export discriminated union `AgUiEvent` type\n- [ ] Add JSDoc documentation for each event type\n\n## Acceptance Criteria\n\n- All 17 AG-UI event types are defined (TEXT_MESSAGE_*, TOOL_CALL_*, STATE_*, RUN_*, STEP_*, CUSTOM)\n- Each event type has a Zod schema with proper validation\n- Type exports compile without errors\n- Event types are discriminated unions for type safety\n\n## References\n\n- [[SPEC-009]] Section \"Part 1: AG-UI Adapter Layer - Core Types\"\n\n## Implementation Notes\n\nEvent types to implement:\n- TEXT_MESSAGE_START, TEXT_MESSAGE_CONTENT, TEXT_MESSAGE_END\n- TOOL_CALL_START, TOOL_CALL_ARGS, TOOL_CALL_END, TOOL_CALL_RESULT\n- STATE_SNAPSHOT, STATE_DELTA\n- RUN_STARTED, RUN_FINISHED, RUN_ERROR\n- STEP_STARTED, STEP_FINISHED\n- CUSTOM","status":"closed","priority":0,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-30 20:23:32","updated_at":"2025-10-30 20:37:53","closed_at":"2025-10-30 20:37:53","parent_id":null,"relationships":[{"from":"ISSUE-097","from_type":"issue","to":"SPEC-009","to_type":"spec","type":"implements"}],"tags":[]}
{"id":"ISSUE-098","uuid":"97a96b06-9f19-42e3-bc8a-829a01792c37","title":"Implement AgUiEventAdapter class","content":"# Overview\n\nImplement the `AgUiEventAdapter` class that subscribes to SPEC-007 events and transforms them into AG-UI protocol events as specified in [[SPEC-009]].\n\n## Tasks\n\n- [ ] Create `server/src/execution/output/ag-ui-adapter.ts`\n- [ ] Implement `AgUiEventAdapter` class with constructor taking `runId`\n- [ ] Implement `connectToProcessor(processor: IOutputProcessor)` method\n- [ ] Implement event handler methods:\n  - `handleToolCall(toolCall: ToolCall): void`\n  - `handleFileChange(fileChange: FileChange): void`\n  - `handleProgress(metrics: ProcessingMetrics): void`\n  - `handleError(error): void`\n- [ ] Implement listener registration: `onEvent()`, `offEvent()`\n- [ ] Implement private `emit()` method\n- [ ] Add helper methods: `emitStateSnapshot()`\n\n## Acceptance Criteria\n\n- AgUiEventAdapter subscribes to all SPEC-007 event handlers\n- Each SPEC-007 event type correctly transforms to AG-UI events\n- Tool calls emit TOOL_CALL_START → TOOL_CALL_ARGS → TOOL_CALL_END sequence\n- Progress updates emit STATE_DELTA events with metrics\n- Listeners can subscribe to AG-UI events via `onEvent()`\n- All methods have proper TypeScript types\n\n## References\n\n- [[SPEC-009]] Section \"AG-UI Event Adapter Implementation\"\n- Depends on: [[ISSUE-097]]\n\n## Implementation Notes\n\nKey transformation mappings:\n- `ToolCall` → TOOL_CALL_START, TOOL_CALL_ARGS, TOOL_CALL_END, TOOL_CALL_RESULT (if completed)\n- `FileChange` → CUSTOM event with file operation details\n- `ProcessingMetrics` → STATE_DELTA with progress information\n- Error → RUN_ERROR event","status":"closed","priority":0,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-30 20:23:44","updated_at":"2025-10-30 20:55:32","closed_at":"2025-10-30 20:55:32","parent_id":null,"relationships":[{"from":"ISSUE-098","from_type":"issue","to":"ISSUE-097","to_type":"issue","type":"depends-on"},{"from":"ISSUE-098","from_type":"issue","to":"SPEC-009","to_type":"spec","type":"implements"}],"tags":[]}
{"id":"ISSUE-099","uuid":"b16c38cc-2857-4cef-a505-0b18934c86e9","title":"Implement SSE Transport Layer","content":"# Overview\n\nImplement the Server-Sent Events (SSE) transport layer for streaming AG-UI events to the frontend as specified in [[SPEC-009]].\n\n## Tasks\n\n- [ ] Create `server/src/execution/transport/sse-transport.ts`\n- [ ] Implement `SseTransport` class\n- [ ] Implement `handleConnection(clientId, res, runId?)` method\n- [ ] Implement `sendToClient(clientId, event)` method\n- [ ] Implement `broadcast(event)` method for all clients\n- [ ] Implement `broadcastToRun(runId, event)` method for run-specific clients\n- [ ] Implement `removeClient(clientId)` method\n- [ ] Implement heartbeat mechanism (ping every 30s)\n- [ ] Implement connection management (track clients, handle disconnects)\n- [ ] Add proper SSE headers and formatting\n\n## Acceptance Criteria\n\n- SSE connections can be established from frontend\n- Events are properly formatted as SSE data\n- Clients receive events in real-time\n- Heartbeat keeps connections alive\n- Clients can be filtered by runId\n- Disconnected clients are properly cleaned up\n- Multiple concurrent clients are supported\n- No memory leaks from stale connections\n\n## References\n\n- [[SPEC-009]] Section \"Part 2: Transport Layer - SSE Transport\"\n- Depends on: [[ISSUE-098]]\n\n## Implementation Notes\n\nSSE format:\n```\nevent: TOOL_CALL_START\ndata: {\"type\":\"TOOL_CALL_START\",\"toolCallId\":\"...\"}\n\n```\n\nHeaders:\n- Content-Type: text/event-stream\n- Cache-Control: no-cache\n- Connection: keep-alive","status":"closed","priority":1,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-30 20:24:11","updated_at":"2025-10-30 22:23:50","closed_at":"2025-10-30 22:05:49","parent_id":null,"relationships":[{"from":"ISSUE-099","from_type":"issue","to":"ISSUE-098","to_type":"issue","type":"depends-on"},{"from":"ISSUE-099","from_type":"issue","to":"SPEC-009","to_type":"spec","type":"implements"}],"tags":[]}
{"id":"ISSUE-100","uuid":"fb002042-c733-4466-9991-f9a5bb53ecfa","title":"Implement TransportManager","content":"# Overview\n\nImplement the `TransportManager` class that coordinates between the AG-UI adapter and SSE transport as specified in [[SPEC-009]].\n\n## Tasks\n\n- [ ] Create `server/src/execution/transport/transport-manager.ts`\n- [ ] Implement `TransportManager` class\n- [ ] Initialize `SseTransport` in constructor\n- [ ] Implement `connectAdapter(adapter, runId?)` method\n- [ ] Implement `broadcast(event)` method\n- [ ] Implement `broadcastToRun(runId, event)` method\n- [ ] Implement `getSseTransport()` getter\n- [ ] Implement `shutdown()` cleanup method\n\n## Acceptance Criteria\n\n- TransportManager creates and manages SseTransport instance\n- `connectAdapter()` properly wires adapter events to transport\n- Events from adapter are broadcast via SSE\n- Run-specific filtering works correctly\n- Cleanup releases all resources\n\n## References\n\n- [[SPEC-009]] Section \"Transport Manager\"\n- Depends on: [[ISSUE-099]]\n\n## Implementation Notes\n\nThe manager acts as a facade that:\n1. Subscribes to adapter's `onEvent()` \n2. Routes events to appropriate broadcast method\n3. Provides access to underlying transport for route handlers","status":"closed","priority":1,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-30 20:24:22","updated_at":"2025-10-30 22:43:43","closed_at":"2025-10-30 22:43:43","parent_id":null,"relationships":[{"from":"ISSUE-100","from_type":"issue","to":"SPEC-009","to_type":"spec","type":"implements"}],"tags":[]}
{"id":"ISSUE-101","uuid":"b7e559fa-d8dd-480d-abb0-e38e74521a18","title":"Implement SSE API Endpoint","content":"# Overview\n\nImplement the Express API endpoint for SSE streaming at `GET /api/executions/:executionId/stream` as specified in [[SPEC-009]].\n\n## Tasks\n\n- [ ] Create `server/src/routes/executions-stream.ts`\n- [ ] Implement `createExecutionStreamRoutes(transportManager)` factory\n- [ ] Add SSE endpoint: `GET /:executionId/stream`\n- [ ] Generate unique client ID for each connection\n- [ ] Call `transportManager.getSseTransport().handleConnection()`\n- [ ] Handle authentication/authorization (TODO marker for now)\n- [ ] Register routes in main Express app\n- [ ] Add integration test for SSE connection\n\n## Acceptance Criteria\n\n- Endpoint responds with correct SSE headers\n- Client connections are established successfully\n- ExecutionId is properly passed to transport\n- Route is registered in Express app\n- Test verifies SSE connection works\n\n## References\n\n- [[SPEC-009]] Section \"API Routes\"\n- Depends on: [[ISSUE-100]]\n\n## Implementation Notes\n\nRoute registration in `server/src/index.ts`:\n```typescript\nimport { createExecutionStreamRoutes } from './routes/executions-stream.js';\n\nconst streamRoutes = createExecutionStreamRoutes(transportManager);\napp.use('/api/executions', streamRoutes);\n```","status":"closed","priority":1,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-30 20:24:33","updated_at":"2025-10-30 22:58:28","closed_at":"2025-10-30 22:58:28","parent_id":null,"relationships":[{"from":"ISSUE-101","from_type":"issue","to":"SPEC-009","to_type":"spec","type":"implements"}],"tags":[]}
{"id":"ISSUE-102","uuid":"556aa442-d5c7-4c45-be42-e62a07041dae","title":"Create AG-UI Integration Helper Functions","content":"# Overview\n\nCreate helper functions to simplify wiring SPEC-007 to SPEC-009 as specified in [[SPEC-009]].\n\n## Tasks\n\n- [ ] Create `server/src/execution/output/ag-ui-integration.ts`\n- [ ] Implement `createAgUiSystem(runId)` factory function\n- [ ] Implement `wireManually(processor, adapter)` helper\n- [ ] Export integration functions\n- [ ] Add JSDoc documentation with usage examples\n- [ ] Create integration test\n\n## Acceptance Criteria\n\n- `createAgUiSystem()` returns connected processor and adapter\n- Factory function properly wires all event handlers\n- Manual wiring function provides flexibility\n- Integration test verifies event flow works end-to-end\n- Documentation includes complete usage example\n\n## References\n\n- [[SPEC-009]] Section \"Integration with SPEC-007 Output Processor\"\n- Depends on: [[ISSUE-098]]\n\n## Implementation Notes\n\n```typescript\nexport function createAgUiSystem(runId: string) {\n  const processor = new ClaudeCodeOutputProcessor();\n  const adapter = new AgUiEventAdapter(runId);\n  adapter.connectToProcessor(processor);\n  return { processor, adapter };\n}\n```","status":"open","priority":1,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-30 20:24:43","updated_at":"2025-10-30 20:24:43","closed_at":null,"parent_id":null,"relationships":[{"from":"ISSUE-102","from_type":"issue","to":"SPEC-009","to_type":"spec","type":"implements"},{"from":"ISSUE-102","from_type":"issue","to":"ISSUE-098","to_type":"issue","type":"depends-on"}],"tags":[]}
{"id":"ISSUE-103","uuid":"6b48db34-59ee-4059-8d6b-88f8ad058154","title":"Integrate AG-UI with LinearOrchestrator Lifecycle Events","content":"# Overview\n\nIntegrate AG-UI event emission with LinearOrchestrator workflow lifecycle events as specified in [[SPEC-009]].\n\n## Tasks\n\n- [ ] Modify `server/src/execution/workflow/linear-orchestrator.ts`\n- [ ] Add optional `AgUiEventAdapter` parameter to constructor\n- [ ] Emit RUN_STARTED event when `startWorkflow()` is called\n- [ ] Emit RUN_FINISHED event when workflow completes\n- [ ] Emit RUN_ERROR event when workflow fails\n- [ ] Emit STEP_STARTED event when each step begins\n- [ ] Emit STEP_FINISHED event when each step completes\n- [ ] Update STATE_SNAPSHOT events with workflow context\n- [ ] Add unit tests for event emission\n- [ ] Update integration tests to verify events\n\n## Acceptance Criteria\n\n- LinearOrchestrator emits all workflow lifecycle events\n- RUN_STARTED includes runId, threadId, workflowId\n- STEP events include stepId, stepName\n- Events are emitted at correct lifecycle points\n- Tests verify event timing and content\n- Existing workflow behavior unchanged\n- Adapter is optional (backward compatible)\n\n## References\n\n- [[SPEC-009]] Section \"Integration with LinearOrchestrator\"\n- [[SPEC-006]] for LinearOrchestrator API\n- Depends on: [[ISSUE-098]]\n\n## Implementation Notes\n\nAdd to LinearOrchestrator:\n```typescript\nconstructor(\n  private executor: IResilientExecutor,\n  private storage?: IWorkflowStorage,\n  private agUiAdapter?: AgUiEventAdapter\n) {}\n```\n\nEmit events at key points:\n- Start: before executing first step\n- Step start: before executeStep()\n- Step finish: after executeStep() succeeds\n- Finish: after all steps complete\n- Error: in catch blocks","status":"open","priority":2,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-30 20:25:16","updated_at":"2025-10-30 20:25:16","closed_at":null,"parent_id":null,"relationships":[{"from":"ISSUE-103","from_type":"issue","to":"ISSUE-098","to_type":"issue","type":"depends-on"},{"from":"ISSUE-103","from_type":"issue","to":"SPEC-009","to_type":"spec","type":"implements"}],"tags":[]}
{"id":"ISSUE-104","uuid":"1cd2bdf1-c3d8-4efd-8acc-9e686877ce60","title":"Implement Frontend AG-UI Types","content":"# Overview\n\nImplement TypeScript types for AG-UI events on the frontend as specified in [[SPEC-009]].\n\n## Tasks\n\n- [ ] Create `frontend/src/types/ag-ui.ts`\n- [ ] Define `AgUiEventType` enum (matching backend)\n- [ ] Define `AgUiEvent` discriminated union types\n- [ ] Define helper types for hook state\n- [ ] Add JSDoc documentation\n- [ ] Ensure types match backend AG-UI schema\n\n## Acceptance Criteria\n\n- All 17 AG-UI event types are defined\n- Event types are properly discriminated unions\n- Types compile without errors\n- Types match backend definitions\n- Can be imported by React components\n\n## References\n\n- [[SPEC-009]] Section \"Part 3: Frontend Integration\"\n- Backend types: `server/src/execution/output/ag-ui-types.ts`\n- Depends on: [[ISSUE-097]]\n\n## Implementation Notes\n\nFrontend types can be simpler than backend (no Zod validation needed), but must match the structure of events received via SSE.","status":"open","priority":2,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-30 20:25:26","updated_at":"2025-10-30 20:25:26","closed_at":null,"parent_id":null,"relationships":[{"from":"ISSUE-104","from_type":"issue","to":"ISSUE-097","to_type":"issue","type":"depends-on"},{"from":"ISSUE-104","from_type":"issue","to":"SPEC-009","to_type":"spec","type":"implements"}],"tags":[]}
{"id":"ISSUE-105","uuid":"ecda1def-82f1-43d1-b67c-86586e3fea96","title":"Implement useAgUiStream React Hook","content":"# Overview\n\nImplement the `useAgUiStream` React hook for consuming AG-UI events via SSE as specified in [[SPEC-009]].\n\n## Tasks\n\n- [ ] Create `frontend/src/hooks/useAgUiStream.ts`\n- [ ] Define `UseAgUiStreamOptions` interface\n- [ ] Define `AgUiStreamState` interface\n- [ ] Implement `useAgUiStream(options)` hook\n- [ ] Set up EventSource connection to `/api/executions/:id/stream`\n- [ ] Listen to all AG-UI event types\n- [ ] Implement state management for messages, tool calls, progress\n- [ ] Handle TEXT_MESSAGE_* events (buffering content)\n- [ ] Handle TOOL_CALL_* events (tracking status)\n- [ ] Handle STATE_DELTA events (updating progress)\n- [ ] Handle connection states (connecting, connected, error, disconnected)\n- [ ] Handle cleanup on unmount\n- [ ] Add unit tests using mock EventSource\n\n## Acceptance Criteria\n\n- Hook establishes SSE connection correctly\n- All AG-UI event types are handled\n- State updates reflect event stream\n- Message buffering works (TEXT_MESSAGE_CONTENT deltas)\n- Tool call tracking shows pending → completed/error\n- Progress updates from STATE_DELTA\n- Connection cleanup prevents memory leaks\n- Tests verify event handling logic\n\n## References\n\n- [[SPEC-009]] Section \"React Hook for AG-UI Streaming\"\n- Depends on: [[ISSUE-104]]\n\n## Implementation Notes\n\nUse native EventSource API:\n```typescript\nconst eventSource = new EventSource(`/api/executions/${executionId}/stream`);\nObject.values(AgUiEventType).forEach(eventType => {\n  eventSource.addEventListener(eventType, (e: MessageEvent) => {\n    const event: AgUiEvent = JSON.parse(e.data);\n    handleEvent(event);\n  });\n});\n```","status":"open","priority":2,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-30 20:25:38","updated_at":"2025-10-30 20:25:38","closed_at":null,"parent_id":null,"relationships":[{"from":"ISSUE-105","from_type":"issue","to":"ISSUE-104","to_type":"issue","type":"depends-on"},{"from":"ISSUE-105","from_type":"issue","to":"SPEC-009","to_type":"spec","type":"implements"}],"tags":[]}
{"id":"ISSUE-106","uuid":"8ac08482-563a-44f7-8fb1-55a8cc3c300c","title":"Implement ExecutionMonitor Component","content":"# Overview\n\nImplement the `ExecutionMonitor` React component that displays real-time execution status using the AG-UI stream.\n\n## Tasks\n\n- [ ] Create `frontend/src/components/executions/ExecutionMonitor.tsx`\n- [ ] Use `useAgUiStream` hook to connect to event stream\n- [ ] Display execution status (connecting, running, completed, error)\n- [ ] Show current activity/progress\n- [ ] Display token usage and cost\n- [ ] Show tool call count and file change count\n- [ ] Render child components: ToolCallViewer, MessageStream\n- [ ] Handle loading and error states\n- [ ] Add prop: `executionId`, `onComplete?`, `onError?`\n- [ ] Add styling with Tailwind CSS\n- [ ] Add component tests\n\n## Acceptance Criteria\n\n- Component connects to SSE stream via hook\n- Real-time updates display correctly\n- Status indicators show current state\n- Progress metrics update in real-time\n- Clean UI with proper loading states\n- Tests verify rendering and updates\n\n## References\n\n- [[SPEC-009]] Section \"Part 3: Frontend Integration\"\n- Depends on: [[ISSUE-105]]\n\n## Implementation Notes\n\nLayout structure:\n- Header: execution status, progress bar\n- Main: message stream, tool calls\n- Footer: metrics (tokens, cost, files changed)","status":"open","priority":2,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-30 20:25:49","updated_at":"2025-10-30 20:25:49","closed_at":null,"parent_id":null,"relationships":[{"from":"ISSUE-106","from_type":"issue","to":"ISSUE-105","to_type":"issue","type":"depends-on"},{"from":"ISSUE-106","from_type":"issue","to":"SPEC-009","to_type":"spec","type":"implements"}],"tags":[]}
{"id":"ISSUE-107","uuid":"cb2aa887-d830-4456-b335-d5107309a886","title":"Implement Supporting UI Components (ToolCallViewer, MessageStream, ProgressIndicator)","content":"# Overview\n\nImplement supporting UI components for the ExecutionMonitor as specified in [[SPEC-009]].\n\n## Tasks\n\n### ToolCallViewer Component\n- [ ] Create `frontend/src/components/executions/ToolCallViewer.tsx`\n- [ ] Display list of tool calls with status\n- [ ] Show tool name, arguments (collapsible), result\n- [ ] Color code by status (pending, success, error)\n- [ ] Add expand/collapse for tool details\n\n### MessageStream Component\n- [ ] Create `frontend/src/components/executions/MessageStream.tsx`\n- [ ] Display streaming text messages\n- [ ] Handle message buffering and display\n- [ ] Auto-scroll to latest message\n- [ ] Support markdown rendering\n\n### ProgressIndicator Component\n- [ ] Create `frontend/src/components/executions/ProgressIndicator.tsx`\n- [ ] Display progress metrics (tool calls, files, tokens)\n- [ ] Show visual progress indicators\n- [ ] Display cost information\n- [ ] Update in real-time from STATE_DELTA events\n\n## Acceptance Criteria\n\n- All three components render correctly\n- Components accept appropriate props from ExecutionMonitor\n- Real-time updates work smoothly\n- UI is clean and intuitive\n- Tests cover component rendering and updates\n\n## References\n\n- [[SPEC-009]] Section \"Part 3: Frontend Integration\"\n- Depends on: [[ISSUE-105]]\n\n## Implementation Notes\n\nThese are child components used by ExecutionMonitor. Keep them focused and reusable.","status":"open","priority":3,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-30 20:25:59","updated_at":"2025-10-30 20:25:59","closed_at":null,"parent_id":null,"relationships":[{"from":"ISSUE-107","from_type":"issue","to":"SPEC-009","to_type":"spec","type":"implements"},{"from":"ISSUE-107","from_type":"issue","to":"ISSUE-105","to_type":"issue","type":"depends-on"}],"tags":[]}
{"id":"ISSUE-108","uuid":"b2d5a828-3a82-4f0a-9e99-ca9c607b1e0d","title":"Write AG-UI Integration Tests","content":"# Overview\n\nWrite comprehensive integration and unit tests for the AG-UI system as specified in [[SPEC-009]].\n\n## Tasks\n\n### Backend Tests\n- [ ] Unit tests for AgUiEventAdapter event transformations\n- [ ] Unit tests for SseTransport connection management\n- [ ] Integration test: SPEC-007 events → AG-UI events\n- [ ] Integration test: Full pipeline (processor → adapter → SSE)\n- [ ] Integration test: SSE endpoint connection and streaming\n- [ ] Test heartbeat mechanism\n- [ ] Test client cleanup on disconnect\n\n### Frontend Tests\n- [ ] Unit tests for useAgUiStream hook\n- [ ] Component tests for ExecutionMonitor\n- [ ] Component tests for child components\n- [ ] Mock EventSource for testing\n- [ ] Test event buffering logic\n- [ ] Test state updates from events\n\n### E2E Tests (Optional)\n- [ ] Full stack test: backend → frontend streaming\n- [ ] Test multiple concurrent clients\n- [ ] Test reconnection scenarios\n\n## Acceptance Criteria\n\n- All tests pass\n- Code coverage >80% for new code\n- Integration tests verify end-to-end flow\n- Tests run in CI/CD pipeline\n- Mock EventSource works in test environment\n\n## References\n\n- [[SPEC-009]] Section \"Testing\" and \"E2E Tests\"\n- Depends on: [[ISSUE-101]], [[ISSUE-105]]\n\n## Implementation Notes\n\nUse Vitest for all tests. For EventSource mocking, consider using a test utility or manual mock.","status":"open","priority":3,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-30 20:26:10","updated_at":"2025-10-30 20:26:10","closed_at":null,"parent_id":null,"relationships":[{"from":"ISSUE-108","from_type":"issue","to":"ISSUE-101","to_type":"issue","type":"depends-on"},{"from":"ISSUE-108","from_type":"issue","to":"ISSUE-105","to_type":"issue","type":"depends-on"},{"from":"ISSUE-108","from_type":"issue","to":"SPEC-009","to_type":"spec","type":"implements"}],"tags":[]}
{"id":"ISSUE-109","uuid":"a1c59bcd-3f7a-4a1a-8054-bb3db986137a","title":"Create worktree manager interface and basic implementation","content":"## Overview\n\nImplement the `IWorktreeManager` interface and basic `WorktreeManager` class as specified in [[SPEC-010]].\n\n## Requirements\n\n### Interface Definition\nCreate `server/src/execution/worktree/manager.ts` with:\n- `IWorktreeManager` interface with methods:\n  - `createWorktree()` - Create new worktree for a session\n  - `ensureWorktreeExists()` - Ensure worktree exists with locking\n  - `cleanupWorktree()` - Clean up worktree and git metadata\n  - `isWorktreeValid()` - Check if worktree is properly set up\n\n### Basic Implementation\n- Implement `WorktreeManager` class\n- Load configuration from `.sudocode/config.json`\n- Initialize per-path locking mechanism (using async-mutex)\n- Basic validation logic\n\n### Dependencies\n- Depends on: Git CLI wrapper implementation\n- Depends on: Configuration schema\n\n## Acceptance Criteria\n- [ ] Interface defined with proper TypeScript types\n- [ ] Basic implementation compiles without errors\n- [ ] Configuration loaded from `.sudocode/config.json`\n- [ ] Locking mechanism initialized\n- [ ] Exports available from index file\n\n## References\n- [[SPEC-010]] - Worktree Management Design\n- Vibe-kanban reference: `crates/services/src/services/worktree_manager.rs`","status":"closed","priority":1,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-30 22:18:11","updated_at":"2025-10-30 22:23:25","closed_at":"2025-10-30 22:23:25","parent_id":null,"relationships":[{"from":"ISSUE-109","from_type":"issue","to":"SPEC-010","to_type":"spec","type":"implements"}],"tags":["foundation","phase-1","worktree"]}
{"id":"ISSUE-110","uuid":"1508ea93-2510-497f-8109-5ced9321f4ae","title":"Implement git CLI wrapper for worktree operations","content":"## Overview\n\nCreate a git CLI wrapper to handle all git worktree operations as specified in [[SPEC-010]].\n\n## Requirements\n\n### Interface Definition\nCreate `server/src/execution/worktree/git-cli.ts` with:\n- `IGitCli` interface with methods:\n  - `worktreeAdd()` - Add new worktree\n  - `worktreeRemove()` - Remove worktree\n  - `worktreePrune()` - Prune stale metadata\n  - `worktreeList()` - List all worktrees\n  - `createBranch()` - Create new branch\n  - `deleteBranch()` - Delete branch\n\n### Implementation\n- Use `execa` or `child_process.exec` for git commands\n- Proper command escaping for paths and branch names\n- Error handling with meaningful error messages\n- Parse git command output (especially for `worktree list`)\n- Support for sparse-checkout if configured\n\n## Example Commands\n```bash\ngit worktree add <path> <branch>\ngit worktree remove <path> --force\ngit worktree prune\ngit worktree list --porcelain\ngit branch <name> <base>\ngit branch -d <name>\n```\n\n## Acceptance Criteria\n- [ ] All methods implemented with proper error handling\n- [ ] Command output parsed correctly\n- [ ] Shell escaping handled properly\n- [ ] Exports available from index file\n- [ ] Works with both absolute and relative paths\n\n## References\n- [[SPEC-010]] - Worktree Management Design\n- Git worktree docs: https://git-scm.com/docs/git-worktree","status":"open","priority":1,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-30 22:18:11","updated_at":"2025-10-30 22:18:11","closed_at":null,"parent_id":null,"relationships":[{"from":"ISSUE-110","from_type":"issue","to":"SPEC-010","to_type":"spec","type":"implements"}],"tags":["foundation","git","phase-1","worktree"]}
{"id":"ISSUE-111","uuid":"339fa891-ae49-4804-80c6-4190d91a41fe","title":"Add configuration schema and loading from .sudocode/config.json","content":"## Overview\n\nCreate configuration schema for worktree settings and implement loading from `.sudocode/config.json` as specified in [[SPEC-010]].\n\n## Requirements\n\n### Configuration Schema\nCreate `server/src/config/worktree.ts` with:\n```typescript\ninterface WorktreeConfig {\n  worktreeStoragePath: string;        // Default: \".sudocode/worktrees\"\n  autoCreateBranches: boolean;         // Default: true\n  autoDeleteBranches: boolean;         // Default: false\n  enableSparseCheckout: boolean;       // Default: false\n  sparseCheckoutPatterns?: string[];\n  branchPrefix: string;                // Default: \"sudocode\"\n  cleanupOrphanedWorktreesOnStartup: boolean; // Default: true\n}\n```\n\n### Configuration Loading\n- Load from `.sudocode/config.json` (worktree section)\n- Validate configuration values\n- Use defaults for missing/invalid values\n- Warn user about invalid configuration\n- Export singleton or factory pattern for config access\n\n### Validation\n- `worktreeStoragePath` - valid path format\n- Boolean values - must be boolean\n- `sparseCheckoutPatterns` - array of strings\n- `branchPrefix` - valid git branch name characters\n\n## Example config.json\n```json\n{\n  \"worktree\": {\n    \"worktreeStoragePath\": \".sudocode/worktrees\",\n    \"autoCreateBranches\": true,\n    \"autoDeleteBranches\": false,\n    \"enableSparseCheckout\": false,\n    \"branchPrefix\": \"sudocode\",\n    \"cleanupOrphanedWorktreesOnStartup\": true\n  }\n}\n```\n\n## Acceptance Criteria\n- [ ] Configuration schema defined with TypeScript types\n- [ ] Configuration loaded from `.sudocode/config.json`\n- [ ] Defaults applied for missing values\n- [ ] Validation implemented with warnings\n- [ ] Can be imported by WorktreeManager\n- [ ] Unit tests for validation logic\n\n## References\n- [[SPEC-010]] - Worktree Management Design","status":"closed","priority":1,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-30 22:18:12","updated_at":"2025-10-30 22:29:40","closed_at":"2025-10-30 22:29:40","parent_id":null,"relationships":[{"from":"ISSUE-111","from_type":"issue","to":"SPEC-010","to_type":"spec","type":"implements"}],"tags":["config","foundation","phase-1","worktree"]}
{"id":"ISSUE-112","uuid":"9fe804f2-b213-4276-b46b-a2b6b06eafe4","title":"Add database schema for worktree tracking","content":"## Overview\n\nExtend the sessions table with worktree tracking fields as specified in [[SPEC-010]].\n\n## Requirements\n\n### Database Migration\nCreate migration to add worktree fields to sessions table:\n```sql\n-- Add worktree fields to sessions table\nALTER TABLE sessions ADD COLUMN worktree_path TEXT;\nALTER TABLE sessions ADD COLUMN branch_name TEXT NOT NULL;\nALTER TABLE sessions ADD COLUMN target_branch TEXT NOT NULL;\nALTER TABLE sessions ADD COLUMN worktree_deleted BOOLEAN NOT NULL DEFAULT FALSE;\n\n-- Index for cleanup queries\nCREATE INDEX idx_sessions_worktree_deleted ON sessions(worktree_deleted);\n```\n\n### Model Updates\nUpdate session model/types to include:\n```typescript\ninterface Session {\n  id: string;\n  issueId: string;\n  \n  // NEW: Worktree tracking\n  worktreePath: string | null;\n  branchName: string;\n  targetBranch: string;\n  worktreeDeleted: boolean;\n  \n  // Existing fields...\n  status: SessionStatus;\n  createdAt: Date;\n  updatedAt: Date;\n}\n```\n\n### Queries\nAdd database queries for:\n- Finding sessions with orphaned worktrees (for cleanup)\n- Marking worktrees as deleted\n- Finding sessions by worktree path\n- Finding sessions by branch name\n\n## Acceptance Criteria\n- [ ] Migration file created and tested\n- [ ] Session model/interface updated\n- [ ] Index created for cleanup queries\n- [ ] Migration runs successfully on test database\n- [ ] Model types match database schema\n- [ ] Can query orphaned worktrees\n\n## References\n- [[SPEC-010]] - Worktree Management Design\n- Vibe-kanban migrations for reference","status":"open","priority":1,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-30 22:18:13","updated_at":"2025-10-30 22:18:13","closed_at":null,"parent_id":null,"relationships":[{"from":"ISSUE-112","from_type":"issue","to":"SPEC-010","to_type":"spec","type":"implements"}],"tags":["database","foundation","phase-1","worktree"]}
{"id":"ISSUE-113","uuid":"74a9ee3f-264c-4bab-8fdf-5b38d103ed4b","title":"Write unit tests for worktree operations","content":"## Overview\n\nCreate comprehensive unit tests for worktree manager and git CLI wrapper as specified in [[SPEC-010]].\n\n## Requirements\n\n### WorktreeManager Tests\nCreate `server/tests/unit/execution/worktree/manager.test.ts`:\n- `should create a new worktree`\n- `should handle concurrent creation requests` (locking)\n- `should cleanup worktree completely`\n- `should recover from partial cleanup`\n- `should validate worktree existence`\n- `should handle metadata conflicts`\n- `should load configuration from config.json`\n- `should use default config values for missing settings`\n\n### GitCli Tests\nCreate `server/tests/unit/execution/worktree/git-cli.test.ts`:\n- `should execute git worktree add`\n- `should execute git worktree remove`\n- `should execute git worktree prune`\n- `should parse git worktree list output`\n- `should handle git errors gracefully`\n- `should create branches`\n- `should delete branches`\n\n### Test Setup\n- Use test fixtures with temporary git repositories\n- Mock file system operations where appropriate\n- Test both success and error paths\n- Test configuration validation\n\n## Acceptance Criteria\n- [ ] All WorktreeManager methods tested\n- [ ] All GitCli methods tested\n- [ ] Tests pass with `npm --prefix server test -- --run`\n- [ ] Test coverage > 80% for new code\n- [ ] Uses proper test cleanup (temp dirs removed)\n- [ ] Tests can run in parallel safely\n\n## References\n- [[SPEC-010]] - Worktree Management Design\n- Existing test patterns in `server/tests/unit/`","status":"open","priority":2,"assignee":null,"archived":0,"archived_at":null,"created_at":"2025-10-30 22:18:13","updated_at":"2025-10-30 22:18:13","closed_at":null,"parent_id":null,"relationships":[{"from":"ISSUE-113","from_type":"issue","to":"SPEC-010","to_type":"spec","type":"implements"}],"tags":["foundation","phase-1","testing","worktree"]}
