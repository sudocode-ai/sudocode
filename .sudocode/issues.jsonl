{"id":"ISSUE-001","uuid":"6a41fb64-d043-415d-911d-76f2536795f4","title":"Server: Project Initialization & Basic Express Setup","description":"Set up the basic TypeScript + Express project structure for the sudocode backend server.\n\n## Tasks\n- [ ] Create `server/` directory structure\n- [ ] Initialize `package.json` with dependencies (express, typescript, etc.)\n- [ ] Create `tsconfig.json` for TypeScript configuration\n- [ ] Set up basic Express app in `src/index.ts`\n- [ ] Add development scripts (dev, build, start)\n- [ ] Create `.env.example` for environment variables\n- [ ] Create `.gitignore` with appropriate entries\n\n## Files to Create\n```\nserver/\n├── src/\n│   └── index.ts          # Basic Express app\n├── package.json\n├── tsconfig.json\n├── .env.example\n└── .gitignore\n```\n\n## Verification\n- Server should start on http://localhost:3001\n- GET http://localhost:3001/health should return 200\n- `npm run dev` should start the server successfully\n\n## Success Criteria\nExpress server that starts successfully with a health check endpoint.\n\nReference: [[server/server_plan.md]] - Phase 1, Step 1.1","content":"\n","status":"closed","priority":0,"assignee":null,"created_at":"2025-10-24 09:53:37","updated_at":"2025-10-24 10:18:01","closed_at":"2025-10-24 10:18:01","parent_id":null,"relationships":[],"tags":["foundation","phase-1","server","setup"]}
{"id":"ISSUE-002","uuid":"326b22be-f823-4cf9-a281-c774cb6742cc","title":"Server: Database Setup & Schema Implementation","description":"Initialize SQLite database with schema for sudocode server.\n\n## Tasks\n- [ ] Create `src/services/db.ts` with database connection\n- [ ] Import schema from `../cli/src/schema.ts`\n- [ ] Add new tables for projects, issue_attempts, execution_processes\n- [ ] Add execution_process_logs table\n- [ ] Write database initialization function\n- [ ] Add database migration logic\n- [ ] Create helper functions for common queries\n\n## Files to Create\n```\nserver/src/\n├── services/\n│   └── db.ts             # Database connection & init\n└── types/\n    └── extended.ts       # Extended types (Project, IssueAttempt, etc.)\n```\n\n## Schema Additions\n- Projects table\n- Issue attempts table\n- Execution processes table\n- Execution process logs table\n\n## Verification\n- Run server with `npm run dev`\n- Database should be created at `server/sudocode.db`\n- All tables should be created successfully\n- Can query tables with sqlite3\n\n## Success Criteria\nWorking SQLite database with all required tables.\n\nReference: [[server/server_plan.md]] - Phase 1, Step 1.2","content":"\n","status":"closed","priority":0,"assignee":null,"created_at":"2025-10-24 09:53:37","updated_at":"2025-10-24 10:18:01","closed_at":"2025-10-24 10:18:01","parent_id":null,"relationships":[],"tags":["database","phase-1","schema","server"]}
{"id":"ISSUE-003","uuid":"827d2fb6-ce4d-4889-a53f-d93688057825","title":"Server: Read Issues from JSONL","description":"Load and serve issues from issues.jsonl file.\n\n## Tasks\n- [ ] Create `src/services/jsonl.ts` for JSONL operations\n- [ ] Implement `readIssuesJsonl(path)` function\n- [ ] Implement `parseIssueJsonl(line)` function\n- [ ] Create `src/services/issues.ts` for issue business logic\n- [ ] Create `src/routes/issues.ts` for issue routes\n- [ ] Implement GET `/api/tasks` (list issues)\n- [ ] Implement GET `/api/tasks/:id` (get issue by ID)\n- [ ] Add request validation and error handling\n\n## Files to Create\n```\nserver/src/\n├── routes/\n│   └── issues.ts         # Issue routes (mapped to /tasks)\n└── services/\n    ├── jsonl.ts          # JSONL read/write operations\n    └── issues.ts         # Issue business logic\n```\n\n## JSONL Operations\n```typescript\nexport async function readIssuesJsonl(path: string): Promise<IssueJSONL[]>\nexport async function writeIssuesJsonl(path: string, issues: IssueJSONL[]): Promise<void>\nexport function parseJsonlLine<T>(line: string): T | null\n```\n\n## API Response Format\n```typescript\ninterface ApiResponse<T> {\n  success: boolean\n  data: T | null\n  error_data?: any\n  message?: string\n}\n```\n\n## Verification\n```bash\ncurl http://localhost:3002/api/tasks\n# Should return issues from .sudocode/issues.jsonl\n\ncurl http://localhost:3002/api/tasks/ISSUE-001\n# Should return specific issue\n```\n\n## Success Criteria\nRead-only issues API that loads from JSONL files.\n\nReference: [[server/server_plan.md]] - Phase 3, Step 3.1","content":"\n","status":"closed","priority":0,"assignee":null,"created_at":"2025-10-24 10:09:13","updated_at":"2025-10-24 10:24:51","closed_at":"2025-10-24 10:24:51","parent_id":null,"relationships":[],"tags":["api","issues","phase-3","server"]}
{"id":"ISSUE-004","uuid":"ac4048e7-32c5-424f-a7c7-23dde7909c9c","title":"Server: Sync Issues to SQLite Cache","description":"Load JSONL data into SQLite for fast queries. The CLI already maintains the cache.db, so the server should read from the existing database.\n\n## Tasks\n- [ ] Update issues service to read from SQLite instead of JSONL\n- [ ] Implement `getIssues()` to query from database\n- [ ] Implement `getIssueById(id)` to query from database\n- [ ] Handle relationships and tags from database\n- [ ] Add indexes for common queries if not already present\n- [ ] Update GET endpoints to read from SQLite\n- [ ] Handle case when database is not synced (warn user)\n\n## Database Queries\n```typescript\nexport async function getIssues(filters?: IssueFilters): Promise<Issue[]>\nexport async function getIssueById(id: string): Promise<Issue | null>\nexport async function getIssueRelationships(id: string): Promise<Relationship[]>\nexport async function getIssueTags(id: string): Promise<string[]>\n```\n\n## Verification\n```bash\n# Ensure CLI has synced data first\nsudocode sync\n\n# Start server\nnpm run dev\n\n# Query via API\ncurl http://localhost:3002/api/tasks\n# Should return issues from SQLite\n\n# Check database directly\nsqlite3 .sudocode/cache.db \"SELECT COUNT(*) FROM issues;\"\n```\n\n## Success Criteria\nIssues loaded from SQLite cache maintained by CLI, with fast query performance.\n\nReference: [[server/server_plan.md]] - Phase 3, Step 3.2","content":"\n","status":"closed","priority":0,"assignee":null,"created_at":"2025-10-24 10:09:14","updated_at":"2025-10-24 16:55:50","closed_at":"2025-10-24 16:55:50","parent_id":null,"relationships":[],"tags":["database","issues","phase-3","server"]}
{"id":"ISSUE-005","uuid":"68030861-d410-4baf-b1dc-36f486862c5a","title":"Server: Create & Update Issues via API","description":"Implement write operations for issues, delegating to CLI operations for JSONL consistency.\n\n## Tasks\n- [ ] Implement POST `/api/tasks` (create issue)\n- [ ] Implement PUT `/api/tasks/:id` (update issue)\n- [ ] Use CLI operations from `@sudocode/cli` for consistency\n- [ ] Add request validation with Zod schemas\n- [ ] Handle validation errors gracefully\n- [ ] Return updated issue in response\n- [ ] Trigger sync after write operations\n\n## Integration with CLI\n```typescript\nimport { createIssue, updateIssue } from '@sudocode/cli/operations/issues'\n\nexport async function createIssueService(data: CreateIssueRequest): Promise<Issue> {\n  // Use CLI operation to create in JSONL\n  const issue = await createIssue(db, data)\n  \n  // CLI handles JSONL and SQLite sync\n  return issue\n}\n```\n\n## Request Validation\n```typescript\nconst createIssueSchema = z.object({\n  title: z.string().min(1).max(500),\n  description: z.string(),\n  status: z.enum(['open', 'in_progress', 'blocked', 'needs_review', 'closed']),\n  priority: z.number().min(0).max(4).optional(),\n  assignee: z.string().optional(),\n  tags: z.array(z.string()).optional(),\n})\n```\n\n## Verification\n```bash\n# Create new issue\ncurl -X POST http://localhost:3002/api/tasks \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"title\": \"Test Issue\", \"description\": \"Test\", \"status\": \"open\"}'\n\n# Update issue\ncurl -X PUT http://localhost:3002/api/tasks/ISSUE-001 \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"status\": \"in_progress\"}'\n\n# Check issues.jsonl updated\ncat .sudocode/issues.jsonl | tail -1\n```\n\n## Success Criteria\nFull create and update operations for issues with JSONL persistence via CLI.\n\nReference: [[server/server_plan.md]] - Phase 3, Step 3.3","content":"\n","status":"closed","priority":0,"assignee":null,"created_at":"2025-10-24 10:09:14","updated_at":"2025-10-24 17:23:50","closed_at":"2025-10-24 17:23:50","parent_id":null,"relationships":[],"tags":["api","crud","issues","phase-3","server"]}
{"id":"ISSUE-006","uuid":"5952bd3f-1731-4aa9-9ee0-3023570b8c75","title":"Server: Delete Issues via API","description":"Implement issue deletion with proper cascade handling.\n\n## Tasks\n- [ ] Implement DELETE `/api/tasks/:id`\n- [ ] Use CLI delete operation for consistency\n- [ ] Handle cascade deletion of relationships and tags\n- [ ] Add soft delete option (status='closed') as alternative\n- [ ] Return success response with deleted issue ID\n- [ ] Add confirmation requirement for destructive operations\n\n## Delete Operations\n```typescript\nexport async function deleteIssueService(id: string, soft: boolean = false): Promise<void> {\n  if (soft) {\n    // Soft delete: just close the issue\n    await updateIssue(db, id, { status: 'closed', closed_at: new Date().toISOString() })\n  } else {\n    // Hard delete: remove from JSONL and database\n    await deleteIssue(db, id)\n  }\n}\n```\n\n## API Design\n```typescript\n// Hard delete\nDELETE /api/tasks/:id\n\n// Soft delete (close)\nPUT /api/tasks/:id\n{ \"status\": \"closed\" }\n```\n\n## Verification\n```bash\n# Soft delete (close issue)\ncurl -X PUT http://localhost:3002/api/tasks/ISSUE-001 \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"status\": \"closed\"}'\n\n# Hard delete\ncurl -X DELETE http://localhost:3002/api/tasks/ISSUE-001\n\n# Verify removed from JSONL and SQLite\ncat .sudocode/issues.jsonl | grep ISSUE-001\n# Should return nothing\n\nsqlite3 .sudocode/cache.db \"SELECT * FROM issues WHERE id='ISSUE-001';\"\n# Should return nothing\n```\n\n## Success Criteria\nComplete CRUD operations for issues with both hard and soft delete options.\n\nReference: [[server/server_plan.md]] - Phase 3, Step 3.4","content":"\n","status":"closed","priority":0,"assignee":null,"created_at":"2025-10-24 10:09:14","updated_at":"2025-10-24 17:33:04","closed_at":"2025-10-24 17:33:04","parent_id":null,"relationships":[],"tags":["api","crud","issues","phase-3","server"]}
{"id":"ISSUE-007","uuid":"bff23a82-fea5-45e4-8519-ef2b01c1004c","title":"Server: Read Specs from JSONL","description":"Load and serve specs from specs.jsonl file, following the same pattern as the Issues API.\n\n## Tasks\n- [ ] Create `src/routes/specs.ts` for spec routes\n- [ ] Create `src/services/specs.ts` wrapping CLI operations\n- [ ] Implement GET `/api/specs` (list specs)\n- [ ] Implement GET `/api/specs/:id` (get spec by ID)\n- [ ] Use CLI operations from `@sudocode/cli` for consistency\n- [ ] Support filtering and pagination\n- [ ] Include relationships in response\n\n## Files to Create\n```\nserver/src/\n├── routes/\n│   └── specs.ts         # Spec routes (mapped to /api/specs)\n└── services/\n    └── specs.ts         # Spec business logic (wraps CLI)\n```\n\n## Integration with CLI\n```typescript\nimport { getSpec, listSpecs } from '@sudocode/cli/dist/operations/index.js'\n\nexport function getAllSpecs(db: Database.Database, options?: ListSpecsOptions): Spec[] {\n  return listSpecs(db, options || {})\n}\n\nexport function getSpecById(db: Database.Database, id: string): Spec | null {\n  return getSpec(db, id)\n}\n```\n\n## API Response Format\nSame as issues API:\n```typescript\ninterface ApiResponse<T> {\n  success: boolean\n  data: T | null\n  error_data?: any\n  message?: string\n}\n```\n\n## Verification\n```bash\ncurl http://localhost:3002/api/specs\n# Should return specs from SQLite\n\ncurl http://localhost:3002/api/specs/SPEC-001\n# Should return specific spec\n```\n\n## Success Criteria\nRead-only specs API that delegates to CLI operations, following the same patterns as Issues API.\n\nReference: [[server/server_plan.md]] - Phase 4, Step 4.1","content":"","status":"closed","priority":0,"assignee":null,"created_at":"2025-10-24 17:50:33","updated_at":"2025-10-24 18:04:49","closed_at":"2025-10-24 18:04:49","parent_id":null,"relationships":[],"tags":[]}
{"id":"ISSUE-008","uuid":"eccab6c9-845c-4271-9c2e-f436ec4247e7","title":"Server: Specs CRUD Operations","description":"Implement full create, update, and delete operations for specs via API.\n\n## Tasks\n- [ ] Implement POST `/api/specs` (create spec)\n- [ ] Implement PUT `/api/specs/:id` (update spec)\n- [ ] Implement DELETE `/api/specs/:id` (delete spec)\n- [ ] Use CLI operations from `@sudocode/cli` for consistency\n- [ ] Add request validation\n- [ ] Handle validation errors gracefully\n- [ ] Return created/updated spec in response\n- [ ] Add comprehensive tests for all CRUD operations\n\n## Integration with CLI\n```typescript\nimport { createSpec, updateSpec, deleteSpec } from '@sudocode/cli/dist/operations/index.js'\n\nexport function createNewSpec(db: Database.Database, input: CreateSpecInput): Spec {\n  return createSpec(db, input)\n}\n\nexport function updateExistingSpec(db: Database.Database, id: string, input: UpdateSpecInput): Spec {\n  return updateSpec(db, id, input)\n}\n\nexport function deleteExistingSpec(db: Database.Database, id: string): boolean {\n  return deleteSpec(db, id)\n}\n```\n\n## Request Validation\n- Title: required, max 500 characters\n- Content: optional markdown content\n- Priority: 0-4, default 2\n- Parent ID: optional, must exist if provided\n\n## Verification\n```bash\n# Create new spec\ncurl -X POST http://localhost:3002/api/specs \\\\\n  -H \"Content-Type: application/json\" \\\\\n  -d '{\"title\": \"Test Spec\", \"content\": \"# Spec content\"}'\n\n# Update spec\ncurl -X PUT http://localhost:3002/api/specs/SPEC-001 \\\\\n  -H \"Content-Type: application/json\" \\\\\n  -d '{\"content\": \"# Updated content\"}'\n\n# Delete spec\ncurl -X DELETE http://localhost:3002/api/specs/SPEC-001\n\n# Run tests\nnpm test\n```\n\n## Success Criteria\nFull CRUD operations for specs with CLI delegation and comprehensive test coverage.\n\nReference: [[server/server_plan.md]] - Phase 4, Step 4.2","content":"","status":"closed","priority":0,"assignee":null,"created_at":"2025-10-24 17:50:34","updated_at":"2025-10-24 18:13:32","closed_at":"2025-10-24 18:13:32","parent_id":null,"relationships":[],"tags":[]}
{"id":"ISSUE-009","uuid":"e3e058f4-d8b5-4260-b0a3-27fee8a7aa2c","title":"Server: Relationships API","description":"Manage relationships between issues and specs via REST API.\n\n## Tasks\n- [ ] Create `src/routes/relationships.ts` for relationship routes\n- [ ] Create `src/services/relationships.ts` wrapping CLI operations\n- [ ] Implement GET `/api/relationships?entity_id=X&entity_type=issue`\n- [ ] Implement POST `/api/relationships` (create relationship)\n- [ ] Implement DELETE `/api/relationships` (delete relationship)\n- [ ] Use CLI operations from `@sudocode/cli` for consistency\n- [ ] Add request validation\n- [ ] Add comprehensive tests\n\n## Integration with CLI\n```typescript\nimport { \n  getRelationships, \n  createRelationship, \n  deleteRelationship \n} from '@sudocode/cli/dist/operations/index.js'\n\nexport function getEntityRelationships(\n  db: Database.Database, \n  entityId: string, \n  entityType: EntityType\n): Relationship[] {\n  return getRelationships(db, entityId, entityType)\n}\n```\n\n## API Endpoints\n- `GET /api/relationships?entity_id=X&entity_type=issue` - Get relationships for entity\n- `POST /api/relationships` - Create relationship\n  ```json\n  {\n    \"from_id\": \"ISSUE-001\",\n    \"from_type\": \"issue\",\n    \"to_id\": \"SPEC-001\",\n    \"to_type\": \"spec\",\n    \"type\": \"implements\"\n  }\n  ```\n- `DELETE /api/relationships` - Delete relationship (same body as POST)\n\n## Relationship Types\n- `blocks` - Entity blocks another\n- `implements` - Issue implements spec\n- `references` - Entity references another\n- `depends-on` - Entity depends on another\n- `discovered-from` - Issue discovered from spec\n- `related` - Generic relationship\n\n## Verification\n```bash\n# Get relationships for an issue\ncurl http://localhost:3002/api/relationships?entity_id=ISSUE-001&entity_type=issue\n\n# Create relationship\ncurl -X POST http://localhost:3002/api/relationships \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"from_id\": \"ISSUE-001\", \"from_type\": \"issue\", \"to_id\": \"SPEC-001\", \"to_type\": \"spec\", \"type\": \"implements\"}'\n\n# Delete relationship\ncurl -X DELETE http://localhost:3002/api/relationships \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"from_id\": \"ISSUE-001\", \"from_type\": \"issue\", \"to_id\": \"SPEC-001\", \"to_type\": \"spec\", \"type\": \"implements\"}'\n```\n\n## Success Criteria\nRelationship management API with CLI delegation and full test coverage.\n\nReference: [[server/server_plan.md]] - Phase 5, Step 5.1","content":"","status":"closed","priority":0,"assignee":null,"created_at":"2025-10-24 18:16:41","updated_at":"2025-10-24 18:29:03","closed_at":"2025-10-24 18:29:03","parent_id":null,"relationships":[],"tags":[]}
{"id":"ISSUE-010","uuid":"79a841f8-d7df-4f2a-b5bb-3a4d2849fdef","title":"Server: Feedback API","description":"Manage issue feedback on specs via REST API.\n\n## Tasks\n- [ ] Create `src/routes/feedback.ts` for feedback routes\n- [ ] Create `src/services/feedback.ts` wrapping CLI operations\n- [ ] Implement GET `/api/feedback?spec_id=X` (list feedback for spec)\n- [ ] Implement GET `/api/feedback/:id` (get specific feedback)\n- [ ] Implement POST `/api/feedback` (add feedback)\n- [ ] Implement PUT `/api/feedback/:id` (update feedback)\n- [ ] Implement DELETE `/api/feedback/:id` (delete feedback)\n- [ ] Handle feedback anchors (line numbers, text snippets, section headings)\n- [ ] Use CLI operations from `@sudocode/cli` for consistency\n- [ ] Add request validation\n- [ ] Add comprehensive tests\n\n## Integration with CLI\n```typescript\nimport { \n  getFeedback, \n  createFeedback, \n  updateFeedback, \n  deleteFeedback \n} from '@sudocode/cli/dist/operations/index.js'\n\nexport function getSpecFeedback(\n  db: Database.Database, \n  specId: string\n): Feedback[] {\n  return getFeedback(db, specId)\n}\n```\n\n## API Endpoints\n- `GET /api/feedback?spec_id=SPEC-001` - List feedback for a spec\n- `GET /api/feedback/:id` - Get specific feedback\n- `POST /api/feedback` - Create feedback\n  ```json\n  {\n    \"issue_id\": \"ISSUE-001\",\n    \"spec_id\": \"SPEC-001\",\n    \"type\": \"comment\",\n    \"content\": \"Great spec!\",\n    \"anchor\": {\n      \"section_heading\": \"Overview\",\n      \"line_number\": 42,\n      \"text_snippet\": \"some text\",\n      \"anchor_status\": \"valid\"\n    }\n  }\n  ```\n- `PUT /api/feedback/:id` - Update feedback\n- `DELETE /api/feedback/:id` - Delete feedback\n\n## Feedback Types\n- `comment` - General comment\n- `suggestion` - Suggestion for improvement\n- `request` - Request for clarification\n\n## Feedback Anchor\n```typescript\ninterface FeedbackAnchor {\n  section_heading?: string\n  line_number?: number\n  text_snippet?: string\n  anchor_status: 'valid' | 'relocated' | 'stale'\n}\n```\n\n## Verification\n```bash\n# Get feedback for spec\ncurl http://localhost:3002/api/feedback?spec_id=SPEC-001\n\n# Create feedback\ncurl -X POST http://localhost:3002/api/feedback \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"issue_id\": \"ISSUE-001\", \"spec_id\": \"SPEC-001\", \"type\": \"comment\", \"content\": \"Nice work!\", \"anchor\": {\"line_number\": 10, \"anchor_status\": \"valid\"}}'\n\n# Update feedback\ncurl -X PUT http://localhost:3002/api/feedback/fb-123 \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"content\": \"Updated comment\"}'\n\n# Delete feedback\ncurl -X DELETE http://localhost:3002/api/feedback/fb-123\n\n# Run tests\nnpm test\n```\n\n## Success Criteria\nFeedback management API with anchor support, CLI delegation, and full test coverage.\n\nReference: [[server/server_plan.md]] - Phase 5, Step 5.2","content":"","status":"closed","priority":0,"assignee":null,"created_at":"2025-10-24 18:17:04","updated_at":"2025-10-24 18:36:33","closed_at":"2025-10-24 18:36:33","parent_id":null,"relationships":[],"tags":[]}
{"id":"ISSUE-011","uuid":"0022dc0e-75e9-4e4b-842f-65cafcd74217","title":"Server: File Watcher Setup","description":"Watch JSONL files for external changes and trigger database sync.\n\n## Tasks\n- [ ] Create `src/services/watcher.ts` for file watching\n- [ ] Use `chokidar` to watch issues.jsonl and specs.jsonl\n- [ ] Debounce file change events (avoid multiple rapid syncs)\n- [ ] Trigger database sync on file change\n- [ ] Handle file rename/delete events\n- [ ] Add watcher to server startup\n\n## Implementation Details\n\nUse chokidar to watch for file system changes:\n```typescript\nimport chokidar from 'chokidar'\n\nexport function startFileWatcher(jsonlPath: string) {\n  const watcher = chokidar.watch([\n    `${jsonlPath}/issues.jsonl`,\n    `${jsonlPath}/specs.jsonl`,\n  ], {\n    persistent: true,\n    ignoreInitial: true,\n  })\n\n  watcher.on('change', debounce((path) => {\n    console.log(`File changed: ${path}`)\n    if (path.includes('issues.jsonl')) {\n      syncIssuesToDb(path)\n      broadcastIssueUpdate()\n    } else if (path.includes('specs.jsonl')) {\n      syncSpecsToDb(path)\n      broadcastSpecUpdate()\n    }\n  }, 1000))\n}\n```\n\n## Verification\n```bash\n# Start server\nnpm run dev\n\n# Manually edit .sudocode/issues.jsonl\n# Server logs should show \"File changed: issues.jsonl\"\n# Database should be re-synced\n```\n\n## Dependencies\n- chokidar package\n- Existing sync functions from CLI\n\n## Success Criteria\nAutomatic database sync when JSONL files change externally.\n\nReference: [[server/server_plan.md]] - Phase 6, Step 6.1","content":"","status":"open","priority":1,"assignee":null,"created_at":"2025-10-24 18:41:25","updated_at":"2025-10-25 00:10:38","closed_at":null,"parent_id":null,"relationships":[],"tags":[]}
{"id":"ISSUE-012","uuid":"803e1739-35ba-4bd6-924a-b70f34d10cf4","title":"Server: WebSocket Server Setup","description":"Set up WebSocket server for real-time client updates.\n\n## Tasks\n- [ ] Create `src/services/websocket.ts` for WebSocket management\n- [ ] Initialize WebSocket server with `ws` library\n- [ ] Handle client connections and disconnections\n- [ ] Implement connection management (track clients)\n- [ ] Add heartbeat/ping-pong to detect dead connections\n- [ ] Implement subscription system (clients subscribe to projects/entities)\n- [ ] Integrate with Express server\n\n## Implementation Details\n\nWebSocket server setup:\n```typescript\nimport { WebSocketServer, WebSocket } from 'ws'\n\ninterface Client {\n  id: string\n  ws: WebSocket\n  subscriptions: string[]  // e.g., ['project:uuid', 'issue:ISSUE-001']\n}\n\nconst clients = new Map<string, Client>()\n\nexport function initWebSocketServer(server: http.Server) {\n  const wss = new WebSocketServer({ server, path: '/ws' })\n\n  wss.on('connection', (ws, req) => {\n    const clientId = generateId()\n    clients.set(clientId, { id: clientId, ws, subscriptions: [] })\n\n    ws.on('message', (data) => {\n      const message = JSON.parse(data.toString())\n      handleClientMessage(clientId, message)\n    })\n\n    ws.on('close', () => {\n      clients.delete(clientId)\n    })\n\n    // Heartbeat\n    ws.on('pong', () => {\n      client.isAlive = true\n    })\n  })\n\n  // Check for dead connections every 30s\n  setInterval(() => {\n    clients.forEach((client) => {\n      if (!client.isAlive) {\n        client.ws.terminate()\n        clients.delete(client.id)\n        return\n      }\n      client.isAlive = false\n      client.ws.ping()\n    })\n  }, 30000)\n}\n```\n\n## Message Protocol\n\nClient -> Server:\n```json\n{\n  \"type\": \"subscribe\",\n  \"entity_type\": \"issue\",\n  \"entity_id\": \"ISSUE-001\"\n}\n```\n\nServer -> Client:\n```json\n{\n  \"type\": \"issue_updated\",\n  \"data\": { \"id\": \"ISSUE-001\", ... }\n}\n```\n\n## Verification\n```bash\n# Use wscat to test\nnpm install -g wscat\nwscat -c ws://localhost:3002/ws\n# Should connect successfully\n> {\"type\": \"ping\"}\n# Should receive pong\n```\n\n## Dependencies\n- ws package\n- uuid for client IDs\n\n## Success Criteria\nWebSocket server accepting and managing client connections with heartbeat.\n\nReference: [[server/server_plan.md]] - Phase 6, Step 6.2","content":"","status":"closed","priority":1,"assignee":null,"created_at":"2025-10-24 18:41:26","updated_at":"2025-10-24 21:47:26","closed_at":"2025-10-24 21:47:26","parent_id":null,"relationships":[],"tags":[]}
{"id":"ISSUE-013","uuid":"7089f51c-758f-44fd-8183-a886b4876b7f","title":"Server: Real-Time Issue Updates","description":"Broadcast issue changes to connected WebSocket clients in real-time.\n\n## Tasks\n- [ ] Implement issue update broadcasting in `src/services/websocket.ts`\n- [ ] Broadcast updates on issue CRUD operations\n- [ ] Broadcast updates when file watcher detects changes\n- [ ] Add filtering (only send to subscribed clients)\n- [ ] Support subscription to specific issues or all issues\n- [ ] Handle different update types (created/updated/deleted)\n\n## Implementation Details\n\nBroadcasting logic:\n```typescript\nexport function broadcastIssueUpdate(\n  issue: Issue,\n  type: 'created' | 'updated' | 'deleted'\n) {\n  const message = {\n    type: `issue_${type}`,\n    data: issue,\n    timestamp: new Date().toISOString(),\n  }\n\n  clients.forEach((client) => {\n    const subscribed = client.subscriptions.some(sub => \n      sub === 'issues:all' || \n      sub === `issue:${issue.id}` ||\n      (issue.project_id && sub === `project:${issue.project_id}`)\n    )\n    \n    if (subscribed) {\n      client.ws.send(JSON.stringify(message))\n    }\n  })\n}\n```\n\nIntegration points:\n1. Call from routes after CRUD operations\n2. Call from file watcher on external changes\n3. Support filtering by project_id\n\n## Message Types\n\n- `issue_created` - New issue created\n- `issue_updated` - Issue modified\n- `issue_deleted` - Issue removed\n\n## Verification\n```bash\n# Connect with wscat\nwscat -c ws://localhost:3002/ws\n> {\"type\": \"subscribe\", \"entity_type\": \"issues\"}\n\n# In another terminal, create an issue\ncurl -X POST http://localhost:3002/api/issues -d '{\"title\": \"Test\"}'\n\n# wscat should receive update message\n< {\"type\": \"issue_created\", \"data\": {...}}\n```\n\n## Integration\n- Modify `src/routes/issues.ts` to call broadcast functions\n- Connect with file watcher from ISSUE-011\n\n## Success Criteria\nConnected clients receive real-time updates when issues change.\n\nReference: [[server/server_plan.md]] - Phase 6, Step 6.3","content":"","status":"closed","priority":1,"assignee":null,"created_at":"2025-10-24 18:41:26","updated_at":"2025-10-24 22:13:03","closed_at":"2025-10-24 22:13:03","parent_id":null,"relationships":[],"tags":[]}
{"id":"ISSUE-014","uuid":"916d44ca-42fa-4af9-a2a3-3aea6499ec9b","title":"Server: Real-Time Spec Updates","description":"Broadcast spec changes to connected WebSocket clients in real-time.\n\n## Tasks\n- [ ] Implement spec update broadcasting in `src/services/websocket.ts`\n- [ ] Broadcast updates on spec CRUD operations\n- [ ] Broadcast updates when file watcher detects changes\n- [ ] Add filtering (only send to subscribed clients)\n- [ ] Support subscription to specific specs or all specs\n- [ ] Handle different update types (created/updated/deleted)\n\n## Implementation Details\n\nBroadcasting logic:\n```typescript\nexport function broadcastSpecUpdate(\n  spec: Spec,\n  type: 'created' | 'updated' | 'deleted'\n) {\n  const message = {\n    type: `spec_${type}`,\n    data: spec,\n    timestamp: new Date().toISOString(),\n  }\n\n  clients.forEach((client) => {\n    const subscribed = client.subscriptions.some(sub => \n      sub === 'specs:all' || \n      sub === `spec:${spec.id}` ||\n      (spec.project_id && sub === `project:${spec.project_id}`)\n    )\n    \n    if (subscribed) {\n      client.ws.send(JSON.stringify(message))\n    }\n  })\n}\n```\n\nIntegration points:\n1. Call from routes after CRUD operations\n2. Call from file watcher on external changes\n3. Support filtering by project_id\n\n## Message Types\n\n- `spec_created` - New spec created\n- `spec_updated` - Spec modified\n- `spec_deleted` - Spec removed\n\n## Verification\n```bash\n# Connect with wscat\nwscat -c ws://localhost:3002/ws\n> {\"type\": \"subscribe\", \"entity_type\": \"specs\"}\n\n# In another terminal, create a spec\ncurl -X POST http://localhost:3002/api/specs -d '{\"title\": \"Test Spec\"}'\n\n# wscat should receive update message\n< {\"type\": \"spec_created\", \"data\": {...}}\n```\n\n## Integration\n- Modify `src/routes/specs.ts` to call broadcast functions\n- Connect with file watcher from ISSUE-011\n- Consider broadcasting relationship and feedback updates\n\n## Success Criteria\nConnected clients receive real-time updates when specs change.\n\nReference: [[server/server_plan.md]] - Phase 6, Step 6.4","content":"","status":"closed","priority":1,"assignee":null,"created_at":"2025-10-24 18:41:27","updated_at":"2025-10-24 22:49:06","closed_at":"2025-10-24 22:49:06","parent_id":null,"relationships":[],"tags":[]}
{"id":"ISSUE-015","uuid":"0483ddd8-d2ff-4d22-8f5a-4d4ddbbfc925","title":"Import should preserve timestamps from JSONL","description":"When importing from JSONL, updateIssue/updateSpec always generate new updated_at timestamps. This causes JSONL files to be modified even when content hasn't changed, breaking the bidirectional sync content-matching optimization.","content":"","status":"closed","priority":1,"assignee":null,"created_at":"2025-10-24 21:16:59","updated_at":"2025-10-24 21:35:58","closed_at":"2025-10-24 21:35:58","parent_id":null,"relationships":[],"tags":[]}
{"id":"ISSUE-016","uuid":"e0dc4e55-aa7b-4666-b41a-510a8a5541b0","title":"Frontend Setup: Create workspace and configure build tools","description":"Set up the frontend workspace with Vite, React, and TypeScript, following the architecture outlined in [[server/ui.md]].\n\n## Tasks\n- [ ] Create `frontend/` directory in monorepo root\n- [ ] Initialize package.json with dependencies from ui.md\n- [ ] Configure Vite with React plugin and path aliases\n- [ ] Set up TypeScript with strict mode\n- [ ] Configure Tailwind CSS + PostCSS\n- [ ] Add shadcn/ui components configuration\n- [ ] Update root package.json to include frontend workspace\n- [ ] Add build and dev scripts\n\n## Dependencies\nCore:\n- React 18.2, React DOM\n- TypeScript 5.5+\n- Vite 5\n\nUI/Styling:\n- Tailwind CSS 3.4\n- shadcn/ui components (Radix UI primitives)\n- Lucide React icons\n\nSee server/ui.md lines 210-292 for complete dependency list.\n\n## Acceptance Criteria\n- `npm run dev --workspace=frontend` starts Vite dev server on port 3000\n- TypeScript compiles without errors\n- Tailwind CSS is working\n- Hot module replacement is functional","content":"","status":"closed","priority":0,"assignee":null,"created_at":"2025-10-24 22:00:42","updated_at":"2025-10-24 22:07:34","closed_at":"2025-10-24 22:07:34","parent_id":null,"relationships":[{"from":"ISSUE-016","from_type":"issue","to":"ISSUE-019","to_type":"issue","type":"blocks"},{"from":"ISSUE-016","from_type":"issue","to":"ISSUE-020","to_type":"issue","type":"blocks"}],"tags":["frontend","infrastructure","setup"]}
{"id":"ISSUE-017","uuid":"f91867e7-b587-432b-899a-07a72bf525cd","title":"Server: Add static file serving for production frontend","description":"Update Express server to serve built frontend assets in production mode, following the pattern in [[server/ui.md]].\n\n## Tasks\n- [ ] Add static file serving middleware for frontend/dist\n- [ ] Add SPA fallback route to serve index.html for non-API routes\n- [ ] Ensure API routes are registered before static serving\n- [ ] Add production check (NODE_ENV === 'production')\n- [ ] Resolve port configuration (currently 3002, ui.md references 3001)\n- [ ] Document production build process\n\n## Implementation\n```typescript\n// server/src/index.ts (after API routes)\nif (process.env.NODE_ENV === 'production') {\n  const frontendPath = path.join(__dirname, '../../frontend/dist');\n  app.use(express.static(frontendPath));\n  \n  app.get('*', (req, res) => {\n    res.sendFile(path.join(frontendPath, 'index.html'));\n  });\n}\n```\n\n## Acceptance Criteria\n- Built frontend is served at http://localhost:3002/\n- API routes still work at http://localhost:3002/api/*\n- WebSocket endpoint still works at ws://localhost:3002/ws\n- SPA routing works (refresh on /projects, /issues, etc.)","content":"","status":"closed","priority":0,"assignee":null,"created_at":"2025-10-24 22:00:42","updated_at":"2025-10-24 22:22:36","closed_at":"2025-10-24 22:22:36","parent_id":null,"relationships":[],"tags":["infrastructure","production","server"]}
{"id":"ISSUE-018","uuid":"79a69058-fa37-4b1a-bec5-533fb55892e6","title":"Frontend: Implement API client and WebSocket infrastructure","description":"Build the core API client layer with axios and WebSocket support, as designed in [[server/ui.md]] lines 470-670.\n\n## Tasks\n- [ ] Create `lib/api.ts` with axios instance and interceptors\n- [ ] Implement response unwrapping for ApiResponse wrapper\n- [ ] Create API modules: issuesApi, specsApi, relationshipsApi, feedbackApi\n- [ ] Create `lib/websocket.ts` with useWebSocket hook\n- [ ] Add environment variable support (VITE_API_URL, VITE_WS_URL)\n- [ ] Add error handling and logging\n- [ ] Create TypeScript types in `types/api.ts`\n\n## API Structure\n```typescript\nexport const issuesApi = {\n  getAll: (projectId?: string) => get<Issue[]>('/issues'),\n  getById: (id: string) => get<Issue>(\\`/issues/\\${id}\\`),\n  create: (data: CreateIssueRequest) => post<Issue>('/issues', data),\n  update: (id: string, data: UpdateIssueRequest) => put<Issue>(\\`/issues/\\${id}\\`, data),\n  delete: (id: string) => del(\\`/issues/\\${id}\\`)\n}\n```\n\n## Acceptance Criteria\n- API client successfully connects to server\n- Response unwrapping works correctly\n- WebSocket connection establishes and receives messages\n- Type safety for all API calls\n- Error handling with user-friendly messages","content":"","status":"closed","priority":1,"assignee":null,"created_at":"2025-10-24 22:00:42","updated_at":"2025-10-24 22:47:32","closed_at":"2025-10-24 22:47:32","parent_id":null,"relationships":[{"from":"ISSUE-018","from_type":"issue","to":"ISSUE-023","to_type":"issue","type":"blocks"}],"tags":["api","frontend","infrastructure"]}
{"id":"ISSUE-019","uuid":"9947c91e-e3fb-4d94-9ad4-e0cde902b59a","title":"Frontend: Set up routing and application shell","description":"Implement React Router structure, providers, and main application layout per [[server/ui.md]] lines 747-788.\n\n## Tasks\n- [ ] Create `App.tsx` with QueryClientProvider, ThemeProvider, BrowserRouter\n- [ ] Set up React Router routes structure\n- [ ] Create page components: ProjectsPage, IssuesPage, SpecsPage\n- [ ] Create MainLayout component with outlet\n- [ ] Implement ProjectContext for current project state\n- [ ] Implement ThemeContext for dark/light mode\n- [ ] Configure TanStack Query with default options\n- [ ] Add route-based code splitting\n\n## Route Structure\n```\n/ → redirect to /projects\n/projects → Project list\n/projects/:id/issues → Issue kanban board\n/projects/:id/specs → Spec list\n/projects/:id/specs/:specId → Spec detail view\n/settings/* → Settings pages\n```\n\n## Acceptance Criteria\n- All routes render without errors\n- Navigation between routes works\n- QueryClient is configured with proper caching\n- Context providers accessible throughout app\n- Theme switching works (if implemented)","content":"","status":"closed","priority":1,"assignee":null,"created_at":"2025-10-24 22:00:42","updated_at":"2025-10-24 23:06:42","closed_at":"2025-10-24 23:06:42","parent_id":null,"relationships":[],"tags":["frontend","infrastructure","routing"]}
{"id":"ISSUE-020","uuid":"20b4d501-8102-4261-996c-9af16d30ea5e","title":"Frontend: Build core layout components","description":"Implement the main layout structure with header, sidebar, and responsive containers following [[server/ui.md]] component architecture.\n\n## Tasks\n- [ ] Create `components/layout/MainLayout.tsx` - Main wrapper with outlets\n- [ ] Create `components/layout/Header.tsx` - Top navigation bar\n- [ ] Create `components/layout/Sidebar.tsx` - Left navigation sidebar\n- [ ] Create `components/layout/PanelLayout.tsx` - Slide-out panel system\n- [ ] Add Lucide React icons for navigation\n- [ ] Implement responsive breakpoints\n- [ ] Add keyboard navigation support\n- [ ] Style with Tailwind utilities\n\n## Features\n- Header: Logo, project selector, search, settings\n- Sidebar: Navigation links (Issues, Specs, Settings)\n- Panel system: Reusable slide-out panels for details\n- Responsive: Mobile-friendly collapsible sidebar\n\n## Acceptance Criteria\n- Layout renders correctly on desktop and mobile\n- Sidebar can be toggled open/closed\n- Navigation links highlight active route\n- Panel system can open/close smoothly\n- Accessible keyboard navigation","content":"","status":"closed","priority":1,"assignee":null,"created_at":"2025-10-24 22:00:42","updated_at":"2025-10-24 23:18:08","closed_at":"2025-10-24 23:18:08","parent_id":null,"relationships":[],"tags":["components","frontend","layout"]}
{"id":"ISSUE-021","uuid":"b71ce905-f767-4ccf-9f88-3eb6612a7bd9","title":"Frontend: Implement issue kanban board (MVP)","description":"Build the core kanban board for issues with drag-and-drop, following the example in [[server/ui.md]] lines 675-743.\n\n## Tasks\n- [ ] Install @dnd-kit/core, @dnd-kit/sortable\n- [ ] Create `components/ui/kanban/` primitives (Board, Column, Card)\n- [ ] Create `components/issues/IssueKanbanBoard.tsx` - Main board\n- [ ] Create `components/issues/IssueCard.tsx` - Individual issue card\n- [ ] Create `components/issues/IssuePanel.tsx` - Detail slide-out panel\n- [ ] Implement useIssues hook with TanStack Query\n- [ ] Add WebSocket live updates for issue changes\n- [ ] Add drag-and-drop to change status\n- [ ] Style cards with priority badges and status indicators\n\n## Kanban Columns\n- Open → In Progress → Blocked → Closed\n\n## Acceptance Criteria\n- Issues load and display in correct columns\n- Drag-and-drop updates issue status via API\n- WebSocket updates reflect changes from other clients\n- Issue card shows: title, ID, priority, description preview\n- Click card opens detail panel\n- Optimistic updates with error handling","content":"","status":"closed","priority":2,"assignee":null,"created_at":"2025-10-24 22:00:43","updated_at":"2025-10-24 23:56:58","closed_at":"2025-10-24 23:56:58","parent_id":null,"relationships":[{"from":"ISSUE-021","from_type":"issue","to":"ISSUE-022","to_type":"issue","type":"blocks"}],"tags":["frontend","issues","kanban","mvp"]}
{"id":"ISSUE-022","uuid":"1b1aa9c7-5984-4b46-9d9f-ae46dfde265f","title":"Frontend: Implement issue CRUD operations and forms","description":"Build issue creation, editing, and deletion UI with form validation.\n\n## Tasks\n- [ ] Create `components/issues/IssueEditor.tsx` - Create/edit form\n- [ ] Add markdown editor support (react-markdown or Lexical)\n- [ ] Implement issue creation dialog\n- [ ] Implement issue edit mode in panel\n- [ ] Add delete confirmation dialog\n- [ ] Implement priority selector (0-4)\n- [ ] Implement status selector\n- [ ] Add form validation\n- [ ] Connect to issuesApi mutations\n\n## Form Fields\n- Title (required)\n- Description (markdown)\n- Status (open/in_progress/blocked/closed)\n- Priority (0=highest to 4=lowest)\n- Tags (optional)\n- Parent issue (optional for relationships)\n\n## Acceptance Criteria\n- Can create new issues from kanban board\n- Can edit existing issues from detail panel\n- Can delete issues with confirmation\n- Form validates required fields\n- Markdown preview works\n- Mutations update QueryClient cache","content":"","status":"closed","priority":2,"assignee":null,"created_at":"2025-10-24 22:00:43","updated_at":"2025-10-25 00:20:17","closed_at":"2025-10-25 00:20:17","parent_id":null,"relationships":[],"tags":["forms","frontend","issues","mvp"]}
{"id":"ISSUE-023","uuid":"a5d5d0ea-f3b9-49ee-b0b6-8c355c835e0a","title":"Frontend: Implement specs list and viewer","description":"Build the specs page with list view and markdown viewer, following [[server/ui.md]] spec component architecture.\n\n## Tasks\n- [ ] Create `pages/specs.tsx` - Spec list page\n- [ ] Create `pages/spec-detail.tsx` - Individual spec viewer\n- [ ] Create `components/specs/SpecList.tsx` - Grid/list of specs\n- [ ] Create `components/specs/SpecCard.tsx` - Spec preview card\n- [ ] Create `components/specs/SpecViewer.tsx` - Markdown viewer with line numbers\n- [ ] Create `components/specs/SpecEditor.tsx` - Create/edit form\n- [ ] Implement useSpecs hook\n- [ ] Add markdown rendering with syntax highlighting\n- [ ] Add line anchors for feedback system (future)\n\n## Spec Display\n- List view: Title, description preview, tags, created date\n- Detail view: Full markdown with line numbers for anchoring\n- Create/Edit: Markdown editor with preview\n\n## Acceptance Criteria\n- Specs load and display in list\n- Can navigate to spec detail view\n- Markdown renders correctly with syntax highlighting\n- Line numbers displayed for feedback anchoring\n- Can create and edit specs\n- WebSocket updates reflect changes","content":"","status":"closed","priority":3,"assignee":null,"created_at":"2025-10-24 22:00:43","updated_at":"2025-10-25 01:05:16","closed_at":"2025-10-25 01:05:16","parent_id":null,"relationships":[{"from":"ISSUE-023","from_type":"issue","to":"ISSUE-024","to_type":"issue","type":"blocks"}],"tags":["frontend","phase-2","specs"]}
{"id":"ISSUE-024","uuid":"feea9e38-7b61-4906-ab17-cbe2a7efb8f6","title":"Frontend: Implement feedback anchoring UI","description":"Build the feedback system for anchoring comments to spec lines, as designed in [[server/ui.md]].\n\n## Tasks\n- [ ] Create `components/specs/SpecFeedbackPanel.tsx` - Feedback sidebar\n- [ ] Create `components/specs/FeedbackAnchor.tsx` - Visual anchor on lines\n- [ ] Create `components/specs/FeedbackCard.tsx` - Individual feedback item\n- [ ] Create `components/specs/FeedbackForm.tsx` - Add feedback form\n- [ ] Implement useFeedback hook\n- [ ] Add click-to-anchor interaction on spec lines\n- [ ] Add line/text-based anchoring logic\n- [ ] Connect to feedbackApi\n- [ ] Add feedback type badges (comment/suggestion/request)\n\n## Feedback Features\n- Click spec line to add feedback\n- Feedback anchored by line number or text snippet\n- Visual indicators on lines with feedback\n- Sidebar shows all feedback for spec\n- Link feedback to issues\n\n## Acceptance Criteria\n- Can click line to add feedback\n- Feedback displays with correct anchor\n- Visual indicators show lines with feedback\n- Can view and navigate all feedback for a spec\n- Can link feedback to issues\n- Feedback persists across page reloads","content":"","status":"open","priority":3,"assignee":null,"created_at":"2025-10-24 22:00:43","updated_at":"2025-10-24 22:00:43","closed_at":null,"parent_id":null,"relationships":[{"from":"ISSUE-024","from_type":"issue","to":"ISSUE-025","to_type":"issue","type":"blocks"}],"tags":["feedback","frontend","phase-2","specs"]}
{"id":"ISSUE-025","uuid":"c6ca5565-9ac7-4608-8b8d-9618eaccb164","title":"Frontend: Implement relationship visualization","description":"Build UI for viewing and creating relationships between specs and issues.\n\n## Tasks\n- [ ] Create `components/relationships/RelationshipGraph.tsx` - Visual graph\n- [ ] Create `components/relationships/RelationshipList.tsx` - List view\n- [ ] Create `components/relationships/RelationshipForm.tsx` - Create link\n- [ ] Create `components/panels/RelationshipPanel.tsx` - Side panel\n- [ ] Implement useRelationships hook\n- [ ] Add relationship type badges (blocks, implements, references, etc.)\n- [ ] Add graph visualization library (consider D3, Cytoscape, or similar)\n- [ ] Connect to relationshipsApi\n\n## Relationship Types\n- blocks\n- implements\n- references\n- depends-on\n- discovered-from\n- related\n\n## Acceptance Criteria\n- Can view relationships for issue/spec\n- Graph visualization shows connected entities\n- Can create new relationships between entities\n- Relationship types clearly indicated\n- Can navigate to related entities\n- List view shows all relationships","content":"","status":"open","priority":4,"assignee":null,"created_at":"2025-10-24 22:00:43","updated_at":"2025-10-24 22:00:43","closed_at":null,"parent_id":null,"relationships":[],"tags":["frontend","phase-2","relationships"]}
{"id":"ISSUE-026","uuid":"b03a982b-d66c-4561-bd89-1f5311c5eea4","title":"Frontend: Add dark mode support","description":"Implement dark/light theme switching with system preference detection.\n\n## Tasks\n- [ ] Set up CSS variables for theme colors\n- [ ] Configure Tailwind dark mode (class strategy)\n- [ ] Implement ThemeContext with localStorage persistence\n- [ ] Add theme toggle component in header\n- [ ] Add system preference detection\n- [ ] Update all components to support dark mode\n- [ ] Test contrast and accessibility\n- [ ] Add smooth transitions between themes\n\n## Theme Colors (from ui.md)\n- Define HSL color variables for light/dark\n- Use Tailwind's dark: prefix for dark mode styles\n- shadcn/ui components support dark mode by default\n\n## Acceptance Criteria\n- Theme toggle button switches themes instantly\n- Theme preference persists in localStorage\n- Respects system preference on first visit\n- All components render correctly in both themes\n- Smooth transition animation between themes\n- Accessible contrast ratios in both modes","content":"","status":"open","priority":4,"assignee":null,"created_at":"2025-10-24 22:00:44","updated_at":"2025-10-24 22:00:44","closed_at":null,"parent_id":null,"relationships":[],"tags":["accessibility","frontend","polish","ui"]}
{"id":"ISSUE-027","uuid":"ab6f0cc6-86f7-410c-8a6f-b60c4c73835b","title":"Real-time Test Issue","description":"Testing WebSocket broadcast","content":"","status":"open","priority":2,"assignee":null,"created_at":"2025-10-24 22:11:41","updated_at":"2025-10-24 22:11:41","closed_at":null,"parent_id":null,"relationships":[],"tags":[]}
