{"id":"SPEC-001","uuid":"37d447c6-5f01-435d-b7e8-99d689e597f8","title":"Agent Execution System","file_path":"specs/agent_execution_system.md","content":"# Agent Execution System\n\n## Overview\n\nA flexible system for running different coding agents on issues and tracking their execution trajectories. Designed for sudocode's TypeScript/Node.js stack.\n\n## Architecture\n\n### Three-Layer Execution Model\n\n```\nIssue → Execution → Trajectory Entries\n  ↓         ↓            ↓\nTask      Process    Log Events\n```\n\n**1\\. Issue** (existing)\n\n- Already implemented in sudocode\n- Represents a task to be completed\n\n**2\\. Execution** (new)\n\n- Represents a single agent run on an issue\n- Tracks: agent type, status, git context, session info\n- Multiple executions can exist per issue (retries, different agents)\n\n**3\\. Trajectory Entry** (new)\n\n- Individual events/actions during execution\n- Tool uses, thinking, messages, file changes\n- Enables playback and analysis of agent behavior\n\n### Supported Agents\n\nPhase 1: **Claude Code** (via `@anthropic-ai/claude-code`) Phase 2: **Codex** (via `@phasehq/codex`) Future: Aider, Cursor, custom agents\n\n## Data Models\n\n### Execution\n\n```typescript\ninterface Execution {\n  id: string;                    // UUID\n  issueId: string;               // Foreign key to issues\n  agentType: AgentType;          // Which agent ran\n  status: ExecutionStatus;       // Current state\n  \n  // Timestamps\n  startedAt: Date;\n  completedAt?: Date;\n  \n  // Process info\n  exitCode?: number;\n  \n  // Git context (captured before/after)\n  beforeCommit?: string;         // Git SHA before execution\n  afterCommit?: string;          // Git SHA after execution\n  \n  // Session tracking (for resume/fork)\n  sessionId?: string;            // External session ID from agent\n  prompt?: string;               // Initial prompt sent\n  summary?: string;              // Final agent summary\n  \n  // Metadata\n  createdAt: Date;\n  updatedAt: Date;\n}\n\ntype AgentType = 'claude-code' | 'codex';\n\ntype ExecutionStatus = \n  | 'running'\n  | 'completed' \n  | 'failed'\n  | 'stopped';\n```\n\n### Trajectory Entry\n\n```typescript\ninterface TrajectoryEntry {\n  id: number;                    // Auto-increment\n  executionId: string;           // Foreign key to executions\n  index: number;                 // Sequential order within execution\n  timestamp: Date;\n  \n  // Entry type and data (polymorphic)\n  type: EntryType;\n  content: string;               // Display text\n  metadata?: Record<string, any>; // Type-specific data\n}\n\ntype EntryType = \n  | 'tool_use'        // Agent used a tool\n  | 'thinking'        // Agent reasoning/planning\n  | 'assistant_msg'   // Agent message to user\n  | 'user_msg'        // User message to agent\n  | 'user_feedback'   // User approval/denial\n  | 'system_msg'      // System notifications\n  | 'error_msg';      // Errors\n\n// Tool use metadata\ninterface ToolUseMetadata {\n  toolName: string;\n  action: ActionType;\n  status: 'created' | 'running' | 'success' | 'failed';\n}\n\ntype ActionType =\n  | { type: 'file_read', path: string }\n  | { type: 'file_edit', path: string, changes: FileChange[] }\n  | { type: 'file_write', path: string, content: string }\n  | { type: 'command_run', command: string, result?: CommandResult }\n  | { type: 'search', query: string }\n  | { type: 'web_fetch', url: string }\n  | { type: 'task_create', description: string }\n  | { type: 'tool', toolName: string, args: any, result?: any };\n\ninterface FileChange {\n  type: 'edit' | 'write';\n  unifiedDiff?: string;          // For edits\n  content?: string;              // For writes\n  hasLineNumbers: boolean;\n}\n\ninterface CommandResult {\n  exitStatus: { code: number } | { success: boolean };\n  output: string;\n}\n```\n\n## Agent Abstraction\n\n### CodingAgent Interface\n\n```typescript\ninterface CodingAgent {\n  // Spawn initial execution\n  spawn(\n    workDir: string, \n    prompt: string\n  ): Promise<SpawnedProcess>;\n  \n  // Spawn follow-up (resume/fork)\n  spawnFollowUp(\n    workDir: string,\n    prompt: string, \n    sessionId: string\n  ): Promise<SpawnedProcess>;\n  \n  // Normalize agent-specific logs to TrajectoryEntry\n  normalizeLogs(\n    rawLogs: AsyncIterable<string>\n  ): AsyncIterable<TrajectoryEntry>;\n  \n  // Capabilities\n  supportsSessionFork(): boolean;\n  supportsMCP(): boolean;\n  getDefaultMCPConfigPath(): string | null;\n}\n\ninterface SpawnedProcess {\n  process: ChildProcess;\n  exitSignal?: Promise<void>;  // Optional early exit signal\n}\n```\n\n### Claude Code Executor\n\n```typescript\nclass ClaudeCodeExecutor implements CodingAgent {\n  async spawn(workDir: string, prompt: string) {\n    const proc = spawn('npx', [\n      '-y', '@anthropic-ai/claude-code@latest',\n      '-p',\n      '--output-format=stream-json',\n      '--include-partial-messages',\n      '--verbose'\n    ], { \n      cwd: workDir,\n      stdio: ['pipe', 'pipe', 'pipe']\n    });\n    \n    proc.stdin.write(prompt);\n    proc.stdin.end();\n    \n    return { process: proc };\n  }\n  \n  async spawnFollowUp(workDir: string, prompt: string, sessionId: string) {\n    const proc = spawn('npx', [\n      '-y', '@anthropic-ai/claude-code@latest',\n      '-p',\n      '--output-format=stream-json',\n      '--include-partial-messages',\n      '--verbose',\n      '--fork-session',\n      '--resume', sessionId\n    ], { cwd: workDir });\n    \n    proc.stdin.write(prompt);\n    proc.stdin.end();\n    \n    return { process: proc };\n  }\n  \n  async *normalizeLogs(rawLogs: AsyncIterable<string>) {\n    let buffer = '';\n    let sessionIdExtracted = false;\n    let entryIndex = 0;\n    \n    for await (const chunk of rawLogs) {\n      buffer += chunk;\n      \n      // Process complete JSON lines\n      const lines = buffer.split('\\n');\n      buffer = lines.pop() || '';\n      \n      for (const line of lines) {\n        const trimmed = line.trim();\n        if (!trimmed) continue;\n        \n        try {\n          const json = JSON.parse(trimmed);\n          \n          // Extract session ID\n          if (!sessionIdExtracted && json.session_id) {\n            sessionIdExtracted = true;\n            // Emit session ID separately for storage\n          }\n          \n          // Normalize to TrajectoryEntry\n          const entries = this.normalizeClaudeJson(json, entryIndex);\n          for (const entry of entries) {\n            yield entry;\n            entryIndex++;\n          }\n        } catch (e) {\n          // Non-JSON output - treat as system message\n          yield {\n            index: entryIndex++,\n            type: 'system_msg',\n            content: trimmed,\n            timestamp: new Date()\n          };\n        }\n      }\n    }\n  }\n  \n  private normalizeClaudeJson(json: any, startIndex: number): TrajectoryEntry[] {\n    // Parse Claude's JSON format into TrajectoryEntry[]\n    const entries: TrajectoryEntry[] = [];\n    \n    switch (json.type) {\n      case 'system':\n        if (json.subtype !== 'init') {\n          entries.push({\n            index: startIndex,\n            type: 'system_msg',\n            content: `System: ${json.subtype || 'message'}`,\n            timestamp: new Date(),\n            metadata: json\n          });\n        }\n        break;\n        \n      case 'assistant':\n        for (const item of json.message.content) {\n          if (item.type === 'text') {\n            entries.push({\n              index: startIndex + entries.length,\n              type: 'assistant_msg',\n              content: item.text,\n              timestamp: new Date(),\n              metadata: item\n            });\n          } else if (item.type === 'thinking') {\n            entries.push({\n              index: startIndex + entries.length,\n              type: 'thinking',\n              content: item.thinking,\n              timestamp: new Date(),\n              metadata: item\n            });\n          } else if (item.type === 'tool_use') {\n            entries.push({\n              index: startIndex + entries.length,\n              type: 'tool_use',\n              content: this.generateToolContent(item),\n              timestamp: new Date(),\n              metadata: {\n                toolName: item.name,\n                action: this.extractAction(item),\n                status: 'created'\n              }\n            });\n          }\n        }\n        break;\n        \n      case 'user':\n        // Handle tool results and user messages\n        break;\n    }\n    \n    return entries;\n  }\n  \n  supportsSessionFork() { return true; }\n  supportsMCP() { return true; }\n  getDefaultMCPConfigPath() { \n    return `${os.homedir()}/.claude.json`; \n  }\n}\n```\n\n### Codex Executor\n\n```typescript\nclass CodexExecutor implements CodingAgent {\n  async spawn(workDir: string, prompt: string) {\n    // Similar structure, but using Codex CLI\n    const proc = spawn('npx', [\n      '-y', '@phasehq/codex@latest',\n      // Codex-specific flags\n    ], { cwd: workDir });\n    \n    // Codex has different input format\n    proc.stdin.write(JSON.stringify({ prompt }));\n    proc.stdin.end();\n    \n    return { process: proc };\n  }\n  \n  async *normalizeLogs(rawLogs: AsyncIterable<string>) {\n    // Codex-specific log parsing\n    // Different format than Claude\n  }\n  \n  supportsSessionFork() { return true; }\n  supportsMCP() { return true; }\n}\n```\n\n## Database Schema\n\n### Executions Table\n\n[[ISSUE-028]]{ references }\n\n```sql\nCREATE TABLE executions (\n  id TEXT PRIMARY KEY,\n  issue_id TEXT NOT NULL REFERENCES issues(id) ON DELETE CASCADE,\n  agent_type TEXT NOT NULL,  -- 'claude-code' | 'codex' | etc\n  status TEXT NOT NULL,      -- 'running' | 'completed' | 'failed' | 'stopped'\n  \n  started_at INTEGER NOT NULL,\n  completed_at INTEGER,\n  exit_code INTEGER,\n  \n  before_commit TEXT,\n  after_commit TEXT,\n  \n  session_id TEXT,\n  prompt TEXT,\n  summary TEXT,\n  \n  created_at INTEGER NOT NULL DEFAULT (unixepoch()),\n  updated_at INTEGER NOT NULL DEFAULT (unixepoch())\n);\n\nCREATE INDEX idx_executions_issue_id ON executions(issue_id);\nCREATE INDEX idx_executions_status ON executions(status);\nCREATE INDEX idx_executions_session_id ON executions(session_id);\n```\n\n### Trajectory Entries Table\n\n```sql\nCREATE TABLE trajectory_entries (\n  id INTEGER PRIMARY KEY AUTOINCREMENT,\n  execution_id TEXT NOT NULL REFERENCES executions(id) ON DELETE CASCADE,\n  entry_index INTEGER NOT NULL,\n  timestamp INTEGER NOT NULL,\n  \n  type TEXT NOT NULL,  -- 'tool_use' | 'thinking' | 'assistant_msg' | etc\n  content TEXT NOT NULL,\n  metadata TEXT,       -- JSON blob\n  \n  created_at INTEGER NOT NULL DEFAULT (unixepoch())\n);\n\nCREATE INDEX idx_trajectory_entries_execution_id ON trajectory_entries(execution_id);\nCREATE INDEX idx_trajectory_entries_execution_index ON trajectory_entries(execution_id, entry_index);\n```\n\n## API Endpoints\n\n[[ISSUE-031]]{ references }\n\n### Start Execution\n\n```\nPOST /api/issues/:issueId/executions\n{\n  \"agentType\": \"claude-code\",\n  \"prompt\": \"Fix the authentication bug\"\n}\n\nResponse: { \"executionId\": \"exec-123\" }\n```\n\n### Get Execution Status\n\n```\nGET /api/executions/:executionId\n\nResponse: {\n  \"id\": \"exec-123\",\n  \"issueId\": \"issue-456\",\n  \"agentType\": \"claude-code\",\n  \"status\": \"running\",\n  \"startedAt\": \"2025-01-26T10:00:00Z\",\n  ...\n}\n```\n\n### Stream Trajectory (WebSocket)\n\n```\nWS /api/executions/:executionId/trajectory\n\nMessages:\n{\n  \"type\": \"entry\",\n  \"data\": {\n    \"index\": 5,\n    \"type\": \"tool_use\",\n    \"content\": \"`src/auth.ts`\",\n    \"timestamp\": \"2025-01-26T10:01:23Z\",\n    \"metadata\": { ... }\n  }\n}\n\n{\n  \"type\": \"session_id\",\n  \"data\": { \"sessionId\": \"claude-session-abc\" }\n}\n\n{\n  \"type\": \"finished\",\n  \"data\": { \"exitCode\": 0 }\n}\n```\n\n### Stop Execution\n\n```\nPOST /api/executions/:executionId/stop\n\nResponse: { \"status\": \"stopped\" }\n```\n\n### List Executions for Issue\n\n```\nGET /api/issues/:issueId/executions\n\nResponse: {\n  \"executions\": [\n    { \"id\": \"exec-123\", ... },\n    { \"id\": \"exec-124\", ... }\n  ]\n}\n```\n\n## Implementation Phases\n\n### Phase 1: Core Execution (MVP)\n\n[[ISSUE-029]]{ references }**Goal**: Basic process spawning and log storage\n\n**Issues**:\n\n- [[ISSUE-028]] - Database schema and TypeScript types for executions\n- [[ISSUE-029]] - Implement ExecutionManager class for process lifecycle management\n- [[ISSUE-030]] - Implement basic Claude Code process spawning\n- [[ISSUE-031]] - API endpoints for execution management\n- [[ISSUE-032]] - Raw log storage in temp files\n- [[ISSUE-033]] - Integration test for Phase 1 MVP\n\n**Deliverable**: Can start Claude Code on an issue, track if it's running, and know when it finishes.\n\n### Phase 2: Trajectory Normalization\n\n**Goal**: Parse and store structured logs\n\n- Add trajectory\\_entries table\n- ClaudeCodeExecutor with normalization\n- Parse Claude JSON format → TrajectoryEntry\n- Store entries in database\n- API endpoint: get trajectory entries\n\n**Deliverable**: Can view what Claude did step-by-step (tools used, files edited, etc.)\n\n### Phase 3: Real-Time Streaming\n\n**Goal**: Live updates in UI\n\n- WebSocket endpoint for live trajectory\n- Frontend TrajectoryViewer component\n- Display tool uses, thinking, messages\n- Auto-scroll and updates\n\n**Deliverable**: Watch agent execution in real-time\n\n### Phase 4: Session Management\n\n**Goal**: Resume and fork executions\n\n- Extract session IDs during execution\n- Store session\\_id in executions table\n- Implement spawnFollowUp\n- API endpoint: resume execution\n- UI: \"Continue\" button on executions\n\n**Deliverable**: Can send follow-up prompts to same session\n\n### Phase 5: Multiple Agents\n\n**Goal**: Support Codex and others\n\n- CodingAgent abstraction\n- CodexExecutor implementation\n- Agent selection in UI\n- Agent-specific config (MCP, etc.)\n\n**Deliverable**: Can choose between Claude Code and Codex\n\n### Phase 6: Advanced Features\n\n**Goal**: Production-ready\n\n- Git integration (capture commits)\n- Execution history and comparison\n- Trajectory search and filtering\n- Cost tracking (token usage)\n- Approval system for tool execution\n- Export trajectories\n\n## Key Design Decisions\n\n### Why Three Layers (Issue → Execution → Trajectory)?\n\n- **Issue** = What to do (user-defined task)\n- **Execution** = Agent run (can retry, use different agents)\n- **Trajectory** = How it was done (reproducibility, debugging)\n\nThis allows:\n\n1. Multiple attempts on same issue\n1. Comparing different agents\n1. Detailed playback and analysis\n\n### Why Normalize Logs?\n\nDifferent agents have wildly different output formats:\n\n- Claude Code: Structured JSON\n- Codex: Different JSON format\n- Aider: Plain text with markers\n\nNormalization gives us:\n\n1. Unified UI across all agents\n1. Consistent database schema\n1. Easier analysis and search\n\n### Why AsyncIterable for Log Processing?\n\n```typescript\nasync *normalizeLogs(rawLogs: AsyncIterable<string>)\n```\n\nBenefits:\n\n1. Streaming - process logs as they arrive\n1. Memory efficient - don't load all logs at once\n1. Cancellable - can stop mid-stream\n1. Natural async/await syntax\n\n### Why Store Raw + Normalized?\n\nStore both raw logs (temp files) AND normalized entries: [[ISSUE-032]]{ references }\n\n- Raw logs: debugging, replay, re-parsing\n- Normalized: fast queries, UI display\n\nTrade storage for flexibility.\n\n## Testing Strategy\n\n### Unit Tests\n\n- Log normalization logic\n- Action type extraction\n- Session ID parsing\n\n### Integration Tests\n\n[[ISSUE-033]]{ references }\n\n- Full execution lifecycle\n- WebSocket streaming\n- Database persistence\n\n### E2E Tests\n\n- Start execution via API\n- Verify trajectory entries created\n- Check final status\n\n## Open Questions\n\n1. **Where to run executions?**\n  - Option A: Same machine as server (simpler)\n  - Option B: Separate worker processes (scalable)\n  - **Recommendation**: Start with A, migrate to B later\n1. **How to handle long-running executions?**\n  - Timeout after N minutes?\n  - User-configurable timeout?\n  - **Recommendation**: 30min default, configurable per-issue\n1. **Store raw logs where?**\n  - Temp files (deleted after normalization)?\n  - Database blob?\n  - S3/object storage?\n  - **Recommendation**: Temp files initially, add retention later\n1. **How to handle git context?**\n  - Create isolated git worktrees for executions?\n  - Run in-place and capture commits?\n  - **Recommendation**: Start in-place, add worktrees in Phase 6\n\n## Success Metrics\n\n- **MVP (Phase 1)**: Can run Claude Code on an issue\n- **Useful (Phase 3)**: Can watch execution in real-time\n- **Powerful (Phase 4)**: Can have multi-turn conversations\n- **Production (Phase 6)**: Multiple agents, git integration, approval workflows\n\n## References\n\n- Claude Code: [https://docs.anthropic.com/en/docs/claude-code](https://docs.anthropic.com/en/docs/claude-code)\n- Codex: [https://github.com/phasehq/codex](https://github.com/phasehq/codex)","priority":0,"created_at":"2025-10-27 00:06:59","updated_at":"2025-10-27 04:45:11","parent_id":null,"relationships":[{"from":"SPEC-001","from_type":"spec","to":"ISSUE-028","to_type":"issue","type":"references"},{"from":"SPEC-001","from_type":"spec","to":"ISSUE-029","to_type":"issue","type":"references"},{"from":"SPEC-001","from_type":"spec","to":"ISSUE-030","to_type":"issue","type":"references"},{"from":"SPEC-001","from_type":"spec","to":"ISSUE-031","to_type":"issue","type":"references"},{"from":"SPEC-001","from_type":"spec","to":"ISSUE-032","to_type":"issue","type":"references"},{"from":"SPEC-001","from_type":"spec","to":"ISSUE-033","to_type":"issue","type":"references"}],"tags":[]}
