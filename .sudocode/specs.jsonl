{"id":"SPEC-001","uuid":"37d447c6-5f01-435d-b7e8-99d689e597f8","title":"Agent Execution System","file_path":"specs/agent_execution_system.md","content":"# Agent Execution System\n\n## Overview\n\nA flexible system for running different coding agents on issues and tracking their execution trajectories. Designed for sudocode's TypeScript/Node.js stack.\n\n## Architecture\n\n### Three-Layer Execution Model\n\n```\nIssue → Execution → Trajectory Entries\n  ↓         ↓            ↓\nTask      Process    Log Events\n```\n\n**1\\. Issue** (existing)\n\n- Already implemented in sudocode\n- Represents a task to be completed\n\n**2\\. Execution** (new)\n\n- Represents a single agent run on an issue\n- Tracks: agent type, status, git context, session info\n- Multiple executions can exist per issue (retries, different agents)\n\n**3\\. Trajectory Entry** (new)\n\n- Individual events/actions during execution\n- Tool uses, thinking, messages, file changes\n- Enables playback and analysis of agent behavior\n\n### Supported Agents\n\nPhase 1: **Claude Code** (via `@anthropic-ai/claude-code`) Phase 2: **Codex** (via `@phasehq/codex`) Future: Aider, Cursor, custom agents\n\n## Data Models\n\n### Execution\n\n```typescript\ninterface Execution {\n  id: string;                    // UUID\n  issueId: string;               // Foreign key to issues\n  agentType: AgentType;          // Which agent ran\n  status: ExecutionStatus;       // Current state\n  \n  // Timestamps\n  startedAt: Date;\n  completedAt?: Date;\n  \n  // Process info\n  exitCode?: number;\n  \n  // Git context (captured before/after)\n  beforeCommit?: string;         // Git SHA before execution\n  afterCommit?: string;          // Git SHA after execution\n  \n  // Session tracking (for resume/fork)\n  sessionId?: string;            // External session ID from agent\n  prompt?: string;               // Initial prompt sent\n  summary?: string;              // Final agent summary\n  \n  // Metadata\n  createdAt: Date;\n  updatedAt: Date;\n}\n\ntype AgentType = 'claude-code' | 'codex';\n\ntype ExecutionStatus = \n  | 'running'\n  | 'completed' \n  | 'failed'\n  | 'stopped';\n```\n\n### Trajectory Entry\n\n```typescript\ninterface TrajectoryEntry {\n  id: number;                    // Auto-increment\n  executionId: string;           // Foreign key to executions\n  index: number;                 // Sequential order within execution\n  timestamp: Date;\n  \n  // Entry type and data (polymorphic)\n  type: EntryType;\n  content: string;               // Display text\n  metadata?: Record<string, any>; // Type-specific data\n}\n\ntype EntryType = \n  | 'tool_use'        // Agent used a tool\n  | 'thinking'        // Agent reasoning/planning\n  | 'assistant_msg'   // Agent message to user\n  | 'user_msg'        // User message to agent\n  | 'user_feedback'   // User approval/denial\n  | 'system_msg'      // System notifications\n  | 'error_msg';      // Errors\n\n// Tool use metadata\ninterface ToolUseMetadata {\n  toolName: string;\n  action: ActionType;\n  status: 'created' | 'running' | 'success' | 'failed';\n}\n\ntype ActionType =\n  | { type: 'file_read', path: string }\n  | { type: 'file_edit', path: string, changes: FileChange[] }\n  | { type: 'file_write', path: string, content: string }\n  | { type: 'command_run', command: string, result?: CommandResult }\n  | { type: 'search', query: string }\n  | { type: 'web_fetch', url: string }\n  | { type: 'task_create', description: string }\n  | { type: 'tool', toolName: string, args: any, result?: any };\n\ninterface FileChange {\n  type: 'edit' | 'write';\n  unifiedDiff?: string;          // For edits\n  content?: string;              // For writes\n  hasLineNumbers: boolean;\n}\n\ninterface CommandResult {\n  exitStatus: { code: number } | { success: boolean };\n  output: string;\n}\n```\n\n## Agent Abstraction\n\n### CodingAgent Interface\n\n```typescript\ninterface CodingAgent {\n  // Spawn initial execution\n  spawn(\n    workDir: string, \n    prompt: string\n  ): Promise<SpawnedProcess>;\n  \n  // Spawn follow-up (resume/fork)\n  spawnFollowUp(\n    workDir: string,\n    prompt: string, \n    sessionId: string\n  ): Promise<SpawnedProcess>;\n  \n  // Normalize agent-specific logs to TrajectoryEntry\n  normalizeLogs(\n    rawLogs: AsyncIterable<string>\n  ): AsyncIterable<TrajectoryEntry>;\n  \n  // Capabilities\n  supportsSessionFork(): boolean;\n  supportsMCP(): boolean;\n  getDefaultMCPConfigPath(): string | null;\n}\n\ninterface SpawnedProcess {\n  process: ChildProcess;\n  exitSignal?: Promise<void>;  // Optional early exit signal\n}\n```\n\n### Claude Code Executor\n\n```typescript\nclass ClaudeCodeExecutor implements CodingAgent {\n  async spawn(workDir: string, prompt: string) {\n    const proc = spawn('npx', [\n      '-y', '@anthropic-ai/claude-code@latest',\n      '-p',\n      '--output-format=stream-json',\n      '--include-partial-messages',\n      '--verbose'\n    ], { \n      cwd: workDir,\n      stdio: ['pipe', 'pipe', 'pipe']\n    });\n    \n    proc.stdin.write(prompt);\n    proc.stdin.end();\n    \n    return { process: proc };\n  }\n  \n  async spawnFollowUp(workDir: string, prompt: string, sessionId: string) {\n    const proc = spawn('npx', [\n      '-y', '@anthropic-ai/claude-code@latest',\n      '-p',\n      '--output-format=stream-json',\n      '--include-partial-messages',\n      '--verbose',\n      '--fork-session',\n      '--resume', sessionId\n    ], { cwd: workDir });\n    \n    proc.stdin.write(prompt);\n    proc.stdin.end();\n    \n    return { process: proc };\n  }\n  \n  async *normalizeLogs(rawLogs: AsyncIterable<string>) {\n    let buffer = '';\n    let sessionIdExtracted = false;\n    let entryIndex = 0;\n    \n    for await (const chunk of rawLogs) {\n      buffer += chunk;\n      \n      // Process complete JSON lines\n      const lines = buffer.split('\\n');\n      buffer = lines.pop() || '';\n      \n      for (const line of lines) {\n        const trimmed = line.trim();\n        if (!trimmed) continue;\n        \n        try {\n          const json = JSON.parse(trimmed);\n          \n          // Extract session ID\n          if (!sessionIdExtracted && json.session_id) {\n            sessionIdExtracted = true;\n            // Emit session ID separately for storage\n          }\n          \n          // Normalize to TrajectoryEntry\n          const entries = this.normalizeClaudeJson(json, entryIndex);\n          for (const entry of entries) {\n            yield entry;\n            entryIndex++;\n          }\n        } catch (e) {\n          // Non-JSON output - treat as system message\n          yield {\n            index: entryIndex++,\n            type: 'system_msg',\n            content: trimmed,\n            timestamp: new Date()\n          };\n        }\n      }\n    }\n  }\n  \n  private normalizeClaudeJson(json: any, startIndex: number): TrajectoryEntry[] {\n    // Parse Claude's JSON format into TrajectoryEntry[]\n    const entries: TrajectoryEntry[] = [];\n    \n    switch (json.type) {\n      case 'system':\n        if (json.subtype !== 'init') {\n          entries.push({\n            index: startIndex,\n            type: 'system_msg',\n            content: `System: ${json.subtype || 'message'}`,\n            timestamp: new Date(),\n            metadata: json\n          });\n        }\n        break;\n        \n      case 'assistant':\n        for (const item of json.message.content) {\n          if (item.type === 'text') {\n            entries.push({\n              index: startIndex + entries.length,\n              type: 'assistant_msg',\n              content: item.text,\n              timestamp: new Date(),\n              metadata: item\n            });\n          } else if (item.type === 'thinking') {\n            entries.push({\n              index: startIndex + entries.length,\n              type: 'thinking',\n              content: item.thinking,\n              timestamp: new Date(),\n              metadata: item\n            });\n          } else if (item.type === 'tool_use') {\n            entries.push({\n              index: startIndex + entries.length,\n              type: 'tool_use',\n              content: this.generateToolContent(item),\n              timestamp: new Date(),\n              metadata: {\n                toolName: item.name,\n                action: this.extractAction(item),\n                status: 'created'\n              }\n            });\n          }\n        }\n        break;\n        \n      case 'user':\n        // Handle tool results and user messages\n        break;\n    }\n    \n    return entries;\n  }\n  \n  supportsSessionFork() { return true; }\n  supportsMCP() { return true; }\n  getDefaultMCPConfigPath() { \n    return `${os.homedir()}/.claude.json`; \n  }\n}\n```\n\n### Codex Executor\n\n```typescript\nclass CodexExecutor implements CodingAgent {\n  async spawn(workDir: string, prompt: string) {\n    // Similar structure, but using Codex CLI\n    const proc = spawn('npx', [\n      '-y', '@phasehq/codex@latest',\n      // Codex-specific flags\n    ], { cwd: workDir });\n    \n    // Codex has different input format\n    proc.stdin.write(JSON.stringify({ prompt }));\n    proc.stdin.end();\n    \n    return { process: proc };\n  }\n  \n  async *normalizeLogs(rawLogs: AsyncIterable<string>) {\n    // Codex-specific log parsing\n    // Different format than Claude\n  }\n  \n  supportsSessionFork() { return true; }\n  supportsMCP() { return true; }\n}\n```\n\n## Database Schema\n\n### Executions Table\n\n[[ISSUE-028]]{ references }\n\n```sql\nCREATE TABLE executions (\n  id TEXT PRIMARY KEY,\n  issue_id TEXT NOT NULL REFERENCES issues(id) ON DELETE CASCADE,\n  agent_type TEXT NOT NULL,  -- 'claude-code' | 'codex' | etc\n  status TEXT NOT NULL,      -- 'running' | 'completed' | 'failed' | 'stopped'\n  \n  started_at INTEGER NOT NULL,\n  completed_at INTEGER,\n  exit_code INTEGER,\n  \n  before_commit TEXT,\n  after_commit TEXT,\n  \n  session_id TEXT,\n  prompt TEXT,\n  summary TEXT,\n  \n  created_at INTEGER NOT NULL DEFAULT (unixepoch()),\n  updated_at INTEGER NOT NULL DEFAULT (unixepoch())\n);\n\nCREATE INDEX idx_executions_issue_id ON executions(issue_id);\nCREATE INDEX idx_executions_status ON executions(status);\nCREATE INDEX idx_executions_session_id ON executions(session_id);\n```\n\n### Trajectory Entries Table\n\n```sql\nCREATE TABLE trajectory_entries (\n  id INTEGER PRIMARY KEY AUTOINCREMENT,\n  execution_id TEXT NOT NULL REFERENCES executions(id) ON DELETE CASCADE,\n  entry_index INTEGER NOT NULL,\n  timestamp INTEGER NOT NULL,\n  \n  type TEXT NOT NULL,  -- 'tool_use' | 'thinking' | 'assistant_msg' | etc\n  content TEXT NOT NULL,\n  metadata TEXT,       -- JSON blob\n  \n  created_at INTEGER NOT NULL DEFAULT (unixepoch())\n);\n\nCREATE INDEX idx_trajectory_entries_execution_id ON trajectory_entries(execution_id);\nCREATE INDEX idx_trajectory_entries_execution_index ON trajectory_entries(execution_id, entry_index);\n```\n\n## API Endpoints\n\n[[ISSUE-031]]{ references }\n\n### Start Execution\n\n```\nPOST /api/issues/:issueId/executions\n{\n  \"agentType\": \"claude-code\",\n  \"prompt\": \"Fix the authentication bug\"\n}\n\nResponse: { \"executionId\": \"exec-123\" }\n```\n\n### Get Execution Status\n\n```\nGET /api/executions/:executionId\n\nResponse: {\n  \"id\": \"exec-123\",\n  \"issueId\": \"issue-456\",\n  \"agentType\": \"claude-code\",\n  \"status\": \"running\",\n  \"startedAt\": \"2025-01-26T10:00:00Z\",\n  ...\n}\n```\n\n### Stream Trajectory (WebSocket)\n\n```\nWS /api/executions/:executionId/trajectory\n\nMessages:\n{\n  \"type\": \"entry\",\n  \"data\": {\n    \"index\": 5,\n    \"type\": \"tool_use\",\n    \"content\": \"`src/auth.ts`\",\n    \"timestamp\": \"2025-01-26T10:01:23Z\",\n    \"metadata\": { ... }\n  }\n}\n\n{\n  \"type\": \"session_id\",\n  \"data\": { \"sessionId\": \"claude-session-abc\" }\n}\n\n{\n  \"type\": \"finished\",\n  \"data\": { \"exitCode\": 0 }\n}\n```\n\n### Stop Execution\n\n```\nPOST /api/executions/:executionId/stop\n\nResponse: { \"status\": \"stopped\" }\n```\n\n### List Executions for Issue\n\n```\nGET /api/issues/:issueId/executions\n\nResponse: {\n  \"executions\": [\n    { \"id\": \"exec-123\", ... },\n    { \"id\": \"exec-124\", ... }\n  ]\n}\n```\n\n## Implementation Phases\n\n### Phase 1: Core Execution (MVP)\n\n[[ISSUE-029]]{ references }**Goal**: Basic process spawning and log storage\n\n**Issues**:\n\n- [[ISSUE-028]] - Database schema and TypeScript types for executions\n- [[ISSUE-029]] - Implement ExecutionManager class for process lifecycle management\n- [[ISSUE-030]] - Implement basic Claude Code process spawning\n- [[ISSUE-031]] - API endpoints for execution management\n- [[ISSUE-032]] - Raw log storage in temp files\n- [[ISSUE-033]] - Integration test for Phase 1 MVP\n\n**Deliverable**: Can start Claude Code on an issue, track if it's running, and know when it finishes.\n\n### Phase 2: Trajectory Normalization\n\n**Goal**: Parse and store structured logs\n\n- Add trajectory\\_entries table\n- ClaudeCodeExecutor with normalization\n- Parse Claude JSON format → TrajectoryEntry\n- Store entries in database\n- API endpoint: get trajectory entries\n\n**Deliverable**: Can view what Claude did step-by-step (tools used, files edited, etc.)\n\n### Phase 3: Real-Time Streaming\n\n**Goal**: Live updates in UI\n\n- WebSocket endpoint for live trajectory\n- Frontend TrajectoryViewer component\n- Display tool uses, thinking, messages\n- Auto-scroll and updates\n\n**Deliverable**: Watch agent execution in real-time\n\n### Phase 4: Session Management\n\n**Goal**: Resume and fork executions\n\n- Extract session IDs during execution\n- Store session\\_id in executions table\n- Implement spawnFollowUp\n- API endpoint: resume execution\n- UI: \"Continue\" button on executions\n\n**Deliverable**: Can send follow-up prompts to same session\n\n### Phase 5: Multiple Agents\n\n**Goal**: Support Codex and others\n\n- CodingAgent abstraction\n- CodexExecutor implementation\n- Agent selection in UI\n- Agent-specific config (MCP, etc.)\n\n**Deliverable**: Can choose between Claude Code and Codex\n\n### Phase 6: Advanced Features\n\n**Goal**: Production-ready\n\n- Git integration (capture commits)\n- Execution history and comparison\n- Trajectory search and filtering\n- Cost tracking (token usage)\n- Approval system for tool execution\n- Export trajectories\n\n## Key Design Decisions\n\n### Why Three Layers (Issue → Execution → Trajectory)?\n\n- **Issue** = What to do (user-defined task)\n- **Execution** = Agent run (can retry, use different agents)\n- **Trajectory** = How it was done (reproducibility, debugging)\n\nThis allows:\n\n1. Multiple attempts on same issue\n1. Comparing different agents\n1. Detailed playback and analysis\n\n### Why Normalize Logs?\n\nDifferent agents have wildly different output formats:\n\n- Claude Code: Structured JSON\n- Codex: Different JSON format\n- Aider: Plain text with markers\n\nNormalization gives us:\n\n1. Unified UI across all agents\n1. Consistent database schema\n1. Easier analysis and search\n\n### Why AsyncIterable for Log Processing?\n\n```typescript\nasync *normalizeLogs(rawLogs: AsyncIterable<string>)\n```\n\nBenefits:\n\n1. Streaming - process logs as they arrive\n1. Memory efficient - don't load all logs at once\n1. Cancellable - can stop mid-stream\n1. Natural async/await syntax\n\n### Why Store Raw + Normalized?\n\nStore both raw logs (temp files) AND normalized entries: [[ISSUE-032]]{ references }\n\n- Raw logs: debugging, replay, re-parsing\n- Normalized: fast queries, UI display\n\nTrade storage for flexibility.\n\n## Testing Strategy\n\n### Unit Tests\n\n- Log normalization logic\n- Action type extraction\n- Session ID parsing\n\n### Integration Tests\n\n[[ISSUE-033]]{ references }\n\n- Full execution lifecycle\n- WebSocket streaming\n- Database persistence\n\n### E2E Tests\n\n- Start execution via API\n- Verify trajectory entries created\n- Check final status\n\n## Open Questions\n\n1. **Where to run executions?**\n  - Option A: Same machine as server (simpler)\n  - Option B: Separate worker processes (scalable)\n  - **Recommendation**: Start with A, migrate to B later\n1. **How to handle long-running executions?**\n  - Timeout after N minutes?\n  - User-configurable timeout?\n  - **Recommendation**: 30min default, configurable per-issue\n1. **Store raw logs where?**\n  - Temp files (deleted after normalization)?\n  - Database blob?\n  - S3/object storage?\n  - **Recommendation**: Temp files initially, add retention later\n1. **How to handle git context?**\n  - Create isolated git worktrees for executions?\n  - Run in-place and capture commits?\n  - **Recommendation**: Start in-place, add worktrees in Phase 6\n\n## Success Metrics\n\n- **MVP (Phase 1)**: Can run Claude Code on an issue\n- **Useful (Phase 3)**: Can watch execution in real-time\n- **Powerful (Phase 4)**: Can have multi-turn conversations\n- **Production (Phase 6)**: Multiple agents, git integration, approval workflows\n\n## References\n\n- Claude Code: [https://docs.anthropic.com/en/docs/claude-code](https://docs.anthropic.com/en/docs/claude-code)\n- Codex: [https://github.com/phasehq/codex](https://github.com/phasehq/codex)","priority":0,"archived":1,"archived_at":"2025-10-28T19:03:55.817Z","created_at":"2025-10-27 00:06:59","updated_at":"2025-10-28 19:03:55","parent_id":null,"relationships":[{"from":"SPEC-001","from_type":"spec","to":"ISSUE-028","to_type":"issue","type":"references"},{"from":"SPEC-001","from_type":"spec","to":"ISSUE-029","to_type":"issue","type":"references"},{"from":"SPEC-001","from_type":"spec","to":"ISSUE-030","to_type":"issue","type":"references"},{"from":"SPEC-001","from_type":"spec","to":"ISSUE-032","to_type":"issue","type":"references"},{"from":"SPEC-001","from_type":"spec","to":"ISSUE-033","to_type":"issue","type":"references"}],"tags":[]}
{"id":"SPEC-002","uuid":"603f99a9-53d6-448a-b66c-cf6c902894cf","title":"Execution System","file_path":"specs/execution_system.md","content":"Execution System Specification for Sudocode\n\n  Overview\n\n  Design a flexible, simple-first execution system that can spawn Claude Code instances to work on issues and\n  specs, with real-time progress tracking and the ability to upgrade to a pool-based strategy later.\n\n  Architecture Goals\n\n  1. Simple First: Start with straightforward process spawning\n  2. Flexible Design: Easy to upgrade to pool strategy without breaking changes\n  3. Real-time Feedback: Stream progress to frontend via WebSocket\n  4. Context-Aware: Build rich prompts from issue, spec, and codebase data\n  5. Reliable: Handle errors, timeouts, and process crashes gracefully\n\n  System Components\n\n  ┌─────────────────────────────────────────────────────────────┐\n  │                     Execution System                         │\n  ├─────────────────────────────────────────────────────────────┤\n  │                                                              │\n  │  ┌──────────────┐      ┌──────────────┐      ┌──────────┐  │\n  │  │   Context    │      │  Execution   │      │ Progress │  │\n  │  │   Builder    │─────▶│ Orchestrator │─────▶│ Tracker  │  │\n  │  └──────────────┘      └──────┬───────┘      └────┬─────┘  │\n  │                               │                    │         │\n  │                               ▼                    ▼         │\n  │                    ┌──────────────────┐    ┌──────────────┐ │\n  │                    │ Simple Execution │    │  WebSocket   │ │\n  │                    │    Strategy      │    │   Service    │ │\n  │                    └────────┬─────────┘    └──────────────┘ │\n  │                             │                                │\n  │                             ▼                                │\n  │                   ┌──────────────────┐                       │\n  │                   │ Simple Process   │                       │\n  │                   │    Manager       │                       │\n  │                   └────────┬─────────┘                       │\n  │                            │                                 │\n  │                            ▼                                 │\n  │                   ┌──────────────────┐                       │\n  │                   │  Claude Code     │                       │\n  │                   │  CLI Process     │                       │\n  │                   └──────────────────┘                       │\n  │                                                              │\n  └─────────────────────────────────────────────────────────────┘\n\n  Data Flow\n\n  1. User triggers execution (via API/UI)\n     ↓\n  2. ExecutionOrchestrator.executeIssue(issueId)\n     ↓\n  3. ContextBuilder.buildIssueContext(issueId)\n     - Read issue from database\n     - Find related specs via relationships\n     - Find related issues (dependencies, parent)\n     - Read spec content from markdown files\n     - Build comprehensive prompt\n     ↓\n  4. Create ExecutionTask\n     - Task ID, entity type, context, priority\n     ↓\n  5. SimpleExecutionStrategy.executeTask(task)\n     ↓\n  6. SimpleProcessManager.acquireProcess(task)\n     - Spawn new Claude Code CLI process\n     - Return ManagedProcess handle\n     ↓\n  7. Send prompt to Claude via stdin\n     - Use stream-json output format\n     - Parse output line by line\n     ↓\n  8. ProgressTracker emits updates\n     - Phase changes (initializing → executing → finalizing)\n     - Tool use events (reading files, editing, etc.)\n     - Completion status\n     ↓\n  9. WebSocketService broadcasts to frontend\n     - Real-time progress updates\n     - Execution logs\n     - Final results\n     ↓\n  10. Update execution record in database\n      - Status, exit code, duration, etc.\n      ↓\n  11. SimpleProcessManager.releaseProcess(processId)\n      - Terminate Claude process\n      - Clean up resources\n\n  Component Specifications\n\n  1. Context Builder\n\n  Purpose: Build rich, context-aware prompts for Claude Code\n\n  Inspired by: CodeMachine-CLI's context-manager-agent\n  (references/CodeMachine-CLI/prompts/templates/codemachine/agents/04-context-manager-agent.md)\n\n  Interface:\n  interface IContextBuilder {\n    buildIssueContext(issueId: string): Promise<ExecutionContext>;\n    buildSpecContext(specId: string): Promise<ExecutionContext>;\n    buildBatchContext(entityIds: string[]): Promise<Map<string, ExecutionContext>>;\n  }\n\n  interface ExecutionContext {\n    workDir: string;\n    entityType: 'issue' | 'spec';\n    entityId: string;\n\n    // Core data\n    title: string;\n    description: string;\n\n    // Related entities\n    relatedSpecs: Array<{\n      id: string;\n      title: string;\n      content: string;\n      relationship: string;\n    }>;\n\n    relatedIssues: Array<{\n      id: string;\n      title: string;\n      description: string;\n      status: string;\n      relationship: string;\n    }>;\n\n    // Codebase context (optional, for later enhancement)\n    relevantFiles?: string[];\n\n    // Final prompt\n    prompt: string;\n  }\n\n  Prompt Template Structure (inspired by CodeMachine-CLI):\n  # Task: Work on Issue {issueId}\n\n  ## Issue Details\n  **Title**: {issue.title}\n  **Status**: {issue.status}\n  **Priority**: {issue.priority}\n\n  **Description**:\n  {issue.description}\n\n  ## Related Specifications\n\n  {for each related spec}\n  ### {spec.id}: {spec.title}\n  **Relationship**: {relationship.type}\n\n  {spec.content}\n  {end for}\n\n  ## Related Issues\n\n  {for each related issue}\n  ### {issue.id}: {issue.title}\n  **Status**: {issue.status}\n  **Relationship**: {relationship.type}\n\n  {issue.description}\n  {end for}\n\n  ## Instructions\n\n  1. Analyze the issue description and related specifications\n  2. Understand the requirements and acceptance criteria\n  3. Implement the necessary changes to address the issue\n  4. Test your implementation\n  5. Ensure code quality and adherence to project standards\n\n  ## Project Context\n\n  - Working directory: {workDir}\n  - Project: sudocode issue tracking system\n  - Use TypeScript for all implementations\n  - Follow existing code patterns in the codebase\n\n  ## Output Requirements\n\n  - Make necessary code changes\n  - Update tests if needed\n  - Provide a summary of changes made\n\n  Implementation Notes:\n  - Use template strings or a templating library (handlebars, mustache)\n  - Cache spec content to avoid repeated file reads\n  - Handle missing relationships gracefully\n  - Support both issue and spec execution contexts\n\n  ---\n  2. Execution Orchestrator\n\n  Purpose: Main coordinator that ties all components together\n\n  Inspired by:\n  - CodeMachine-CLI's workflow orchestrator (references/CodeMachine-CLI/src/workflows/execution/workflow.ts)\n  - claude-flow's SwarmCoordinator (references/claude-flow/src/swarm/coordinator.ts)\n\n  Interface:\n  class ExecutionOrchestrator {\n    constructor(\n      private strategy: IExecutionStrategy,\n      private contextBuilder: IContextBuilder,\n      private progressTracker: IProgressTracker,\n      private db: Database.Database\n    );\n\n    // Primary methods\n    executeIssue(issueId: string, options?: ExecutionOptions): Promise<ExecutionResult>;\n    executeSpec(specId: string, options?: ExecutionOptions): Promise<ExecutionResult>;\n    executeMultiple(entityIds: string[], options?: ExecutionOptions): Promise<ExecutionResult[]>;\n\n    // Control methods\n    stopExecution(executionId: string): Promise<void>;\n    getExecutionStatus(executionId: string): ExecutionProgress | null;\n\n    // Strategy management\n    switchStrategy(newStrategy: IExecutionStrategy): void;\n  }\n\n  interface ExecutionOptions {\n    workDir?: string;\n    maxDuration?: number;  // milliseconds\n    priority?: number;\n    customPrompt?: string; // Override generated prompt\n  }\n\n  Key Responsibilities:\n  1. Coordinate between context builder, strategy, and progress tracker\n  2. Create and persist execution records in database\n  3. Handle errors and timeouts gracefully\n  4. Provide clean API for frontend/API layer\n\n  Implementation Pattern (from CodeMachine-CLI):\n  async executeIssue(issueId: string, options: ExecutionOptions = {}): Promise<ExecutionResult> {\n    // 1. Build context\n    const context = await this.contextBuilder.buildIssueContext(issueId);\n\n    // 2. Create task\n    const task: ExecutionTask = {\n      id: generateId('task'),\n      type: 'issue',\n      entityId: issueId,\n      context: {\n        ...context,\n        workDir: options.workDir || process.cwd(),\n      },\n      priority: options.priority || 1,\n      dependencies: [], // TODO: Resolve from relationships\n    };\n\n    // 3. Create execution record in DB\n    const execution = createExecution(this.db, {\n      issue_id: issueId,\n      agent_type: 'claude-code',\n      status: 'running',\n    });\n\n    // 4. Start progress tracking\n    this.progressTracker.startTracking(execution.id, task);\n\n    try {\n      // 5. Execute via strategy\n      const result = await this.strategy.executeTask(task);\n\n      // 6. Update database\n      updateExecution(this.db, execution.id, {\n        status: result.success ? 'completed' : 'failed',\n        exit_code: result.success ? 0 : 1,\n        completed_at: Math.floor(Date.now() / 1000),\n        error_message: result.error,\n      });\n\n      // 7. Complete tracking\n      this.progressTracker.completeTracking(execution.id, result);\n\n      return result;\n    } catch (error) {\n      // Handle errors\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n\n      updateExecution(this.db, execution.id, {\n        status: 'failed',\n        completed_at: Math.floor(Date.now() / 1000),\n        error_message: errorMessage,\n      });\n\n      this.progressTracker.completeTracking(execution.id, {\n        ...result,\n        success: false,\n        error: errorMessage,\n      });\n\n      throw error;\n    }\n  }\n\n  ---\n  3. Simple Execution Strategy\n\n  Purpose: Execute tasks by spawning Claude Code processes on-demand\n\n  Inspired by:\n  - CodeMachine-CLI's step execution (references/CodeMachine-CLI/src/workflows/execution/step.ts)\n  - claude-flow's SimpleExecutionStrategy pattern\n\n  Interface:\n  class SimpleExecutionStrategy implements IExecutionStrategy {\n    constructor(\n      private processManager: IProcessManager,\n      private maxConcurrent: number = 3,\n      private defaultTimeout: number = 300_000 // 5 minutes\n    );\n\n    executeTask(task: ExecutionTask): Promise<ExecutionResult>;\n    executeTasks(tasks: ExecutionTask[]): Promise<ExecutionResult[]>;\n    getMetrics(): StrategyMetrics;\n    shutdown(): Promise<void>;\n  }\n\n  Key Implementation Details:\n\n  1. Process Spawning (from CodeMachine-CLI pattern):\n  private async runTask(\n    process: ManagedProcess,\n    task: ExecutionTask\n  ): Promise<ExecutionResult> {\n    const startTime = Date.now();\n\n    return new Promise((resolve, reject) => {\n      let outputBuffer = '';\n      let errorBuffer = '';\n\n      // Set up timeout\n      const timeout = setTimeout(() => {\n        process.process.kill('SIGTERM');\n        reject(new Error('Execution timed out'));\n      }, this.defaultTimeout);\n\n      // Parse stream-json output (from CodeMachine-CLI)\n      process.process.stdout?.on('data', (chunk: Buffer) => {\n        const text = chunk.toString();\n        outputBuffer += text;\n\n        // Parse JSON lines\n        const lines = text.split('\\n');\n        for (const line of lines) {\n          if (!line.trim()) continue;\n\n          try {\n            const json = JSON.parse(line);\n            this.handleStreamJsonLine(json, task);\n          } catch {\n            // Not JSON, treat as regular output\n          }\n        }\n      });\n\n      process.process.stderr?.on('data', (chunk: Buffer) => {\n        errorBuffer += chunk.toString();\n      });\n\n      process.process.on('exit', (code) => {\n        clearTimeout(timeout);\n\n        const duration = Date.now() - startTime;\n        const result: ExecutionResult = {\n          taskId: task.id,\n          executionId: process.id,\n          success: code === 0,\n          output: outputBuffer,\n          error: code !== 0 ? errorBuffer : undefined,\n          duration,\n          metadata: this.extractMetadata(outputBuffer),\n        };\n\n        resolve(result);\n      });\n\n      process.process.on('error', (error) => {\n        clearTimeout(timeout);\n        reject(error);\n      });\n    });\n  }\n\n  2. Stream JSON Parsing (from CodeMachine-CLI claude runner):\n  private handleStreamJsonLine(json: any, task: ExecutionTask): void {\n    // Parse different event types from Claude's stream-json format\n    if (json.type === 'assistant' && json.message?.content) {\n      for (const content of json.message.content) {\n        if (content.type === 'text') {\n          this.emitProgress(task.id, {\n            phase: 'executing',\n            message: content.text.substring(0, 200),\n          });\n        } else if (content.type === 'tool_use') {\n          this.emitProgress(task.id, {\n            phase: 'executing',\n            message: `Using tool: ${content.name}`,\n            metadata: { tool: content.name, args: content.input },\n          });\n        }\n      }\n    } else if (json.type === 'result') {\n      // Final result with usage stats\n      this.emitProgress(task.id, {\n        phase: 'finalizing',\n        message: 'Task completed',\n        metadata: {\n          duration: json.duration_ms,\n          tokensUsed: json.usage?.total_tokens,\n        },\n      });\n    }\n  }\n\n  3. Concurrency Control (simple batching):\n  async executeTasks(tasks: ExecutionTask[]): Promise<ExecutionResult[]> {\n    const results: ExecutionResult[] = [];\n\n    // Execute in batches\n    for (let i = 0; i < tasks.length; i += this.maxConcurrent) {\n      const batch = tasks.slice(i, i + this.maxConcurrent);\n      const batchResults = await Promise.all(\n        batch.map(task => this.executeTask(task))\n      );\n      results.push(...batchResults);\n    }\n\n    return results;\n  }\n\n  ---\n  4. Simple Process Manager\n\n  Purpose: Manage Claude Code CLI process lifecycle\n\n  Inspired by:\n  - claude-flow's process management (references/claude-flow/src/swarm/claude-code-interface.ts)\n  - Your existing ExecutionManager\n\n  Interface:\n  class SimpleProcessManager implements IProcessManager {\n    constructor(\n      private logsDir: string,\n      private claudePath: string = 'claude'\n    );\n\n    acquireProcess(task: ExecutionTask): Promise<ManagedProcess>;\n    releaseProcess(processId: string): Promise<void>;\n    terminateProcess(processId: string): Promise<void>;\n    getProcessMetrics(): ProcessMetrics;\n    shutdown(): Promise<void>;\n  }\n\n  Key Implementation:\n\n  1. Spawn Claude Code (from CodeMachine-CLI pattern):\n  private spawnClaudeProcess(task: ExecutionTask): ChildProcess {\n    const args = [\n      '--print',                          // Non-interactive mode\n      '--output-format', 'stream-json',   // Structured output\n      '--dangerously-skip-permissions',   // Skip permission prompts\n      '--permission-mode', 'bypassPermissions',\n    ];\n\n    const process = spawn(this.claudePath, args, {\n      cwd: task.context.workDir,\n      stdio: ['pipe', 'pipe', 'pipe'],\n      env: {\n        ...process.env,\n        // Add any custom environment variables\n      },\n    });\n\n    // Write prompt to stdin\n    process.stdin?.write(task.context.prompt);\n    process.stdin?.end();\n\n    return process;\n  }\n\n  2. Process Tracking:\n  async acquireProcess(task: ExecutionTask): Promise<ManagedProcess> {\n    const process = this.spawnClaudeProcess(task);\n\n    if (!process.pid) {\n      throw new Error('Failed to spawn Claude process');\n    }\n\n    const managed: ManagedProcess = {\n      id: generateId('process'),\n      process,\n      status: 'busy',\n      spawnedAt: new Date(),\n      lastActivity: new Date(),\n      tasksCompleted: 0,\n      metrics: {\n        totalDuration: 0,\n        successRate: 1.0,\n      },\n    };\n\n    this.activeProcesses.set(managed.id, managed);\n    return managed;\n  }\n\n  3. Graceful Termination:\n  async terminateProcess(processId: string): Promise<void> {\n    const managed = this.activeProcesses.get(processId);\n    if (!managed) return;\n\n    managed.status = 'terminating';\n\n    // Try SIGTERM first\n    managed.process.kill('SIGTERM');\n\n    // Wait for graceful shutdown\n    await new Promise(resolve => setTimeout(resolve, 2000));\n\n    // Force kill if needed\n    if (!managed.process.killed && managed.process.exitCode === null) {\n      managed.process.kill('SIGKILL');\n    }\n\n    this.activeProcesses.delete(processId);\n  }\n\n  ---\n  5. Progress Tracker\n\n  Purpose: Track and emit real-time progress updates\n\n  Inspired by: claude-flow's event emission patterns\n\n  Interface:\n  interface IProgressTracker {\n    startTracking(executionId: string, task: ExecutionTask): void;\n    updateProgress(executionId: string, update: ProgressUpdate): void;\n    completeTracking(executionId: string, result: ExecutionResult): void;\n    getProgress(executionId: string): ExecutionProgress | null;\n    onProgress(callback: (update: ProgressUpdate) => void): void;\n  }\n\n  interface ProgressUpdate {\n    executionId: string;\n    phase: 'initializing' | 'context_building' | 'executing' | 'finalizing';\n    message: string;\n    percentage?: number;\n    metadata?: {\n      tool?: string;\n      args?: any;\n      tokensUsed?: number;\n      filesChanged?: string[];\n    };\n  }\n\n  Implementation:\n  class WebSocketProgressTracker implements IProgressTracker {\n    private progressMap = new Map<string, ExecutionProgress>();\n    private callbacks: Array<(update: ProgressUpdate) => void> = [];\n\n    constructor(private wss: WebSocketService) {}\n\n    startTracking(executionId: string, task: ExecutionTask): void {\n      const progress: ExecutionProgress = {\n        executionId,\n        taskId: task.id,\n        status: 'running',\n        currentPhase: 'initializing',\n        startTime: new Date(),\n        lastUpdate: new Date(),\n      };\n\n      this.progressMap.set(executionId, progress);\n\n      // Emit initial update\n      this.emitUpdate({\n        executionId,\n        phase: 'initializing',\n        message: 'Starting execution...',\n        percentage: 0,\n      });\n    }\n\n    updateProgress(executionId: string, update: ProgressUpdate): void {\n      const progress = this.progressMap.get(executionId);\n      if (!progress) return;\n\n      progress.currentPhase = update.phase;\n      progress.lastUpdate = new Date();\n\n      this.emitUpdate(update);\n    }\n\n    completeTracking(executionId: string, result: ExecutionResult): void {\n      const progress = this.progressMap.get(executionId);\n      if (!progress) return;\n\n      progress.status = result.success ? 'completed' : 'failed';\n\n      this.emitUpdate({\n        executionId,\n        phase: 'finalizing',\n        message: result.success ? 'Execution completed successfully' : `Execution failed: ${result.error}`,\n        percentage: 100,\n        metadata: result.metadata,\n      });\n\n      // Clean up after a delay\n      setTimeout(() => {\n        this.progressMap.delete(executionId);\n      }, 60_000); // Keep for 1 minute\n    }\n\n    private emitUpdate(update: ProgressUpdate): void {\n      // Emit to WebSocket clients\n      this.wss.broadcast('execution:progress', update);\n\n      // Emit to registered callbacks\n      for (const callback of this.callbacks) {\n        callback(update);\n      }\n    }\n\n    onProgress(callback: (update: ProgressUpdate) => void): void {\n      this.callbacks.push(callback);\n    }\n  }\n\n  ---\n  Integration with Existing Code\n\n  1. Update ExecutionManager\n\n  // server/src/execution/manager.ts\n  export class ExecutionManager {\n    private orchestrator: ExecutionOrchestrator;\n\n    constructor(\n      db: Database.Database,\n      wss: WebSocketService,\n      logsDir?: string\n    ) {\n      // Initialize components\n      const contextBuilder = new DefaultContextBuilder(db);\n      const progressTracker = new WebSocketProgressTracker(wss);\n      const processManager = new SimpleProcessManager(logsDir || path.join(os.tmpdir(),\n  'sudocode-executions'));\n      const strategy = new SimpleExecutionStrategy(processManager, 3);\n\n      // Create orchestrator\n      this.orchestrator = new ExecutionOrchestrator(\n        strategy,\n        contextBuilder,\n        progressTracker,\n        db\n      );\n    }\n\n    // Delegate to orchestrator\n    async startExecution(input: StartExecutionInput): Promise<Execution> {\n      return this.orchestrator.executeIssue(input.issue_id, {\n        workDir: input.work_dir,\n        customPrompt: input.prompt,\n      });\n    }\n\n    async stopExecution(executionId: string): Promise<void> {\n      return this.orchestrator.stopExecution(executionId);\n    }\n\n    getExecutionStatus(executionId: string): ExecutionProgress | null {\n      return this.orchestrator.getExecutionStatus(executionId);\n    }\n  }\n\n  2. Add API Endpoints\n\n  // server/src/routes/executions.ts\n  router.post('/executions', async (req, res) => {\n    const { issue_id, work_dir, prompt } = req.body;\n\n    try {\n      const result = await executionManager.startExecution({\n        issue_id,\n        agent_type: 'claude-code',\n        work_dir,\n        prompt,\n      });\n\n      res.json(result);\n    } catch (error) {\n      res.status(500).json({ error: error.message });\n    }\n  });\n\n  router.get('/executions/:id/status', async (req, res) => {\n    const status = executionManager.getExecutionStatus(req.params.id);\n\n    if (!status) {\n      return res.status(404).json({ error: 'Execution not found' });\n    }\n\n    res.json(status);\n  });\n\n  router.post('/executions/:id/stop', async (req, res) => {\n    await executionManager.stopExecution(req.params.id);\n    res.json({ success: true });\n  });\n\n  3. WebSocket Integration\n\n  // server/src/services/websocket.ts\n  export class WebSocketService {\n    broadcast(event: string, data: any): void {\n      this.wss.clients.forEach(client => {\n        if (client.readyState === WebSocket.OPEN) {\n          client.send(JSON.stringify({ event, data }));\n        }\n      });\n    }\n  }\n\n  // Frontend can subscribe to execution progress\n  socket.on('execution:progress', (update: ProgressUpdate) => {\n    console.log(`[${update.executionId}] ${update.phase}: ${update.message}`);\n    // Update UI with progress\n  });\n\n  ---\n  File Structure\n\n  server/src/execution/\n  ├── manager.ts                    # Existing ExecutionManager (updated)\n  ├── spawn-claude-code.ts         # Existing spawn utility\n  ├── orchestrator.ts              # NEW: ExecutionOrchestrator\n  ├── strategies/\n  │   ├── base.ts                  # IExecutionStrategy interface\n  │   ├── simple-strategy.ts       # SimpleExecutionStrategy\n  │   └── pool-strategy.ts         # (Future) PoolExecutionStrategy\n  ├── process-managers/\n  │   ├── base.ts                  # IProcessManager interface\n  │   ├── simple-manager.ts        # SimpleProcessManager\n  │   └── pool-manager.ts          # (Future) PoolProcessManager\n  ├── context/\n  │   ├── builder.ts               # IContextBuilder interface\n  │   ├── default-builder.ts       # DefaultContextBuilder\n  │   └── templates.ts             # Prompt templates\n  ├── progress/\n  │   ├── tracker.ts               # IProgressTracker interface\n  │   └── websocket-tracker.ts    # WebSocketProgressTracker\n  └── types.ts                     # Shared types and interfaces\n\n  ---\n  Implementation Phases\n\n  Phase 1: Core Infrastructure (Week 1)\n  - Define all interfaces in types.ts\n  - Implement DefaultContextBuilder\n  - Implement SimpleProcessManager\n  - Implement SimpleExecutionStrategy\n  - Write unit tests for each component\n\n  Phase 2: Orchestration (Week 2)\n  - Implement ExecutionOrchestrator\n  - Integrate with existing ExecutionManager\n  - Add API endpoints for execution control\n  - Write integration tests\n\n  Phase 3: Progress Tracking (Week 3)\n  - Implement WebSocketProgressTracker\n  - Add WebSocket event handling\n  - Update frontend to display progress\n  - Test end-to-end flow\n\n  Phase 4: Polish & Documentation (Week 4)\n  - Add error handling and recovery\n  - Write comprehensive documentation\n  - Create example usage guides\n  - Performance testing and optimization\n","priority":0,"archived":1,"archived_at":"2025-10-28T08:31:01.555Z","created_at":"2025-10-27 18:30:25","updated_at":"2025-10-29T01:26:08.211Z","parent_id":null,"relationships":[],"tags":[]}
{"id":"SPEC-003","uuid":"48dd725d-675a-4038-83d2-b5f5e41dd75a","title":"Process Layer - Claude Code Process Management","file_path":"specs/process_layer_claude_code_process_management.md","content":"# Process Layer Specification\n\n## Overview\n\nThe Process Layer (Layer 1) manages the lifecycle of individual Claude Code CLI processes. This is the foundation of the execution system, inspired by claude-flow's simple yet flexible approach.\n\n## Design Goals\n\n1. **Simple First**: Start with basic process spawning using Node.js child_process\n2. **Event-Driven**: Use native event emitters for real-time I/O streaming\n3. **Flexible**: Easy to upgrade from simple spawning to process pooling\n4. **Reliable**: Handle timeouts, crashes, and cleanup gracefully\n5. **Observable**: Expose all process events for upper layers\n\n## Architecture\n\nBased on Execution System spec, this implements the process spawning and management foundation.\n\n```\n┌─────────────────────────────────────────┐\n│        Process Layer (Layer 1)          │\n├─────────────────────────────────────────┤\n│                                         │\n│  ┌──────────────────────────────────┐  │\n│  │   IProcessManager (Interface)    │  │\n│  └────────────┬─────────────────────┘  │\n│               │                         │\n│               ├──────────────────────┐  │\n│               │                      │  │\n│     ┌─────────▼────────┐   ┌────────▼──────────┐\n│     │ SimpleProcess    │   │  PoolProcess      │\n│     │    Manager       │   │   Manager         │\n│     │  (Start Here)    │   │  (Future)         │\n│     └──────────────────┘   └───────────────────┘\n│                                         │\n└─────────────────────────────────────────┘\n```\n\n## Core Types\n\n### ManagedProcess\nRepresents a single Claude Code process instance with its lifecycle state.\n\n```typescript\ninterface ManagedProcess {\n  // Identity\n  id: string;                    // Unique process ID\n  pid: number;                   // OS process ID\n  \n  // Lifecycle\n  status: ProcessStatus;\n  spawnedAt: Date;\n  lastActivity: Date;\n  exitCode: number | null;\n  signal: string | null;\n  \n  // Resources\n  process: ChildProcess;         // Node.js child process handle\n  streams: {\n    stdout: Readable;\n    stderr: Readable;\n    stdin: Writable;\n  };\n  \n  // Metrics\n  metrics: {\n    totalDuration: number;       // milliseconds\n    tasksCompleted: number;\n    successRate: number;\n  };\n}\n\ntype ProcessStatus = \n  | 'spawning'     // Being created\n  | 'idle'         // Ready for work (pool only)\n  | 'busy'         // Executing task\n  | 'terminating'  // Shutting down\n  | 'crashed'      // Exited unexpectedly\n  | 'completed';   // Exited normally\n```\n\n### ProcessConfig\nConfiguration for spawning Claude Code processes.\n\n```typescript\ninterface ProcessConfig {\n  // Claude Code CLI path\n  claudePath: string;            // Default: 'claude'\n  \n  // Working directory\n  workDir: string;\n  \n  // Claude Code CLI arguments\n  args: {\n    print: boolean;              // --print (non-interactive)\n    outputFormat: 'stream-json' | 'json' | 'text';\n    dangerouslySkipPermissions: boolean;\n    permissionMode?: string;\n  };\n  \n  // Environment variables\n  env?: Record<string, string>;\n  \n  // Timeouts\n  timeout?: number;              // Max execution time (ms)\n  idleTimeout?: number;          // Max idle time before cleanup (pool only)\n  \n  // Retry configuration\n  retry?: {\n    maxAttempts: number;\n    backoffMs: number;\n  };\n}\n```\n\n## IProcessManager Interface\n\nThe core abstraction that all process managers implement.\n\n```typescript\ninterface IProcessManager {\n  // Process lifecycle\n  acquireProcess(config: ProcessConfig): Promise<ManagedProcess>;\n  releaseProcess(processId: string): Promise<void>;\n  terminateProcess(processId: string, signal?: NodeJS.Signals): Promise<void>;\n  \n  // Process communication\n  sendInput(processId: string, input: string): Promise<void>;\n  onOutput(processId: string, handler: OutputHandler): void;\n  onError(processId: string, handler: ErrorHandler): void;\n  \n  // Monitoring\n  getProcess(processId: string): ManagedProcess | null;\n  getActiveProcesses(): ManagedProcess[];\n  getMetrics(): ProcessMetrics;\n  \n  // Cleanup\n  shutdown(): Promise<void>;\n}\n\ntype OutputHandler = (data: Buffer, type: 'stdout' | 'stderr') => void;\ntype ErrorHandler = (error: Error) => void;\n\ninterface ProcessMetrics {\n  totalSpawned: number;\n  currentlyActive: number;\n  totalCompleted: number;\n  totalFailed: number;\n  averageDuration: number;\n}\n```\n\n## SimpleProcessManager Implementation\n\nStart with this simple, production-ready implementation based on claude-flow's pattern.\n\n### Key Features\n\n1. **One Process Per Task**: Spawn fresh process for each task\n2. **Event-Based I/O**: Stream stdout/stderr in real-time\n3. **Graceful Termination**: SIGTERM → wait → SIGKILL if needed\n4. **Automatic Cleanup**: Remove completed processes from tracking\n5. **Error Handling**: Capture spawn errors, exit codes, crashes\n\n### Implementation Pattern\n\n```typescript\nclass SimpleProcessManager implements IProcessManager {\n  private activeProcesses = new Map<string, ManagedProcess>();\n  private metrics: ProcessMetrics = {\n    totalSpawned: 0,\n    currentlyActive: 0,\n    totalCompleted: 0,\n    totalFailed: 0,\n    averageDuration: 0,\n  };\n\n  constructor(\n    private defaultConfig: Partial<ProcessConfig> = {}\n  ) {}\n\n  async acquireProcess(config: ProcessConfig): Promise<ManagedProcess> {\n    const mergedConfig = { ...this.defaultConfig, ...config };\n    const process = await this.spawnClaudeProcess(mergedConfig);\n    \n    if (!process.pid) {\n      throw new Error('Failed to spawn Claude Code process');\n    }\n\n    const managed: ManagedProcess = {\n      id: generateId('process'),\n      pid: process.pid,\n      status: 'busy',\n      spawnedAt: new Date(),\n      lastActivity: new Date(),\n      exitCode: null,\n      signal: null,\n      process,\n      streams: {\n        stdout: process.stdout!,\n        stderr: process.stderr!,\n        stdin: process.stdin!,\n      },\n      metrics: {\n        totalDuration: 0,\n        tasksCompleted: 0,\n        successRate: 1.0,\n      },\n    };\n\n    this.setupProcessHandlers(managed, config);\n    this.activeProcesses.set(managed.id, managed);\n    this.metrics.totalSpawned++;\n    this.metrics.currentlyActive++;\n\n    return managed;\n  }\n\n  private async spawnClaudeProcess(config: ProcessConfig): Promise<ChildProcess> {\n    const args = this.buildClaudeArgs(config);\n\n    const process = spawn(config.claudePath, args, {\n      cwd: config.workDir,\n      stdio: ['pipe', 'pipe', 'pipe'],\n      env: {\n        ...process.env,\n        ...config.env,\n      },\n    });\n\n    return process;\n  }\n\n  private buildClaudeArgs(config: ProcessConfig): string[] {\n    const args: string[] = [];\n\n    if (config.args.print) {\n      args.push('--print');\n    }\n\n    if (config.args.outputFormat) {\n      args.push('--output-format', config.args.outputFormat);\n    }\n\n    if (config.args.dangerouslySkipPermissions) {\n      args.push('--dangerously-skip-permissions');\n    }\n\n    if (config.args.permissionMode) {\n      args.push('--permission-mode', config.args.permissionMode);\n    }\n\n    return args;\n  }\n\n  private setupProcessHandlers(managed: ManagedProcess, config: ProcessConfig): void {\n    const { process } = managed;\n    let timeoutHandle: NodeJS.Timeout | null = null;\n\n    // Set timeout if configured\n    if (config.timeout) {\n      timeoutHandle = setTimeout(() => {\n        this.terminateProcess(managed.id, 'SIGTERM');\n      }, config.timeout);\n    }\n\n    // Handle exit\n    process.on('exit', (code, signal) => {\n      if (timeoutHandle) clearTimeout(timeoutHandle);\n\n      managed.exitCode = code;\n      managed.signal = signal;\n      managed.status = code === 0 ? 'completed' : 'crashed';\n\n      const duration = Date.now() - managed.spawnedAt.getTime();\n      managed.metrics.totalDuration = duration;\n\n      // Update global metrics\n      this.metrics.currentlyActive--;\n      if (code === 0) {\n        this.metrics.totalCompleted++;\n      } else {\n        this.metrics.totalFailed++;\n      }\n\n      // Clean up after delay\n      setTimeout(() => {\n        this.activeProcesses.delete(managed.id);\n      }, 5000);\n    });\n\n    // Handle spawn errors\n    process.on('error', (error) => {\n      if (timeoutHandle) clearTimeout(timeoutHandle);\n      \n      managed.status = 'crashed';\n      this.metrics.currentlyActive--;\n      this.metrics.totalFailed++;\n    });\n\n    // Update activity on I/O\n    process.stdout?.on('data', () => {\n      managed.lastActivity = new Date();\n    });\n  }\n\n  async sendInput(processId: string, input: string): Promise<void> {\n    const managed = this.activeProcesses.get(processId);\n    if (!managed) {\n      throw new Error(`Process ${processId} not found`);\n    }\n\n    return new Promise((resolve, reject) => {\n      managed.streams.stdin.write(input, (error) => {\n        if (error) reject(error);\n        else resolve();\n      });\n    });\n  }\n\n  onOutput(processId: string, handler: OutputHandler): void {\n    const managed = this.activeProcesses.get(processId);\n    if (!managed) return;\n\n    managed.streams.stdout.on('data', (data: Buffer) => {\n      handler(data, 'stdout');\n    });\n\n    managed.streams.stderr.on('data', (data: Buffer) => {\n      handler(data, 'stderr');\n    });\n  }\n\n  async terminateProcess(\n    processId: string, \n    signal: NodeJS.Signals = 'SIGTERM'\n  ): Promise<void> {\n    const managed = this.activeProcesses.get(processId);\n    if (!managed) return;\n\n    managed.status = 'terminating';\n\n    // Try graceful shutdown first\n    managed.process.kill(signal);\n\n    // Wait for graceful shutdown\n    await new Promise(resolve => setTimeout(resolve, 2000));\n\n    // Force kill if still running\n    if (!managed.process.killed && managed.exitCode === null) {\n      managed.process.kill('SIGKILL');\n    }\n  }\n\n  async releaseProcess(processId: string): Promise<void> {\n    await this.terminateProcess(processId);\n  }\n\n  getProcess(processId: string): ManagedProcess | null {\n    return this.activeProcesses.get(processId) || null;\n  }\n\n  getActiveProcesses(): ManagedProcess[] {\n    return Array.from(this.activeProcesses.values());\n  }\n\n  getMetrics(): ProcessMetrics {\n    return { ...this.metrics };\n  }\n\n  async shutdown(): Promise<void> {\n    const processes = Array.from(this.activeProcesses.keys());\n    await Promise.all(\n      processes.map(id => this.terminateProcess(id, 'SIGTERM'))\n    );\n  }\n}\n```\n\n## Usage Example\n\n```typescript\n// Initialize manager\nconst processManager = new SimpleProcessManager({\n  claudePath: 'claude',\n  args: {\n    print: true,\n    outputFormat: 'stream-json',\n    dangerouslySkipPermissions: true,\n  },\n});\n\n// Spawn process\nconst process = await processManager.acquireProcess({\n  claudePath: 'claude',\n  workDir: '/path/to/project',\n  args: {\n    print: true,\n    outputFormat: 'stream-json',\n    dangerouslySkipPermissions: true,\n  },\n  timeout: 300000, // 5 minutes\n});\n\n// Send input\nawait processManager.sendInput(process.id, 'Fix the bug in auth.ts\\n');\n\n// Listen to output\nprocessManager.onOutput(process.id, (data, type) => {\n  console.log(`[${type}]`, data.toString());\n});\n\n// Clean up\nawait processManager.releaseProcess(process.id);\n```\n\n## Testing Strategy\n\n### Unit Tests\n\n1. **Process spawning**\n   - Spawns with correct arguments\n   - Sets working directory\n   - Passes environment variables\n\n2. **Lifecycle management**\n   - Tracks process status correctly\n   - Updates metrics on exit\n   - Cleans up resources\n\n3. **I/O handling**\n   - Sends input to stdin\n   - Receives stdout/stderr\n   - Handles stream errors\n\n4. **Termination**\n   - Graceful shutdown (SIGTERM)\n   - Force kill after timeout\n   - Cleans up after termination\n\n### Integration Tests\n\n1. **End-to-end execution**\n   - Spawn → send prompt → receive output → terminate\n   - Multiple concurrent processes\n   - Process crash recovery\n\n2. **Error scenarios**\n   - Invalid claude path\n   - Process spawn failure\n   - Timeout handling\n\n## Future Enhancements\n\n### Path to Pool-Based Strategy\n\nThe interface design makes it easy to add pooling later:\n\n```typescript\nclass PoolProcessManager implements IProcessManager {\n  private pool: ManagedProcess[] = [];\n  private maxPoolSize: number;\n  private minIdleProcesses: number;\n\n  async acquireProcess(config: ProcessConfig): Promise<ManagedProcess> {\n    // Try to get idle process from pool\n    const idle = this.pool.find(p => p.status === 'idle');\n    \n    if (idle) {\n      idle.status = 'busy';\n      return idle;\n    }\n\n    // Create new if under limit\n    if (this.pool.length < this.maxPoolSize) {\n      return this.createAndAddToPool(config);\n    }\n\n    // Wait for available process\n    return this.waitForAvailableProcess(config);\n  }\n\n  async releaseProcess(processId: string): Promise<void> {\n    const process = this.pool.find(p => p.id === processId);\n    if (process) {\n      process.status = 'idle';\n      process.metrics.tasksCompleted++;\n    }\n  }\n\n  // ... pool management logic\n}\n```\n\n### Other Future Features\n\n1. **Process health checks** - Ping processes periodically\n2. **Automatic restarts** - Restart crashed processes in pool\n3. **Resource limits** - Memory/CPU monitoring\n4. **Process affinity** - Pin processes to specific tasks/users\n\n## File Structure\n\n```\nserver/src/execution/process/\n├── types.ts                    # Core types and interfaces\n├── manager.ts                  # IProcessManager interface\n├── simple-manager.ts           # SimpleProcessManager (start here)\n├── pool-manager.ts             # PoolProcessManager (future)\n└── utils.ts                    # Helper functions\n```\n\n## Implementation Checklist\n\n- [ ] Define core types in types.ts\n- [ ] Define IProcessManager interface\n- [ ] Implement SimpleProcessManager\n- [ ] Add process spawning with child_process\n- [ ] Add event handlers for exit, error, I/O\n- [ ] Add graceful termination (SIGTERM → SIGKILL)\n- [ ] Add metrics tracking\n- [ ] Write unit tests for process lifecycle\n- [ ] Write integration tests for end-to-end flow\n- [ ] Document usage examples\n\n## Related Specs\n\n- Execution System (parent spec)\n- Next: Engine Layer (Layer 2) - Multi-agent task execution","priority":0,"archived":0,"archived_at":null,"created_at":"2025-10-28 07:34:44","updated_at":"2025-10-28 07:34:44","parent_id":null,"relationships":[],"tags":["execution","infrastructure","layer-1","process-management"]}
{"id":"SPEC-004","uuid":"7c8ba15b-95d6-40e1-bf1f-e4305e5ddd80","title":"Engine Layer - Multi-Agent Task Execution","file_path":"specs/engine_layer_multi_agent_task_execution.md","content":"# Engine Layer Specification\n\n## Overview\n\nThe Engine Layer (Layer 2) manages multiple Claude Code agents to execute tasks concurrently. It sits above the Process Layer and provides task queueing, capacity management, and result collection.\n\n## Design Goals\n\n1. **Simple First**: Start with queue-based task distribution\n2. **Capacity Control**: Prevent resource exhaustion with configurable limits\n3. **Fair Scheduling**: FIFO queue with optional priority support\n4. **Observable**: Expose task progress and engine metrics\n5. **Upgradeable**: Easy path to intelligent agent pooling\n\n## Architecture\n\nBased on Execution System spec and [[SPEC-003]] (Process Layer).\n\n```\n┌─────────────────────────────────────────────────┐\n│         Engine Layer (Layer 2)                  │\n├─────────────────────────────────────────────────┤\n│                                                 │\n│  ┌──────────────────────────────────────────┐  │\n│  │      IExecutionEngine (Interface)        │  │\n│  └────────────┬─────────────────────────────┘  │\n│               │                                 │\n│               ├──────────────────────────────┐  │\n│               │                              │  │\n│     ┌─────────▼────────┐         ┌──────────▼─────────┐\n│     │  SimpleEngine    │         │   PoolEngine       │\n│     │  (Start Here)    │         │   (Future)         │\n│     └────────┬─────────┘         └────────────────────┘\n│              │                                  │\n│              ▼                                  │\n│     ┌─────────────────┐                        │\n│     │   Task Queue    │                        │\n│     │   (FIFO/Prio)   │                        │\n│     └────────┬────────┘                        │\n│              │                                  │\n│              ▼                                  │\n│     ┌─────────────────┐                        │\n│     │ Process Manager │◄───────────────────────┘\n│     │  (Layer 1)      │                        │\n│     └─────────────────┘                        │\n│                                                 │\n└─────────────────────────────────────────────────┘\n```\n\n## Core Types\n\n### ExecutionTask\nRepresents a unit of work to be executed by a Claude Code agent.\n\n```typescript\ninterface ExecutionTask {\n  // Identity\n  id: string;\n  type: 'issue' | 'spec' | 'custom';\n  entityId?: string;              // Issue/spec ID if applicable\n  \n  // Execution context\n  prompt: string;                 // What to send to Claude\n  workDir: string;                // Where to execute\n  \n  // Scheduling\n  priority: number;               // 0 = highest\n  dependencies: string[];         // Task IDs that must complete first\n  createdAt: Date;\n  \n  // Configuration\n  config: {\n    timeout?: number;             // Max duration (ms)\n    maxRetries?: number;          // Retry attempts\n    env?: Record<string, string>; // Environment variables\n  };\n  \n  // Metadata\n  metadata?: Record<string, any>; // Custom data\n}\n```\n\n### ExecutionResult\nThe outcome of executing a task.\n\n```typescript\ninterface ExecutionResult {\n  // Identity\n  taskId: string;\n  executionId: string;            // Process ID that ran it\n  \n  // Outcome\n  success: boolean;\n  exitCode: number;\n  \n  // Output\n  output: string;                 // stdout\n  error?: string;                 // stderr or error message\n  \n  // Timing\n  startedAt: Date;\n  completedAt: Date;\n  duration: number;               // milliseconds\n  \n  // Parsed data (from stream-json)\n  metadata?: {\n    toolsUsed?: string[];\n    filesChanged?: string[];\n    tokensUsed?: number;\n    cost?: number;\n  };\n}\n```\n\n### EngineMetrics\nReal-time engine performance statistics.\n\n```typescript\ninterface EngineMetrics {\n  // Capacity\n  maxConcurrent: number;\n  currentlyRunning: number;\n  availableSlots: number;\n  \n  // Queue\n  queuedTasks: number;\n  completedTasks: number;\n  failedTasks: number;\n  \n  // Performance\n  averageDuration: number;        // ms\n  successRate: number;            // 0-1\n  throughput: number;             // tasks/minute\n  \n  // Resources\n  totalProcessesSpawned: number;\n  activeProcesses: number;\n}\n```\n\n## IExecutionEngine Interface\n\nThe core abstraction for task execution engines.\n\n```typescript\ninterface IExecutionEngine {\n  // Task submission\n  submitTask(task: ExecutionTask): Promise<string>; // Returns task ID\n  submitTasks(tasks: ExecutionTask[]): Promise<string[]>;\n  \n  // Task control\n  cancelTask(taskId: string): Promise<void>;\n  getTaskStatus(taskId: string): TaskStatus | null;\n  \n  // Execution\n  waitForTask(taskId: string): Promise<ExecutionResult>;\n  waitForTasks(taskIds: string[]): Promise<ExecutionResult[]>;\n  \n  // Monitoring\n  getMetrics(): EngineMetrics;\n  onTaskComplete(handler: TaskCompleteHandler): void;\n  onTaskFailed(handler: TaskFailedHandler): void;\n  \n  // Lifecycle\n  shutdown(): Promise<void>;\n}\n\ntype TaskStatus = \n  | { state: 'queued'; position: number }\n  | { state: 'running'; processId: string; startedAt: Date }\n  | { state: 'completed'; result: ExecutionResult }\n  | { state: 'failed'; error: string }\n  | { state: 'cancelled'; cancelledAt: Date };\n\ntype TaskCompleteHandler = (result: ExecutionResult) => void;\ntype TaskFailedHandler = (taskId: string, error: Error) => void;\n```\n\n## SimpleExecutionEngine Implementation\n\nQueue-based engine that spawns a process per task, with concurrency limits.\n\n### Key Features\n\n1. **FIFO Queue**: Tasks execute in submission order\n2. **Concurrency Limit**: Max N simultaneous processes\n3. **Automatic Retry**: Optional retry on failure\n4. **Event Emission**: Notify on task completion/failure\n5. **Graceful Shutdown**: Wait for running tasks or force terminate\n\n### Implementation Pattern\n\n```typescript\nclass SimpleExecutionEngine implements IExecutionEngine {\n  private taskQueue: ExecutionTask[] = [];\n  private runningTasks = new Map<string, RunningTask>();\n  private completedResults = new Map<string, ExecutionResult>();\n  private taskResolvers = new Map<string, TaskResolver>();\n  \n  private metrics: EngineMetrics;\n  private completeHandlers: TaskCompleteHandler[] = [];\n  private failedHandlers: TaskFailedHandler[] = [];\n  \n  constructor(\n    private processManager: IProcessManager,\n    private config: EngineConfig = {}\n  ) {\n    this.metrics = {\n      maxConcurrent: config.maxConcurrent || 3,\n      currentlyRunning: 0,\n      availableSlots: config.maxConcurrent || 3,\n      queuedTasks: 0,\n      completedTasks: 0,\n      failedTasks: 0,\n      averageDuration: 0,\n      successRate: 1.0,\n      throughput: 0,\n      totalProcessesSpawned: 0,\n      activeProcesses: 0,\n    };\n  }\n\n  async submitTask(task: ExecutionTask): Promise<string> {\n    // Add to queue\n    this.taskQueue.push(task);\n    this.metrics.queuedTasks++;\n    \n    // Try to start immediately if capacity available\n    this.processQueue();\n    \n    return task.id;\n  }\n\n  async submitTasks(tasks: ExecutionTask[]): Promise<string[]> {\n    const ids: string[] = [];\n    for (const task of tasks) {\n      const id = await this.submitTask(task);\n      ids.push(id);\n    }\n    return ids;\n  }\n\n  private async processQueue(): Promise<void> {\n    // Check if we have capacity\n    while (\n      this.taskQueue.length > 0 &&\n      this.runningTasks.size < this.metrics.maxConcurrent\n    ) {\n      const task = this.taskQueue.shift()!;\n      this.metrics.queuedTasks--;\n      \n      // Check dependencies\n      if (!this.areDependenciesMet(task)) {\n        // Re-queue at end\n        this.taskQueue.push(task);\n        this.metrics.queuedTasks++;\n        break; // Stop processing to avoid infinite loop\n      }\n      \n      // Start execution\n      this.executeTask(task).catch(error => {\n        this.handleTaskFailure(task.id, error);\n      });\n    }\n  }\n\n  private areDependenciesMet(task: ExecutionTask): boolean {\n    for (const depId of task.dependencies) {\n      const result = this.completedResults.get(depId);\n      if (!result || !result.success) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private async executeTask(task: ExecutionTask): Promise<void> {\n    const startTime = Date.now();\n    \n    try {\n      // Acquire process\n      const process = await this.processManager.acquireProcess({\n        claudePath: this.config.claudePath || 'claude',\n        workDir: task.workDir,\n        args: {\n          print: true,\n          outputFormat: 'stream-json',\n          dangerouslySkipPermissions: true,\n          permissionMode: 'bypassPermissions',\n        },\n        env: task.config.env,\n        timeout: task.config.timeout,\n      });\n\n      this.metrics.totalProcessesSpawned++;\n      this.metrics.currentlyRunning++;\n      this.metrics.activeProcesses++;\n      this.metrics.availableSlots--;\n\n      // Track running task\n      const running: RunningTask = {\n        task,\n        process,\n        startedAt: new Date(),\n        attempt: 1,\n      };\n      this.runningTasks.set(task.id, running);\n\n      // Send prompt\n      await this.processManager.sendInput(process.id, task.prompt);\n      \n      // Collect output\n      let outputBuffer = '';\n      let errorBuffer = '';\n      \n      this.processManager.onOutput(process.id, (data, type) => {\n        if (type === 'stdout') {\n          outputBuffer += data.toString();\n        } else {\n          errorBuffer += data.toString();\n        }\n      });\n\n      // Wait for completion\n      await this.waitForProcessExit(process);\n\n      const duration = Date.now() - startTime;\n      \n      // Build result\n      const result: ExecutionResult = {\n        taskId: task.id,\n        executionId: process.id,\n        success: process.exitCode === 0,\n        exitCode: process.exitCode || 0,\n        output: outputBuffer,\n        error: process.exitCode !== 0 ? errorBuffer : undefined,\n        startedAt: running.startedAt,\n        completedAt: new Date(),\n        duration,\n        metadata: this.parseMetadata(outputBuffer),\n      };\n\n      // Handle result\n      if (result.success) {\n        this.handleTaskSuccess(task.id, result);\n      } else {\n        // Retry if configured\n        if (\n          task.config.maxRetries &&\n          running.attempt < task.config.maxRetries\n        ) {\n          running.attempt++;\n          this.taskQueue.unshift(task); // Priority re-queue\n          this.metrics.queuedTasks++;\n        } else {\n          this.handleTaskFailure(\n            task.id,\n            new Error(result.error || 'Task failed')\n          );\n        }\n      }\n\n      // Clean up\n      this.runningTasks.delete(task.id);\n      await this.processManager.releaseProcess(process.id);\n      \n      this.metrics.currentlyRunning--;\n      this.metrics.activeProcesses--;\n      this.metrics.availableSlots++;\n\n      // Process next queued task\n      this.processQueue();\n      \n    } catch (error) {\n      this.metrics.currentlyRunning--;\n      this.metrics.activeProcesses--;\n      this.metrics.availableSlots++;\n      this.runningTasks.delete(task.id);\n      \n      throw error;\n    }\n  }\n\n  private async waitForProcessExit(process: ManagedProcess): Promise<void> {\n    return new Promise((resolve) => {\n      const checkInterval = setInterval(() => {\n        if (\n          process.status === 'completed' ||\n          process.status === 'crashed' ||\n          process.status === 'terminated'\n        ) {\n          clearInterval(checkInterval);\n          resolve();\n        }\n      }, 100);\n    });\n  }\n\n  private parseMetadata(output: string): ExecutionResult['metadata'] {\n    // Parse stream-json output for metadata\n    const metadata: ExecutionResult['metadata'] = {\n      toolsUsed: [],\n      filesChanged: [],\n      tokensUsed: 0,\n      cost: 0,\n    };\n\n    const lines = output.split('\\n');\n    for (const line of lines) {\n      if (!line.trim()) continue;\n      \n      try {\n        const json = JSON.parse(line);\n        \n        // Extract tool usage\n        if (json.type === 'assistant' && json.message?.content) {\n          for (const content of json.message.content) {\n            if (content.type === 'tool_use') {\n              metadata.toolsUsed?.push(content.name);\n              \n              // Track file changes\n              if (\n                content.name === 'Write' ||\n                content.name === 'Edit'\n              ) {\n                metadata.filesChanged?.push(content.input.file_path);\n              }\n            }\n          }\n        }\n        \n        // Extract usage stats\n        if (json.type === 'result' && json.usage) {\n          metadata.tokensUsed = json.usage.total_tokens || 0;\n        }\n      } catch {\n        // Not JSON, skip\n      }\n    }\n\n    return metadata;\n  }\n\n  private handleTaskSuccess(taskId: string, result: ExecutionResult): void {\n    this.completedResults.set(taskId, result);\n    this.metrics.completedTasks++;\n    \n    // Update averages\n    this.updateMetrics(result.duration, true);\n    \n    // Resolve promise\n    const resolver = this.taskResolvers.get(taskId);\n    if (resolver) {\n      resolver.resolve(result);\n      this.taskResolvers.delete(taskId);\n    }\n    \n    // Emit event\n    for (const handler of this.completeHandlers) {\n      handler(result);\n    }\n  }\n\n  private handleTaskFailure(taskId: string, error: Error): void {\n    this.metrics.failedTasks++;\n    this.updateMetrics(0, false);\n    \n    // Resolve promise with error\n    const resolver = this.taskResolvers.get(taskId);\n    if (resolver) {\n      resolver.reject(error);\n      this.taskResolvers.delete(taskId);\n    }\n    \n    // Emit event\n    for (const handler of this.failedHandlers) {\n      handler(taskId, error);\n    }\n  }\n\n  private updateMetrics(duration: number, success: boolean): void {\n    const total = this.metrics.completedTasks + this.metrics.failedTasks;\n    \n    // Update average duration\n    this.metrics.averageDuration = \n      (this.metrics.averageDuration * (total - 1) + duration) / total;\n    \n    // Update success rate\n    this.metrics.successRate = this.metrics.completedTasks / total;\n  }\n\n  async waitForTask(taskId: string): Promise<ExecutionResult> {\n    // Check if already completed\n    const existing = this.completedResults.get(taskId);\n    if (existing) return existing;\n    \n    // Wait for completion\n    return new Promise((resolve, reject) => {\n      this.taskResolvers.set(taskId, { resolve, reject });\n    });\n  }\n\n  async waitForTasks(taskIds: string[]): Promise<ExecutionResult[]> {\n    return Promise.all(taskIds.map(id => this.waitForTask(id)));\n  }\n\n  async cancelTask(taskId: string): Promise<void> {\n    // Remove from queue\n    const queueIndex = this.taskQueue.findIndex(t => t.id === taskId);\n    if (queueIndex >= 0) {\n      this.taskQueue.splice(queueIndex, 1);\n      this.metrics.queuedTasks--;\n      return;\n    }\n    \n    // Stop running task\n    const running = this.runningTasks.get(taskId);\n    if (running) {\n      await this.processManager.terminateProcess(running.process.id);\n      this.runningTasks.delete(taskId);\n      this.metrics.currentlyRunning--;\n    }\n  }\n\n  getTaskStatus(taskId: string): TaskStatus | null {\n    // Check completed\n    const result = this.completedResults.get(taskId);\n    if (result) {\n      return { state: 'completed', result };\n    }\n    \n    // Check running\n    const running = this.runningTasks.get(taskId);\n    if (running) {\n      return {\n        state: 'running',\n        processId: running.process.id,\n        startedAt: running.startedAt,\n      };\n    }\n    \n    // Check queued\n    const queuePos = this.taskQueue.findIndex(t => t.id === taskId);\n    if (queuePos >= 0) {\n      return { state: 'queued', position: queuePos };\n    }\n    \n    return null;\n  }\n\n  getMetrics(): EngineMetrics {\n    return { ...this.metrics };\n  }\n\n  onTaskComplete(handler: TaskCompleteHandler): void {\n    this.completeHandlers.push(handler);\n  }\n\n  onTaskFailed(handler: TaskFailedHandler): void {\n    this.failedHandlers.push(handler);\n  }\n\n  async shutdown(): Promise<void> {\n    // Stop accepting new tasks\n    this.taskQueue = [];\n    \n    // Wait for running tasks or force terminate\n    const runningIds = Array.from(this.runningTasks.keys());\n    for (const taskId of runningIds) {\n      await this.cancelTask(taskId);\n    }\n    \n    // Shutdown process manager\n    await this.processManager.shutdown();\n  }\n}\n\ninterface EngineConfig {\n  maxConcurrent?: number;\n  claudePath?: string;\n}\n\ninterface RunningTask {\n  task: ExecutionTask;\n  process: ManagedProcess;\n  startedAt: Date;\n  attempt: number;\n}\n\ninterface TaskResolver {\n  resolve: (result: ExecutionResult) => void;\n  reject: (error: Error) => void;\n}\n```\n\n## Usage Example\n\n```typescript\n// Initialize engine with process manager\nconst processManager = new SimpleProcessManager();\nconst engine = new SimpleExecutionEngine(processManager, {\n  maxConcurrent: 5,\n  claudePath: 'claude',\n});\n\n// Listen to completion events\nengine.onTaskComplete((result) => {\n  console.log(`Task ${result.taskId} completed in ${result.duration}ms`);\n  console.log(`Files changed:`, result.metadata?.filesChanged);\n});\n\n// Submit tasks\nconst task1 = {\n  id: 'task-1',\n  type: 'issue',\n  entityId: 'ISSUE-001',\n  prompt: 'Fix the authentication bug described in ISSUE-001',\n  workDir: '/path/to/project',\n  priority: 0,\n  dependencies: [],\n  createdAt: new Date(),\n  config: {\n    timeout: 300000,\n    maxRetries: 2,\n  },\n};\n\nconst taskId = await engine.submitTask(task1);\n\n// Wait for completion\nconst result = await engine.waitForTask(taskId);\nconsole.log('Success:', result.success);\n\n// Check metrics\nconst metrics = engine.getMetrics();\nconsole.log(`Queue: ${metrics.queuedTasks}, Running: ${metrics.currentlyRunning}`);\n```\n\n## Testing Strategy\n\n### Unit Tests\n\n1. **Task queueing**\n   - Tasks added to queue in order\n   - Queue processes FIFO\n   - Priority ordering (future)\n\n2. **Concurrency control**\n   - Respects maxConcurrent limit\n   - Starts next task when slot available\n   - Tracks running tasks correctly\n\n3. **Dependency resolution**\n   - Waits for dependencies before execution\n   - Handles failed dependencies\n   - Prevents circular dependencies\n\n4. **Retry logic**\n   - Retries failed tasks up to maxRetries\n   - Uses exponential backoff (future)\n   - Stops retrying after limit\n\n### Integration Tests\n\n1. **End-to-end execution**\n   - Submit → queue → execute → complete\n   - Multiple concurrent tasks\n   - Task cancellation during execution\n\n2. **Metrics tracking**\n   - Counts update correctly\n   - Averages calculate properly\n   - Throughput measured accurately\n\n## Future Enhancements\n\n### Path to Pool-Based Strategy\n\n```typescript\nclass PoolExecutionEngine implements IExecutionEngine {\n  private agentPool: AgentPool;\n  \n  async submitTask(task: ExecutionTask): Promise<string> {\n    // Get idle agent from pool or wait\n    const agent = await this.agentPool.acquire();\n    \n    // Reuse existing process\n    await agent.reset(); // Clear previous state\n    await agent.execute(task);\n    \n    // Return to pool\n    this.agentPool.release(agent);\n    \n    return task.id;\n  }\n  \n  // ... intelligent pool management\n}\n```\n\n### Other Future Features\n\n1. **Priority queue** - Higher priority tasks jump queue\n2. **Task batching** - Group similar tasks for efficiency\n3. **Smart scheduling** - Assign tasks based on agent capabilities\n4. **Resource-aware** - Consider memory/CPU before scheduling\n5. **Adaptive concurrency** - Auto-adjust limits based on load\n\n## File Structure\n\n```\nserver/src/execution/engine/\n├── types.ts                    # Core types (ExecutionTask, etc.)\n├── engine.ts                   # IExecutionEngine interface\n├── simple-engine.ts            # SimpleExecutionEngine (start here)\n├── pool-engine.ts              # PoolExecutionEngine (future)\n└── utils.ts                    # Helper functions\n```\n\n## Implementation Checklist\n\n- [ ] Define core types in types.ts\n- [ ] Define IExecutionEngine interface\n- [ ] Implement SimpleExecutionEngine\n- [ ] Add task queue (FIFO)\n- [ ] Add concurrency control\n- [ ] Add dependency resolution\n- [ ] Add retry logic\n- [ ] Add event emission\n- [ ] Integrate with Process Layer\n- [ ] Write unit tests\n- [ ] Write integration tests\n\n## Related Specs\n\n- Execution System (root spec)\n- [[SPEC-003]] - Process Layer (dependency)\n- Next: Task Execution Layer (Layer 3) - Resilience & retry","priority":0,"archived":0,"archived_at":null,"created_at":"2025-10-28 07:36:09","updated_at":"2025-10-28 07:36:09","parent_id":null,"relationships":[],"tags":["concurrency","engine","execution","layer-2","task-queue"]}
{"id":"SPEC-005","uuid":"91c92cf2-110f-4341-88f1-2b90820c769f","title":"Task Execution Layer - Resilience & Retry","file_path":"specs/task_execution_layer_resilience_retry.md","content":"# Task Execution Layer Specification\n\n## Overview\n\nThe Task Execution Layer (Layer 3) adds resilience patterns to task execution. It wraps the Engine Layer with retry logic, circuit breakers, and fault tolerance mechanisms.\n\n## Design Goals\n\n1. **Resilient**: Automatically recover from transient failures\n2. **Smart Retry**: Exponential backoff with jitter\n3. **Circuit Breaker**: Prevent cascading failures\n4. **Fault Isolation**: One agent failure doesn't affect others\n5. **Observable**: Track retry attempts and failure patterns\n\n## Architecture\n\nBased on Execution System spec, [[SPEC-003]] (Process Layer), and [[SPEC-004]] (Engine Layer).\n\n```\n┌──────────────────────────────────────────────────┐\n│      Task Execution Layer (Layer 3)              │\n├──────────────────────────────────────────────────┤\n│                                                  │\n│  ┌────────────────────────────────────────────┐ │\n│  │   IResilientExecutor (Interface)           │ │\n│  └────────────┬───────────────────────────────┘ │\n│               │                                  │\n│     ┌─────────▼────────────┐                    │\n│     │  ResilientExecutor   │                    │\n│     └──────────┬────────────┘                    │\n│                │                                  │\n│         ┌──────┴───────┬──────────┬──────────┐  │\n│         │              │          │          │  │\n│    ┌────▼─────┐  ┌────▼────┐ ┌──▼────┐ ┌───▼──┐│\n│    │  Retry   │  │ Circuit │ │Timeout│ │Error ││\n│    │ Handler  │  │ Breaker │ │Handler│ │Catch ││\n│    └──────────┘  └─────────┘ └───────┘ └──────┘│\n│                                                  │\n│    ┌──────────────────────────────────────────┐ │\n│    │      Execution Engine (Layer 2)          │ │\n│    └──────────────────────────────────────────┘ │\n│                                                  │\n└──────────────────────────────────────────────────┘\n```\n\n## Core Types\n\n### RetryPolicy\nConfiguration for retry behavior.\n\n```typescript\ninterface RetryPolicy {\n  // Retry limits\n  maxAttempts: number;           // Max retry attempts (0 = no retry)\n  \n  // Backoff strategy\n  backoff: {\n    type: 'exponential' | 'linear' | 'fixed';\n    baseDelayMs: number;         // Initial delay\n    maxDelayMs: number;          // Cap on delay\n    jitter: boolean;             // Add randomness to prevent thundering herd\n  };\n  \n  // Retry conditions\n  retryableErrors: string[];     // Error types to retry\n  retryableExitCodes: number[];  // Exit codes to retry\n  \n  // Circuit breaker integration\n  shouldOpenCircuit?: (error: Error, attempts: number) => boolean;\n}\n```\n\n### CircuitBreakerState\nCircuit breaker for preventing cascading failures.\n\n```typescript\ninterface CircuitBreaker {\n  // Identity\n  name: string;                  // Breaker name (e.g., 'issue-executor')\n  \n  // State\n  state: CircuitState;\n  \n  // Configuration\n  config: {\n    failureThreshold: number;    // Failures before opening (e.g., 5)\n    successThreshold: number;    // Successes to close (e.g., 2)\n    timeout: number;             // Half-open retry delay (ms)\n  };\n  \n  // Metrics\n  metrics: {\n    totalRequests: number;\n    failedRequests: number;\n    successfulRequests: number;\n    lastFailureTime?: Date;\n    lastSuccessTime?: Date;\n  };\n}\n\ntype CircuitState = 'closed' | 'open' | 'half-open';\n```\n\n### ExecutionAttempt\nRecord of a single execution attempt.\n\n```typescript\ninterface ExecutionAttempt {\n  attemptNumber: number;\n  startedAt: Date;\n  completedAt?: Date;\n  duration?: number;\n  success: boolean;\n  error?: Error;\n  exitCode?: number;\n  willRetry: boolean;\n  nextRetryAt?: Date;\n}\n```\n\n### ResilientExecutionResult\nEnhanced result with retry information.\n\n```typescript\ninterface ResilientExecutionResult extends ExecutionResult {\n  // Retry information\n  attempts: ExecutionAttempt[];\n  totalAttempts: number;\n  finalAttempt: ExecutionAttempt;\n  \n  // Failure analysis\n  failureReason?: string;\n  circuitBreakerTriggered?: boolean;\n}\n```\n\n## IResilientExecutor Interface\n\nThe core abstraction for resilient task execution.\n\n```typescript\ninterface IResilientExecutor {\n  // Execute with resilience\n  executeTask(\n    task: ExecutionTask,\n    policy?: RetryPolicy\n  ): Promise<ResilientExecutionResult>;\n  \n  executeTasks(\n    tasks: ExecutionTask[],\n    policy?: RetryPolicy\n  ): Promise<ResilientExecutionResult[]>;\n  \n  // Circuit breaker management\n  getCircuitBreaker(name: string): CircuitBreaker | null;\n  resetCircuitBreaker(name: string): void;\n  \n  // Monitoring\n  getRetryMetrics(): RetryMetrics;\n  onRetryAttempt(handler: RetryAttemptHandler): void;\n  onCircuitOpen(handler: CircuitOpenHandler): void;\n}\n\ntype RetryAttemptHandler = (\n  taskId: string,\n  attempt: ExecutionAttempt\n) => void;\n\ntype CircuitOpenHandler = (\n  circuitName: string,\n  breaker: CircuitBreaker\n) => void;\n\ninterface RetryMetrics {\n  totalRetries: number;\n  successfulRetries: number;\n  failedRetries: number;\n  averageAttemptsToSuccess: number;\n  circuitBreakers: Map<string, CircuitBreaker>;\n}\n```\n\n## ResilientExecutor Implementation\n\nWraps the execution engine with retry and circuit breaker logic.\n\n### Key Features\n\n1. **Exponential Backoff**: Delay increases exponentially (2^attempt)\n2. **Jitter**: Random delay component to prevent thundering herd\n3. **Circuit Breaker**: Per-task-type circuit breakers\n4. **Smart Retry**: Only retry transient errors\n5. **Detailed Tracking**: Record all attempts and failures\n\n### Implementation Pattern\n\n```typescript\nclass ResilientExecutor implements IResilientExecutor {\n  private circuitBreakers = new Map<string, CircuitBreaker>();\n  private retryHandlers: RetryAttemptHandler[] = [];\n  private circuitOpenHandlers: CircuitOpenHandler[] = [];\n  \n  private metrics: RetryMetrics = {\n    totalRetries: 0,\n    successfulRetries: 0,\n    failedRetries: 0,\n    averageAttemptsToSuccess: 1.0,\n    circuitBreakers: new Map(),\n  };\n  \n  constructor(\n    private engine: IExecutionEngine,\n    private defaultPolicy: RetryPolicy = DEFAULT_RETRY_POLICY\n  ) {}\n\n  async executeTask(\n    task: ExecutionTask,\n    policy?: RetryPolicy\n  ): Promise<ResilientExecutionResult> {\n    const retryPolicy = policy || this.defaultPolicy;\n    const attempts: ExecutionAttempt[] = [];\n    \n    // Get or create circuit breaker for this task type\n    const circuitBreaker = this.getOrCreateCircuitBreaker(task.type);\n    \n    // Check circuit breaker\n    if (circuitBreaker.state === 'open') {\n      if (!this.shouldAttemptHalfOpen(circuitBreaker)) {\n        throw new Error(\n          `Circuit breaker '${circuitBreaker.name}' is OPEN. ` +\n          `Too many failures. Try again later.`\n        );\n      }\n      circuitBreaker.state = 'half-open';\n    }\n    \n    // Execute with retry\n    for (let attempt = 1; attempt <= retryPolicy.maxAttempts; attempt++) {\n      const attemptRecord: ExecutionAttempt = {\n        attemptNumber: attempt,\n        startedAt: new Date(),\n        success: false,\n        willRetry: false,\n      };\n      \n      try {\n        // Submit to engine\n        const taskId = await this.engine.submitTask(task);\n        \n        // Wait for result\n        const result = await this.engine.waitForTask(taskId);\n        \n        attemptRecord.completedAt = new Date();\n        attemptRecord.duration = \n          attemptRecord.completedAt.getTime() - \n          attemptRecord.startedAt.getTime();\n        attemptRecord.success = result.success;\n        attemptRecord.exitCode = result.exitCode;\n        \n        attempts.push(attemptRecord);\n        \n        if (result.success) {\n          // Success! Record and close circuit\n          this.recordSuccess(circuitBreaker);\n          \n          return {\n            ...result,\n            attempts,\n            totalAttempts: attempt,\n            finalAttempt: attemptRecord,\n          };\n        } else {\n          // Task failed\n          attemptRecord.error = new Error(result.error || 'Task failed');\n          \n          // Check if we should retry\n          const shouldRetry = \n            attempt < retryPolicy.maxAttempts &&\n            this.isRetryable(result, retryPolicy);\n          \n          if (shouldRetry) {\n            // Calculate backoff delay\n            const delay = this.calculateBackoff(\n              attempt,\n              retryPolicy.backoff\n            );\n            \n            attemptRecord.willRetry = true;\n            attemptRecord.nextRetryAt = new Date(Date.now() + delay);\n            \n            // Emit retry event\n            for (const handler of this.retryHandlers) {\n              handler(task.id, attemptRecord);\n            }\n            \n            this.metrics.totalRetries++;\n            \n            // Wait before retry\n            await this.sleep(delay);\n          } else {\n            // No more retries\n            this.recordFailure(circuitBreaker, attemptRecord.error);\n            \n            this.metrics.failedRetries++;\n            \n            return {\n              ...result,\n              attempts,\n              totalAttempts: attempt,\n              finalAttempt: attemptRecord,\n              failureReason: attemptRecord.error.message,\n            };\n          }\n        }\n      } catch (error) {\n        // Engine-level error (spawn failure, etc.)\n        attemptRecord.completedAt = new Date();\n        attemptRecord.duration = \n          attemptRecord.completedAt.getTime() - \n          attemptRecord.startedAt.getTime();\n        attemptRecord.error = error as Error;\n        attemptRecord.success = false;\n        \n        attempts.push(attemptRecord);\n        \n        // Check if we should retry\n        const shouldRetry = \n          attempt < retryPolicy.maxAttempts &&\n          this.isErrorRetryable(error as Error, retryPolicy);\n        \n        if (shouldRetry) {\n          const delay = this.calculateBackoff(attempt, retryPolicy.backoff);\n          attemptRecord.willRetry = true;\n          attemptRecord.nextRetryAt = new Date(Date.now() + delay);\n          \n          for (const handler of this.retryHandlers) {\n            handler(task.id, attemptRecord);\n          }\n          \n          this.metrics.totalRetries++;\n          await this.sleep(delay);\n        } else {\n          this.recordFailure(circuitBreaker, error as Error);\n          this.metrics.failedRetries++;\n          \n          throw error;\n        }\n      }\n    }\n    \n    // Should never reach here, but TypeScript requires it\n    throw new Error('Max retry attempts exceeded');\n  }\n\n  async executeTasks(\n    tasks: ExecutionTask[],\n    policy?: RetryPolicy\n  ): Promise<ResilientExecutionResult[]> {\n    return Promise.all(\n      tasks.map(task => this.executeTask(task, policy))\n    );\n  }\n\n  private getOrCreateCircuitBreaker(taskType: string): CircuitBreaker {\n    let breaker = this.circuitBreakers.get(taskType);\n    \n    if (!breaker) {\n      breaker = {\n        name: taskType,\n        state: 'closed',\n        config: {\n          failureThreshold: 5,\n          successThreshold: 2,\n          timeout: 60000, // 1 minute\n        },\n        metrics: {\n          totalRequests: 0,\n          failedRequests: 0,\n          successfulRequests: 0,\n        },\n      };\n      \n      this.circuitBreakers.set(taskType, breaker);\n      this.metrics.circuitBreakers.set(taskType, breaker);\n    }\n    \n    return breaker;\n  }\n\n  private shouldAttemptHalfOpen(breaker: CircuitBreaker): boolean {\n    if (!breaker.metrics.lastFailureTime) return true;\n    \n    const timeSinceFailure = \n      Date.now() - breaker.metrics.lastFailureTime.getTime();\n    \n    return timeSinceFailure >= breaker.config.timeout;\n  }\n\n  private recordSuccess(breaker: CircuitBreaker): void {\n    breaker.metrics.totalRequests++;\n    breaker.metrics.successfulRequests++;\n    breaker.metrics.lastSuccessTime = new Date();\n    \n    if (breaker.state === 'half-open') {\n      // Count consecutive successes in half-open state\n      const recentSuccesses = this.getRecentSuccessCount(breaker);\n      if (recentSuccesses >= breaker.config.successThreshold) {\n        breaker.state = 'closed';\n        breaker.metrics.failedRequests = 0; // Reset failure count\n      }\n    }\n    \n    this.metrics.successfulRetries++;\n  }\n\n  private recordFailure(breaker: CircuitBreaker, error: Error): void {\n    breaker.metrics.totalRequests++;\n    breaker.metrics.failedRequests++;\n    breaker.metrics.lastFailureTime = new Date();\n    \n    // Check if we should open circuit\n    if (\n      breaker.state === 'closed' &&\n      breaker.metrics.failedRequests >= breaker.config.failureThreshold\n    ) {\n      breaker.state = 'open';\n      \n      // Emit circuit open event\n      for (const handler of this.circuitOpenHandlers) {\n        handler(breaker.name, breaker);\n      }\n    } else if (breaker.state === 'half-open') {\n      // Failed in half-open, back to open\n      breaker.state = 'open';\n    }\n  }\n\n  private getRecentSuccessCount(breaker: CircuitBreaker): number {\n    // In a real implementation, track recent attempts\n    // For now, simplified\n    return breaker.metrics.successfulRequests;\n  }\n\n  private calculateBackoff(\n    attempt: number,\n    config: RetryPolicy['backoff']\n  ): number {\n    let delay: number;\n    \n    switch (config.type) {\n      case 'exponential':\n        delay = config.baseDelayMs * Math.pow(2, attempt - 1);\n        break;\n      case 'linear':\n        delay = config.baseDelayMs * attempt;\n        break;\n      case 'fixed':\n        delay = config.baseDelayMs;\n        break;\n    }\n    \n    // Cap at max delay\n    delay = Math.min(delay, config.maxDelayMs);\n    \n    // Add jitter if configured\n    if (config.jitter) {\n      const jitterAmount = delay * 0.1; // 10% jitter\n      delay += Math.random() * jitterAmount - jitterAmount / 2;\n    }\n    \n    return Math.floor(delay);\n  }\n\n  private isRetryable(\n    result: ExecutionResult,\n    policy: RetryPolicy\n  ): boolean {\n    // Check exit code\n    if (\n      result.exitCode !== undefined &&\n      policy.retryableExitCodes.includes(result.exitCode)\n    ) {\n      return true;\n    }\n    \n    // Check error message\n    if (result.error) {\n      for (const retryableError of policy.retryableErrors) {\n        if (result.error.includes(retryableError)) {\n          return true;\n        }\n      }\n    }\n    \n    return false;\n  }\n\n  private isErrorRetryable(error: Error, policy: RetryPolicy): boolean {\n    for (const retryableError of policy.retryableErrors) {\n      if (error.message.includes(retryableError)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private sleep(ms: number): Promise<void> {\n    return new Promise(resolve => setTimeout(resolve, ms));\n  }\n\n  getCircuitBreaker(name: string): CircuitBreaker | null {\n    return this.circuitBreakers.get(name) || null;\n  }\n\n  resetCircuitBreaker(name: string): void {\n    const breaker = this.circuitBreakers.get(name);\n    if (breaker) {\n      breaker.state = 'closed';\n      breaker.metrics.failedRequests = 0;\n      breaker.metrics.successfulRequests = 0;\n    }\n  }\n\n  getRetryMetrics(): RetryMetrics {\n    return { ...this.metrics };\n  }\n\n  onRetryAttempt(handler: RetryAttemptHandler): void {\n    this.retryHandlers.push(handler);\n  }\n\n  onCircuitOpen(handler: CircuitOpenHandler): void {\n    this.circuitOpenHandlers.push(handler);\n  }\n}\n\n// Default retry policy\nconst DEFAULT_RETRY_POLICY: RetryPolicy = {\n  maxAttempts: 3,\n  backoff: {\n    type: 'exponential',\n    baseDelayMs: 1000,\n    maxDelayMs: 30000,\n    jitter: true,\n  },\n  retryableErrors: [\n    'ECONNREFUSED',\n    'ETIMEDOUT',\n    'ENOTFOUND',\n    'timeout',\n    'network',\n  ],\n  retryableExitCodes: [1, 137], // Generic error, SIGKILL\n};\n```\n\n## Usage Example\n\n```typescript\n// Initialize stack\nconst processManager = new SimpleProcessManager();\nconst engine = new SimpleExecutionEngine(processManager, {\n  maxConcurrent: 5,\n});\n\nconst resilientExecutor = new ResilientExecutor(engine, {\n  maxAttempts: 3,\n  backoff: {\n    type: 'exponential',\n    baseDelayMs: 1000,\n    maxDelayMs: 30000,\n    jitter: true,\n  },\n  retryableErrors: ['timeout', 'ECONNREFUSED'],\n  retryableExitCodes: [1],\n});\n\n// Listen to retry attempts\nresilientExecutor.onRetryAttempt((taskId, attempt) => {\n  console.log(\n    `Task ${taskId} attempt ${attempt.attemptNumber} failed. ` +\n    `Retrying in ${attempt.nextRetryAt}...`\n  );\n});\n\n// Listen to circuit breaker events\nresilientExecutor.onCircuitOpen((name, breaker) => {\n  console.log(\n    `Circuit breaker '${name}' opened after ` +\n    `${breaker.metrics.failedRequests} failures`\n  );\n});\n\n// Execute task with resilience\nconst task = {\n  id: 'task-1',\n  type: 'issue',\n  entityId: 'ISSUE-001',\n  prompt: 'Fix the bug',\n  workDir: '/path/to/project',\n  priority: 0,\n  dependencies: [],\n  createdAt: new Date(),\n  config: {},\n};\n\nconst result = await resilientExecutor.executeTask(task);\n\nconsole.log(`Success: ${result.success}`);\nconsole.log(`Attempts: ${result.totalAttempts}`);\nconsole.log(`Attempts:`, result.attempts);\n```\n\n## Testing Strategy\n\n### Unit Tests\n\n1. **Retry logic**\n   - Retries up to maxAttempts\n   - Calculates backoff correctly\n   - Adds jitter when configured\n   - Stops retrying on non-retryable errors\n\n2. **Circuit breaker**\n   - Opens after failure threshold\n   - Transitions to half-open after timeout\n   - Closes after success threshold\n   - Rejects requests when open\n\n3. **Backoff calculation**\n   - Exponential: 1s, 2s, 4s, 8s, 16s\n   - Linear: 1s, 2s, 3s, 4s, 5s\n   - Fixed: 1s, 1s, 1s, 1s, 1s\n   - Respects maxDelay cap\n\n### Integration Tests\n\n1. **End-to-end resilience**\n   - Task fails → retries → succeeds\n   - Circuit breaker opens → half-open → closes\n   - Multiple task types have separate breakers\n\n2. **Failure scenarios**\n   - Transient errors are retried\n   - Permanent errors fail fast\n   - Circuit breaker prevents cascading failures\n\n## Future Enhancements\n\n1. **Adaptive retry** - Adjust backoff based on load\n2. **Bulkhead pattern** - Isolate task types with separate pools\n3. **Rate limiting** - Prevent overwhelming downstream services\n4. **Retry budgets** - Limit total retry percentage\n5. **Dead letter queue** - Store permanently failed tasks\n\n## File Structure\n\n```\nserver/src/execution/resilience/\n├── types.ts                    # Core types (RetryPolicy, etc.)\n├── executor.ts                 # IResilientExecutor interface\n├── resilient-executor.ts       # ResilientExecutor implementation\n├── circuit-breaker.ts          # Circuit breaker logic\n├── retry.ts                    # Retry and backoff logic\n└── utils.ts                    # Helper functions\n```\n\n## Implementation Checklist\n\n- [ ] Define core types in types.ts\n- [ ] Define IResilientExecutor interface\n- [ ] Implement ResilientExecutor\n- [ ] Add retry logic with exponential backoff\n- [ ] Add jitter to backoff\n- [ ] Implement circuit breaker\n- [ ] Add retryable error detection\n- [ ] Add metrics tracking\n- [ ] Write unit tests for retry logic\n- [ ] Write unit tests for circuit breaker\n- [ ] Write integration tests\n\n## Related Specs\n\n- Execution System (root spec)\n- [[SPEC-003]] - Process Layer (foundation)\n- [[SPEC-004]] - Engine Layer (dependency)\n- Next: Workflow Layer (Layer 4) - Orchestration & state","priority":0,"archived":0,"archived_at":null,"created_at":"2025-10-28 07:45:43","updated_at":"2025-10-28 07:45:43","parent_id":null,"relationships":[],"tags":["circuit-breaker","execution","layer-3","resilience","retry"]}
{"id":"SPEC-006","uuid":"3d34e745-31ce-409e-b43b-9459ea4704bc","title":"Workflow Layer - Orchestration & State Management","file_path":"specs/workflow_layer_orchestration_state_management.md","content":"# Workflow Layer Specification\n\n## Overview\n\nThe Workflow Layer (Layer 4) orchestrates complex multi-step executions with state persistence, dependency management, and workflow resumption. It enables building sophisticated agent workflows that can survive crashes and resume from checkpoints.\n\n## Design Goals\n\n1. **Stateful**: Persist workflow state for crash recovery\n2. **Resumable**: Continue from last checkpoint after failure\n3. **Composable**: Build complex workflows from simple steps\n4. **Observable**: Track workflow progress in real-time\n5. **Simple First**: Start with linear workflows, upgrade to DAGs\n\n## Architecture\n\nBased on Execution System spec, [[SPEC-003]] (Process), [[SPEC-004]] (Engine), and [[SPEC-005]] (Resilience).\n\n```\n┌────────────────────────────────────────────────────┐\n│       Workflow Layer (Layer 4)                     │\n├────────────────────────────────────────────────────┤\n│                                                    │\n│  ┌──────────────────────────────────────────────┐ │\n│  │    IWorkflowOrchestrator (Interface)         │ │\n│  └──────────────┬───────────────────────────────┘ │\n│                 │                                  │\n│       ┌─────────▼──────────┐                      │\n│       │ LinearOrchestrator │                      │\n│       │  (Start Here)      │                      │\n│       └─────────┬──────────┘                      │\n│                 │                                  │\n│          ┌──────┴───────┬────────────┐            │\n│          │              │            │            │\n│     ┌────▼────┐   ┌────▼────┐  ┌───▼──────┐     │\n│     │Workflow │   │  Step   │  │  State   │     │\n│     │Executor │   │Executor │  │Persister │     │\n│     └─────────┘   └─────────┘  └──────────┘     │\n│                                                    │\n│    ┌────────────────────────────────────────────┐ │\n│    │   Resilient Executor (Layer 3)             │ │\n│    └────────────────────────────────────────────┘ │\n│                                                    │\n└────────────────────────────────────────────────────┘\n```\n\n## Core Types\n\n### WorkflowDefinition\nDefines a multi-step workflow.\n\n```typescript\ninterface WorkflowDefinition {\n  // Identity\n  id: string;\n  name: string;\n  version: string;\n  \n  // Steps\n  steps: WorkflowStep[];\n  \n  // Configuration\n  config: {\n    checkpointInterval?: number;  // Save state every N steps\n    continueOnStepFailure?: boolean;\n    timeout?: number;             // Overall workflow timeout\n  };\n  \n  // Metadata\n  metadata?: Record<string, any>;\n}\n\ninterface WorkflowStep {\n  // Identity\n  id: string;\n  name: string;\n  \n  // Task configuration\n  taskType: 'issue' | 'spec' | 'custom';\n  promptTemplate: string;         // Template with variables\n  \n  // Dependencies\n  dependsOn: string[];            // Step IDs that must complete first\n  \n  // Execution config\n  retryPolicy?: RetryPolicy;\n  timeout?: number;\n  \n  // Condition\n  condition?: (context: WorkflowContext) => boolean;\n  \n  // Output mapping\n  outputMapping?: Record<string, string>; // Map outputs to context vars\n}\n```\n\n### WorkflowExecution\nRuntime state of a workflow execution.\n\n```typescript\ninterface WorkflowExecution {\n  // Identity\n  id: string;\n  workflowId: string;\n  \n  // State\n  status: WorkflowStatus;\n  currentStep?: string;          // Currently executing step ID\n  \n  // Progress\n  completedSteps: string[];\n  failedSteps: string[];\n  skippedSteps: string[];\n  \n  // Context (variables shared across steps)\n  context: WorkflowContext;\n  \n  // Results\n  stepResults: Map<string, ExecutionResult>;\n  \n  // Timing\n  startedAt: Date;\n  completedAt?: Date;\n  lastCheckpointAt?: Date;\n  \n  // Metadata\n  metadata?: Record<string, any>;\n}\n\ntype WorkflowStatus = \n  | 'pending'\n  | 'running'\n  | 'paused'\n  | 'completed'\n  | 'failed'\n  | 'cancelled';\n\ninterface WorkflowContext {\n  // Global variables\n  variables: Record<string, any>;\n  \n  // Step outputs (accessible by step ID)\n  outputs: Record<string, any>;\n  \n  // Shared state\n  shared: Record<string, any>;\n}\n```\n\n### WorkflowCheckpoint\nSerializable checkpoint for resumption.\n\n```typescript\ninterface WorkflowCheckpoint {\n  executionId: string;\n  workflowId: string;\n  timestamp: Date;\n  \n  // State snapshot\n  execution: WorkflowExecution;\n  \n  // Next step to execute\n  nextStep?: string;\n}\n```\n\n## IWorkflowOrchestrator Interface\n\nThe core abstraction for workflow orchestration.\n\n```typescript\ninterface IWorkflowOrchestrator {\n  // Workflow execution\n  startWorkflow(\n    workflow: WorkflowDefinition,\n    initialContext?: Partial<WorkflowContext>\n  ): Promise<string>; // Returns execution ID\n  \n  resumeWorkflow(\n    checkpointId: string\n  ): Promise<string>; // Returns execution ID\n  \n  // Control\n  pauseWorkflow(executionId: string): Promise<void>;\n  cancelWorkflow(executionId: string): Promise<void>;\n  \n  // Monitoring\n  getExecution(executionId: string): WorkflowExecution | null;\n  getStepStatus(executionId: string, stepId: string): StepStatus | null;\n  \n  // Waiting\n  waitForWorkflow(executionId: string): Promise<WorkflowResult>;\n  \n  // Checkpointing\n  saveCheckpoint(executionId: string): Promise<string>; // Returns checkpoint ID\n  listCheckpoints(workflowId: string): Promise<WorkflowCheckpoint[]>;\n  \n  // Events\n  onStepComplete(handler: StepCompleteHandler): void;\n  onWorkflowComplete(handler: WorkflowCompleteHandler): void;\n  onCheckpoint(handler: CheckpointHandler): void;\n}\n\ninterface StepStatus {\n  stepId: string;\n  status: 'pending' | 'running' | 'completed' | 'failed' | 'skipped';\n  result?: ExecutionResult;\n  attempts: number;\n}\n\ninterface WorkflowResult {\n  executionId: string;\n  success: boolean;\n  completedSteps: number;\n  failedSteps: number;\n  outputs: Record<string, any>;\n  duration: number;\n}\n\ntype StepCompleteHandler = (\n  executionId: string,\n  stepId: string,\n  result: ExecutionResult\n) => void;\n\ntype WorkflowCompleteHandler = (result: WorkflowResult) => void;\n\ntype CheckpointHandler = (checkpoint: WorkflowCheckpoint) => void;\n```\n\n## LinearOrchestrator Implementation\n\nSimple linear workflow execution with checkpointing.\n\n### Key Features\n\n1. **Sequential Execution**: Steps execute in defined order\n2. **Dependency Resolution**: Wait for dependencies before executing\n3. **Context Passing**: Share data between steps via context\n4. **Checkpointing**: Save state after each step for resumption\n5. **Conditional Steps**: Skip steps based on conditions\n\n### Implementation Pattern\n\n```typescript\nclass LinearOrchestrator implements IWorkflowOrchestrator {\n  private executions = new Map<string, WorkflowExecution>();\n  private checkpoints = new Map<string, WorkflowCheckpoint>();\n  \n  private stepCompleteHandlers: StepCompleteHandler[] = [];\n  private workflowCompleteHandlers: WorkflowCompleteHandler[] = [];\n  private checkpointHandlers: CheckpointHandler[] = [];\n  \n  constructor(\n    private executor: IResilientExecutor,\n    private storage?: IWorkflowStorage\n  ) {}\n\n  async startWorkflow(\n    workflow: WorkflowDefinition,\n    initialContext?: Partial<WorkflowContext>\n  ): Promise<string> {\n    const execution: WorkflowExecution = {\n      id: generateId('execution'),\n      workflowId: workflow.id,\n      status: 'pending',\n      completedSteps: [],\n      failedSteps: [],\n      skippedSteps: [],\n      context: {\n        variables: initialContext?.variables || {},\n        outputs: {},\n        shared: {},\n      },\n      stepResults: new Map(),\n      startedAt: new Date(),\n    };\n    \n    this.executions.set(execution.id, execution);\n    \n    // Start execution in background\n    this.executeWorkflow(workflow, execution).catch(error => {\n      execution.status = 'failed';\n      execution.completedAt = new Date();\n    });\n    \n    return execution.id;\n  }\n\n  async resumeWorkflow(checkpointId: string): Promise<string> {\n    const checkpoint = this.checkpoints.get(checkpointId);\n    if (!checkpoint) {\n      throw new Error(`Checkpoint ${checkpointId} not found`);\n    }\n    \n    // Restore execution state\n    const execution = checkpoint.execution;\n    execution.status = 'pending';\n    this.executions.set(execution.id, execution);\n    \n    // Find workflow definition\n    const workflow = await this.loadWorkflowDefinition(execution.workflowId);\n    \n    // Resume from next step\n    this.executeWorkflow(workflow, execution, checkpoint.nextStep).catch(\n      error => {\n        execution.status = 'failed';\n        execution.completedAt = new Date();\n      }\n    );\n    \n    return execution.id;\n  }\n\n  private async executeWorkflow(\n    workflow: WorkflowDefinition,\n    execution: WorkflowExecution,\n    startFromStep?: string\n  ): Promise<void> {\n    execution.status = 'running';\n    \n    // Find starting point\n    let startIndex = 0;\n    if (startFromStep) {\n      startIndex = workflow.steps.findIndex(s => s.id === startFromStep);\n      if (startIndex === -1) {\n        throw new Error(`Step ${startFromStep} not found in workflow`);\n      }\n    }\n    \n    // Execute steps sequentially\n    for (let i = startIndex; i < workflow.steps.length; i++) {\n      const step = workflow.steps[i];\n      \n      // Check if paused or cancelled\n      if (execution.status === 'paused' || execution.status === 'cancelled') {\n        return;\n      }\n      \n      // Check dependencies\n      if (!this.areDependenciesMet(step, execution)) {\n        execution.failedSteps.push(step.id);\n        if (!workflow.config.continueOnStepFailure) {\n          execution.status = 'failed';\n          execution.completedAt = new Date();\n          return;\n        }\n        continue;\n      }\n      \n      // Check condition\n      if (step.condition && !step.condition(execution.context)) {\n        execution.skippedSteps.push(step.id);\n        continue;\n      }\n      \n      // Execute step\n      execution.currentStep = step.id;\n      \n      try {\n        const result = await this.executeStep(step, execution, workflow);\n        \n        execution.stepResults.set(step.id, result);\n        execution.completedSteps.push(step.id);\n        \n        // Update context with step outputs\n        if (step.outputMapping) {\n          for (const [key, path] of Object.entries(step.outputMapping)) {\n            execution.context.outputs[key] = this.extractValue(result, path);\n          }\n        }\n        \n        // Emit step complete event\n        for (const handler of this.stepCompleteHandlers) {\n          handler(execution.id, step.id, result);\n        }\n        \n        // Checkpoint if configured\n        if (\n          workflow.config.checkpointInterval &&\n          execution.completedSteps.length % workflow.config.checkpointInterval === 0\n        ) {\n          await this.saveCheckpoint(execution.id);\n        }\n      } catch (error) {\n        execution.failedSteps.push(step.id);\n        \n        if (!workflow.config.continueOnStepFailure) {\n          execution.status = 'failed';\n          execution.completedAt = new Date();\n          throw error;\n        }\n      }\n    }\n    \n    // Workflow completed\n    execution.status = 'completed';\n    execution.completedAt = new Date();\n    \n    // Emit workflow complete event\n    const result: WorkflowResult = {\n      executionId: execution.id,\n      success: execution.failedSteps.length === 0,\n      completedSteps: execution.completedSteps.length,\n      failedSteps: execution.failedSteps.length,\n      outputs: execution.context.outputs,\n      duration: execution.completedAt.getTime() - execution.startedAt.getTime(),\n    };\n    \n    for (const handler of this.workflowCompleteHandlers) {\n      handler(result);\n    }\n  }\n\n  private areDependenciesMet(\n    step: WorkflowStep,\n    execution: WorkflowExecution\n  ): boolean {\n    for (const depId of step.dependsOn) {\n      if (!execution.completedSteps.includes(depId)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private async executeStep(\n    step: WorkflowStep,\n    execution: WorkflowExecution,\n    workflow: WorkflowDefinition\n  ): Promise<ExecutionResult> {\n    // Render prompt template with context\n    const prompt = this.renderTemplate(step.promptTemplate, execution.context);\n    \n    // Build execution task\n    const task: ExecutionTask = {\n      id: generateId('task'),\n      type: step.taskType,\n      entityId: undefined,\n      prompt,\n      workDir: process.cwd(), // TODO: Make configurable\n      priority: 0,\n      dependencies: [],\n      createdAt: new Date(),\n      config: {\n        timeout: step.timeout,\n      },\n    };\n    \n    // Execute with resilience\n    return await this.executor.executeTask(task, step.retryPolicy);\n  }\n\n  private renderTemplate(\n    template: string,\n    context: WorkflowContext\n  ): string {\n    let rendered = template;\n    \n    // Replace variables: {{variable}}\n    for (const [key, value] of Object.entries(context.variables)) {\n      rendered = rendered.replace(\n        new RegExp(`{{${key}}}`, 'g'),\n        String(value)\n      );\n    }\n    \n    // Replace outputs: {{step.output}}\n    for (const [key, value] of Object.entries(context.outputs)) {\n      rendered = rendered.replace(\n        new RegExp(`{{${key}}}`, 'g'),\n        String(value)\n      );\n    }\n    \n    return rendered;\n  }\n\n  private extractValue(result: ExecutionResult, path: string): any {\n    // Simple path extraction (e.g., \"output\" or \"metadata.filesChanged\")\n    const parts = path.split('.');\n    let value: any = result;\n    \n    for (const part of parts) {\n      value = value[part];\n      if (value === undefined) break;\n    }\n    \n    return value;\n  }\n\n  async saveCheckpoint(executionId: string): Promise<string> {\n    const execution = this.executions.get(executionId);\n    if (!execution) {\n      throw new Error(`Execution ${executionId} not found`);\n    }\n    \n    const checkpoint: WorkflowCheckpoint = {\n      executionId,\n      workflowId: execution.workflowId,\n      timestamp: new Date(),\n      execution: { ...execution },\n      nextStep: execution.currentStep,\n    };\n    \n    const checkpointId = generateId('checkpoint');\n    this.checkpoints.set(checkpointId, checkpoint);\n    \n    execution.lastCheckpointAt = new Date();\n    \n    // Persist to storage if available\n    if (this.storage) {\n      await this.storage.saveCheckpoint(checkpointId, checkpoint);\n    }\n    \n    // Emit checkpoint event\n    for (const handler of this.checkpointHandlers) {\n      handler(checkpoint);\n    }\n    \n    return checkpointId;\n  }\n\n  async pauseWorkflow(executionId: string): Promise<void> {\n    const execution = this.executions.get(executionId);\n    if (execution) {\n      execution.status = 'paused';\n    }\n  }\n\n  async cancelWorkflow(executionId: string): Promise<void> {\n    const execution = this.executions.get(executionId);\n    if (execution) {\n      execution.status = 'cancelled';\n      execution.completedAt = new Date();\n    }\n  }\n\n  getExecution(executionId: string): WorkflowExecution | null {\n    return this.executions.get(executionId) || null;\n  }\n\n  getStepStatus(executionId: string, stepId: string): StepStatus | null {\n    const execution = this.executions.get(executionId);\n    if (!execution) return null;\n    \n    const result = execution.stepResults.get(stepId);\n    \n    let status: StepStatus['status'];\n    if (execution.completedSteps.includes(stepId)) {\n      status = 'completed';\n    } else if (execution.failedSteps.includes(stepId)) {\n      status = 'failed';\n    } else if (execution.skippedSteps.includes(stepId)) {\n      status = 'skipped';\n    } else if (execution.currentStep === stepId) {\n      status = 'running';\n    } else {\n      status = 'pending';\n    }\n    \n    return {\n      stepId,\n      status,\n      result,\n      attempts: 1, // TODO: Track attempts\n    };\n  }\n\n  async waitForWorkflow(executionId: string): Promise<WorkflowResult> {\n    return new Promise((resolve, reject) => {\n      const checkInterval = setInterval(() => {\n        const execution = this.executions.get(executionId);\n        if (!execution) {\n          clearInterval(checkInterval);\n          reject(new Error(`Execution ${executionId} not found`));\n          return;\n        }\n        \n        if (\n          execution.status === 'completed' ||\n          execution.status === 'failed' ||\n          execution.status === 'cancelled'\n        ) {\n          clearInterval(checkInterval);\n          \n          const result: WorkflowResult = {\n            executionId,\n            success: execution.status === 'completed',\n            completedSteps: execution.completedSteps.length,\n            failedSteps: execution.failedSteps.length,\n            outputs: execution.context.outputs,\n            duration: execution.completedAt\n              ? execution.completedAt.getTime() - execution.startedAt.getTime()\n              : 0,\n          };\n          \n          resolve(result);\n        }\n      }, 100);\n    });\n  }\n\n  async listCheckpoints(workflowId: string): Promise<WorkflowCheckpoint[]> {\n    const checkpoints: WorkflowCheckpoint[] = [];\n    \n    for (const checkpoint of this.checkpoints.values()) {\n      if (checkpoint.workflowId === workflowId) {\n        checkpoints.push(checkpoint);\n      }\n    }\n    \n    return checkpoints;\n  }\n\n  onStepComplete(handler: StepCompleteHandler): void {\n    this.stepCompleteHandlers.push(handler);\n  }\n\n  onWorkflowComplete(handler: WorkflowCompleteHandler): void {\n    this.workflowCompleteHandlers.push(handler);\n  }\n\n  onCheckpoint(handler: CheckpointHandler): void {\n    this.checkpointHandlers.push(handler);\n  }\n\n  private async loadWorkflowDefinition(\n    workflowId: string\n  ): Promise<WorkflowDefinition> {\n    // TODO: Load from storage\n    throw new Error('Not implemented');\n  }\n}\n\ninterface IWorkflowStorage {\n  saveCheckpoint(id: string, checkpoint: WorkflowCheckpoint): Promise<void>;\n  loadCheckpoint(id: string): Promise<WorkflowCheckpoint | null>;\n}\n```\n\n## Usage Example\n\n```typescript\n// Define workflow\nconst bugFixWorkflow: WorkflowDefinition = {\n  id: 'bug-fix-workflow',\n  name: 'Bug Fix and Test',\n  version: '1.0',\n  steps: [\n    {\n      id: 'analyze',\n      name: 'Analyze Issue',\n      taskType: 'issue',\n      promptTemplate: 'Analyze the bug in {{issueId}} and suggest a fix',\n      dependsOn: [],\n      outputMapping: {\n        analysis: 'output',\n      },\n    },\n    {\n      id: 'implement',\n      name: 'Implement Fix',\n      taskType: 'issue',\n      promptTemplate: 'Implement the fix for {{issueId}}. Analysis: {{analysis}}',\n      dependsOn: ['analyze'],\n      outputMapping: {\n        filesChanged: 'metadata.filesChanged',\n      },\n    },\n    {\n      id: 'test',\n      name: 'Run Tests',\n      taskType: 'custom',\n      promptTemplate: 'Run tests for files: {{filesChanged}}',\n      dependsOn: ['implement'],\n    },\n  ],\n  config: {\n    checkpointInterval: 1,\n    continueOnStepFailure: false,\n  },\n};\n\n// Execute workflow\nconst orchestrator = new LinearOrchestrator(resilientExecutor);\n\norchestrator.onStepComplete((execId, stepId, result) => {\n  console.log(`Step ${stepId} completed:`, result.success);\n});\n\nconst executionId = await orchestrator.startWorkflow(bugFixWorkflow, {\n  variables: {\n    issueId: 'ISSUE-001',\n  },\n});\n\nconst result = await orchestrator.waitForWorkflow(executionId);\nconsole.log(`Workflow completed: ${result.success}`);\nconsole.log(`Outputs:`, result.outputs);\n```\n\n## Testing Strategy\n\n### Unit Tests\n\n1. **Step execution**\n   - Executes steps in order\n   - Passes context between steps\n   - Handles step failures\n   - Skips conditional steps\n\n2. **Checkpointing**\n   - Saves checkpoint after interval\n   - Resumes from checkpoint correctly\n   - Preserves execution state\n\n3. **Template rendering**\n   - Replaces variables correctly\n   - Handles nested paths\n   - Handles missing variables\n\n### Integration Tests\n\n1. **End-to-end workflows**\n   - Multi-step workflow completes\n   - Checkpoint and resume works\n   - Context data flows correctly\n\n2. **Failure scenarios**\n   - Step failure stops workflow\n   - Resume after crash\n   - Handle partial completion\n\n## Future Enhancements\n\n1. **DAG workflows** - Parallel step execution\n2. **Conditional branches** - If/else logic\n3. **Loops** - Repeat steps until condition\n4. **Sub-workflows** - Compose workflows\n5. **Workflow versioning** - A/B testing\n\n## File Structure\n\n```\nserver/src/execution/workflow/\n├── types.ts                    # Core types (WorkflowDefinition, etc.)\n├── orchestrator.ts             # IWorkflowOrchestrator interface\n├── linear-orchestrator.ts      # LinearOrchestrator (start here)\n├── dag-orchestrator.ts         # DAGOrchestrator (future)\n├── storage.ts                  # Checkpoint persistence\n└── utils.ts                    # Template rendering, etc.\n```\n\n## Implementation Checklist\n\n- [ ] Define core types\n- [ ] Define IWorkflowOrchestrator interface\n- [ ] Implement LinearOrchestrator\n- [ ] Add sequential step execution\n- [ ] Add dependency resolution\n- [ ] Add template rendering\n- [ ] Add checkpointing\n- [ ] Add workflow resumption\n- [ ] Add conditional step execution\n- [ ] Write unit tests\n- [ ] Write integration tests\n\n## Related Specs\n\n- Execution System (root spec)\n- [[SPEC-003]] - Process Layer\n- [[SPEC-004]] - Engine Layer\n- [[SPEC-005]] - Task Execution Layer (dependency)\n- Next: Output Processing Layer (Layer 5)","priority":0,"archived":0,"archived_at":null,"created_at":"2025-10-28 07:45:45","updated_at":"2025-10-28 07:45:45","parent_id":null,"relationships":[{"from":"SPEC-006","from_type":"spec","to":"SPEC-005","to_type":"spec","type":"depends-on"}],"tags":["execution","layer-4","orchestration","state","workflow"]}
{"id":"SPEC-007","uuid":"cb9b2531-e8ce-4696-a74e-6973649ccdc7","title":"Output Processing Layer - Real-time Parsing","file_path":"specs/output_processing_layer_real_time_parsing.md","content":"# Output Processing Layer Specification\n\n## Overview\n\nThe Output Processing Layer (Layer 5) handles real-time parsing and processing of Claude Code's output. It parses stream-json format, extracts structured data, tracks progress, and provides event-driven updates.\n\n## Design Goals\n\n1. **Real-time**: Parse output as it streams, not after completion\n2. **Structured**: Extract tool calls, file changes, errors from JSON\n3. **Event-driven**: Emit events for progress tracking\n4. **Robust**: Handle malformed JSON gracefully\n5. **Flexible**: Support multiple output formats\n\n## Architecture\n\nBased on Execution System spec and all previous layers.\n\n```\n┌──────────────────────────────────────────────────┐\n│     Output Processing Layer (Layer 5)            │\n├──────────────────────────────────────────────────┤\n│                                                  │\n│  ┌────────────────────────────────────────────┐ │\n│  │   IOutputProcessor (Interface)             │ │\n│  └────────────┬───────────────────────────────┘ │\n│               │                                  │\n│     ┌─────────▼──────────┐                      │\n│     │ StreamJsonProcessor│                      │\n│     │  (Start Here)      │                      │\n│     └─────────┬──────────┘                      │\n│               │                                  │\n│        ┌──────┴──────┬──────────┬──────────┐   │\n│        │             │          │          │   │\n│   ┌────▼────┐  ┌────▼────┐ ┌──▼────┐ ┌───▼──┐│\n│   │  JSON   │  │  Event  │ │ Meta  │ │Error ││\n│   │ Parser  │  │ Emitter │ │Extract│ │Handle││\n│   └─────────┘  └─────────┘ └───────┘ └──────┘│\n│                                                  │\n│    ┌──────────────────────────────────────────┐ │\n│    │      Process Manager (Layer 1)           │ │\n│    └──────────────────────────────────────────┘ │\n│                                                  │\n└──────────────────────────────────────────────────┘\n```\n\n## Core Types\n\n### StreamMessage\nParsed message from Claude Code stream-json output.\n\n```typescript\ninterface StreamMessage {\n  type: MessageType;\n  timestamp: Date;\n  raw: string;                   // Original JSON line\n  data: any;                     // Parsed JSON\n}\n\ntype MessageType = \n  | 'user'                       // User message\n  | 'assistant'                  // Assistant message\n  | 'tool_use'                   // Tool invocation\n  | 'tool_result'                // Tool result\n  | 'result'                     // Final result with usage\n  | 'error'                      // Error message\n  | 'unknown';                   // Unparseable\n```\n\n### ToolCall\nExtracted tool call information.\n\n```typescript\ninterface ToolCall {\n  id: string;\n  name: string;\n  input: Record<string, any>;\n  timestamp: Date;\n}\n\ninterface ToolResult {\n  toolCallId: string;\n  success: boolean;\n  output?: any;\n  error?: string;\n  timestamp: Date;\n}\n```\n\n### ExecutionProgress\nReal-time execution progress.\n\n```typescript\ninterface ExecutionProgress {\n  // Basic info\n  processId: string;\n  startedAt: Date;\n  lastUpdate: Date;\n  \n  // Progress\n  toolCalls: ToolCall[];\n  toolResults: ToolResult[];\n  filesChanged: string[];\n  errors: string[];\n  \n  // Current state\n  currentActivity?: string;      // e.g., \"Reading file auth.ts\"\n  \n  // Usage\n  usage?: {\n    inputTokens: number;\n    outputTokens: number;\n    totalTokens: number;\n    cost?: number;\n  };\n}\n```\n\n### OutputProcessingOptions\nConfiguration for output processing.\n\n```typescript\ninterface OutputProcessingOptions {\n  // Format\n  format: 'stream-json' | 'json' | 'text';\n  \n  // Filtering\n  captureToolCalls?: boolean;\n  captureFileChanges?: boolean;\n  captureErrors?: boolean;\n  \n  // Events\n  emitProgressEvents?: boolean;\n  progressInterval?: number;     // ms between progress events\n  \n  // Buffering\n  maxBufferSize?: number;        // Max lines to buffer\n  lineSeparator?: string;        // Default: '\\n'\n}\n```\n\n## IOutputProcessor Interface\n\nThe core abstraction for output processing.\n\n```typescript\ninterface IOutputProcessor {\n  // Processing\n  processLine(line: string): StreamMessage | null;\n  processBuffer(buffer: string): StreamMessage[];\n  \n  // Progress tracking\n  getProgress(processId: string): ExecutionProgress | null;\n  \n  // Events\n  onToolCall(handler: ToolCallHandler): void;\n  onFileChange(handler: FileChangeHandler): void;\n  onProgress(handler: ProgressHandler): void;\n  onError(handler: ErrorHandler): void;\n  onComplete(handler: CompleteHandler): void;\n  \n  // Extraction\n  extractMetadata(messages: StreamMessage[]): ExecutionMetadata;\n  extractToolCalls(messages: StreamMessage[]): ToolCall[];\n  extractFileChanges(messages: StreamMessage[]): string[];\n}\n\ntype ToolCallHandler = (processId: string, toolCall: ToolCall) => void;\ntype FileChangeHandler = (processId: string, filePath: string) => void;\ntype ProgressHandler = (processId: string, progress: ExecutionProgress) => void;\ntype ErrorHandler = (processId: string, error: string) => void;\ntype CompleteHandler = (processId: string, metadata: ExecutionMetadata) => void;\n\ninterface ExecutionMetadata {\n  toolsUsed: string[];\n  filesChanged: string[];\n  tokensUsed: number;\n  cost: number;\n  duration: number;\n}\n```\n\n## StreamJsonProcessor Implementation\n\nParses Claude Code's stream-json format in real-time.\n\n### Key Features\n\n1. **Line-by-line parsing**: Handle incomplete JSON gracefully\n2. **Event emission**: Notify listeners on key events\n3. **Progress tracking**: Build execution progress in real-time\n4. **Metadata extraction**: Extract structured data from messages\n5. **Error handling**: Gracefully handle malformed JSON\n\n### Implementation Pattern\n\n```typescript\nclass StreamJsonProcessor implements IOutputProcessor {\n  private progressTracking = new Map<string, ExecutionProgress>();\n  \n  private toolCallHandlers: ToolCallHandler[] = [];\n  private fileChangeHandlers: FileChangeHandler[] = [];\n  private progressHandlers: ProgressHandler[] = [];\n  private errorHandlers: ErrorHandler[] = [];\n  private completeHandlers: CompleteHandler[] = [];\n  \n  private currentProcessId?: string;\n  \n  constructor(private options: OutputProcessingOptions = {}) {\n    this.options = {\n      format: 'stream-json',\n      captureToolCalls: true,\n      captureFileChanges: true,\n      captureErrors: true,\n      emitProgressEvents: true,\n      progressInterval: 1000,\n      maxBufferSize: 10000,\n      lineSeparator: '\\n',\n      ...options,\n    };\n  }\n\n  processLine(line: string): StreamMessage | null {\n    if (!line.trim()) return null;\n    \n    try {\n      const data = JSON.parse(line);\n      const message: StreamMessage = {\n        type: this.detectMessageType(data),\n        timestamp: new Date(),\n        raw: line,\n        data,\n      };\n      \n      // Process message\n      this.handleMessage(message);\n      \n      return message;\n    } catch (error) {\n      // Not valid JSON, might be plain text\n      return {\n        type: 'unknown',\n        timestamp: new Date(),\n        raw: line,\n        data: { text: line },\n      };\n    }\n  }\n\n  processBuffer(buffer: string): StreamMessage[] {\n    const lines = buffer.split(this.options.lineSeparator!);\n    const messages: StreamMessage[] = [];\n    \n    for (const line of lines) {\n      const message = this.processLine(line);\n      if (message) {\n        messages.push(message);\n      }\n    }\n    \n    return messages;\n  }\n\n  private detectMessageType(data: any): MessageType {\n    if (data.type === 'user') return 'user';\n    if (data.type === 'assistant') return 'assistant';\n    if (data.type === 'result') return 'result';\n    if (data.type === 'error') return 'error';\n    \n    // Check for tool use/result in message content\n    if (data.message?.content) {\n      const content = Array.isArray(data.message.content)\n        ? data.message.content[0]\n        : data.message.content;\n      \n      if (content.type === 'tool_use') return 'tool_use';\n      if (content.type === 'tool_result') return 'tool_result';\n    }\n    \n    return 'unknown';\n  }\n\n  private handleMessage(message: StreamMessage): void {\n    if (!this.currentProcessId) return;\n    \n    const progress = this.getOrCreateProgress(this.currentProcessId);\n    progress.lastUpdate = new Date();\n    \n    switch (message.type) {\n      case 'assistant':\n        this.handleAssistantMessage(message, progress);\n        break;\n      case 'tool_use':\n        this.handleToolUse(message, progress);\n        break;\n      case 'tool_result':\n        this.handleToolResult(message, progress);\n        break;\n      case 'result':\n        this.handleResult(message, progress);\n        break;\n      case 'error':\n        this.handleError(message, progress);\n        break;\n    }\n    \n    // Emit progress event\n    if (this.options.emitProgressEvents) {\n      this.emitProgress(this.currentProcessId, progress);\n    }\n  }\n\n  private handleAssistantMessage(\n    message: StreamMessage,\n    progress: ExecutionProgress\n  ): void {\n    const { data } = message;\n    \n    if (!data.message?.content) return;\n    \n    const contents = Array.isArray(data.message.content)\n      ? data.message.content\n      : [data.message.content];\n    \n    for (const content of contents) {\n      if (content.type === 'tool_use') {\n        const toolCall: ToolCall = {\n          id: content.id,\n          name: content.name,\n          input: content.input,\n          timestamp: message.timestamp,\n        };\n        \n        progress.toolCalls.push(toolCall);\n        \n        // Update current activity\n        progress.currentActivity = `Using tool: ${toolCall.name}`;\n        \n        // Track file changes\n        if (\n          this.options.captureFileChanges &&\n          (content.name === 'Write' || content.name === 'Edit')\n        ) {\n          const filePath = content.input.file_path;\n          if (filePath && !progress.filesChanged.includes(filePath)) {\n            progress.filesChanged.push(filePath);\n            \n            // Emit file change event\n            for (const handler of this.fileChangeHandlers) {\n              handler(progress.processId, filePath);\n            }\n          }\n        }\n        \n        // Emit tool call event\n        if (this.options.captureToolCalls) {\n          for (const handler of this.toolCallHandlers) {\n            handler(progress.processId, toolCall);\n          }\n        }\n      }\n    }\n  }\n\n  private handleToolUse(\n    message: StreamMessage,\n    progress: ExecutionProgress\n  ): void {\n    // Similar to handleAssistantMessage tool_use handling\n    const { data } = message;\n    \n    const toolCall: ToolCall = {\n      id: data.id || generateId('tool'),\n      name: data.name,\n      input: data.input,\n      timestamp: message.timestamp,\n    };\n    \n    progress.toolCalls.push(toolCall);\n    progress.currentActivity = `Using tool: ${toolCall.name}`;\n  }\n\n  private handleToolResult(\n    message: StreamMessage,\n    progress: ExecutionProgress\n  ): void {\n    const { data } = message;\n    \n    const result: ToolResult = {\n      toolCallId: data.tool_use_id || data.id,\n      success: !data.is_error,\n      output: data.content,\n      error: data.is_error ? data.content : undefined,\n      timestamp: message.timestamp,\n    };\n    \n    progress.toolResults.push(result);\n  }\n\n  private handleResult(\n    message: StreamMessage,\n    progress: ExecutionProgress\n  ): void {\n    const { data } = message;\n    \n    // Extract usage information\n    if (data.usage) {\n      progress.usage = {\n        inputTokens: data.usage.input_tokens || 0,\n        outputTokens: data.usage.output_tokens || 0,\n        totalTokens: data.usage.total_tokens || 0,\n        cost: this.calculateCost(data.usage),\n      };\n    }\n    \n    // Emit complete event\n    const metadata = this.buildMetadata(progress);\n    for (const handler of this.completeHandlers) {\n      handler(progress.processId, metadata);\n    }\n  }\n\n  private handleError(\n    message: StreamMessage,\n    progress: ExecutionProgress\n  ): void {\n    const { data } = message;\n    const error = data.error?.message || data.message || 'Unknown error';\n    \n    if (this.options.captureErrors) {\n      progress.errors.push(error);\n      \n      // Emit error event\n      for (const handler of this.errorHandlers) {\n        handler(progress.processId, error);\n      }\n    }\n  }\n\n  private getOrCreateProgress(processId: string): ExecutionProgress {\n    let progress = this.progressTracking.get(processId);\n    \n    if (!progress) {\n      progress = {\n        processId,\n        startedAt: new Date(),\n        lastUpdate: new Date(),\n        toolCalls: [],\n        toolResults: [],\n        filesChanged: [],\n        errors: [],\n      };\n      this.progressTracking.set(processId, progress);\n    }\n    \n    return progress;\n  }\n\n  private emitProgress(processId: string, progress: ExecutionProgress): void {\n    for (const handler of this.progressHandlers) {\n      handler(processId, progress);\n    }\n  }\n\n  private buildMetadata(progress: ExecutionProgress): ExecutionMetadata {\n    const toolsUsed = Array.from(\n      new Set(progress.toolCalls.map(tc => tc.name))\n    );\n    \n    const duration = progress.lastUpdate.getTime() - progress.startedAt.getTime();\n    \n    return {\n      toolsUsed,\n      filesChanged: progress.filesChanged,\n      tokensUsed: progress.usage?.totalTokens || 0,\n      cost: progress.usage?.cost || 0,\n      duration,\n    };\n  }\n\n  private calculateCost(usage: any): number {\n    // Simplified cost calculation\n    // Claude Sonnet pricing (example)\n    const inputCostPer1M = 3.00;\n    const outputCostPer1M = 15.00;\n    \n    const inputCost = (usage.input_tokens / 1000000) * inputCostPer1M;\n    const outputCost = (usage.output_tokens / 1000000) * outputCostPer1M;\n    \n    return inputCost + outputCost;\n  }\n\n  getProgress(processId: string): ExecutionProgress | null {\n    return this.progressTracking.get(processId) || null;\n  }\n\n  extractMetadata(messages: StreamMessage[]): ExecutionMetadata {\n    const toolCalls = this.extractToolCalls(messages);\n    const filesChanged = this.extractFileChanges(messages);\n    \n    let usage = { inputTokens: 0, outputTokens: 0, totalTokens: 0, cost: 0 };\n    \n    for (const message of messages) {\n      if (message.type === 'result' && message.data.usage) {\n        usage = {\n          inputTokens: message.data.usage.input_tokens || 0,\n          outputTokens: message.data.usage.output_tokens || 0,\n          totalTokens: message.data.usage.total_tokens || 0,\n          cost: this.calculateCost(message.data.usage),\n        };\n      }\n    }\n    \n    const toolsUsed = Array.from(new Set(toolCalls.map(tc => tc.name)));\n    \n    return {\n      toolsUsed,\n      filesChanged,\n      tokensUsed: usage.totalTokens,\n      cost: usage.cost,\n      duration: 0, // Would need start/end times\n    };\n  }\n\n  extractToolCalls(messages: StreamMessage[]): ToolCall[] {\n    const toolCalls: ToolCall[] = [];\n    \n    for (const message of messages) {\n      if (message.type === 'assistant' && message.data.message?.content) {\n        const contents = Array.isArray(message.data.message.content)\n          ? message.data.message.content\n          : [message.data.message.content];\n        \n        for (const content of contents) {\n          if (content.type === 'tool_use') {\n            toolCalls.push({\n              id: content.id,\n              name: content.name,\n              input: content.input,\n              timestamp: message.timestamp,\n            });\n          }\n        }\n      }\n    }\n    \n    return toolCalls;\n  }\n\n  extractFileChanges(messages: StreamMessage[]): string[] {\n    const files = new Set<string>();\n    const toolCalls = this.extractToolCalls(messages);\n    \n    for (const toolCall of toolCalls) {\n      if (toolCall.name === 'Write' || toolCall.name === 'Edit') {\n        const filePath = toolCall.input.file_path;\n        if (filePath) {\n          files.add(filePath);\n        }\n      }\n    }\n    \n    return Array.from(files);\n  }\n\n  // Event registration\n  onToolCall(handler: ToolCallHandler): void {\n    this.toolCallHandlers.push(handler);\n  }\n\n  onFileChange(handler: FileChangeHandler): void {\n    this.fileChangeHandlers.push(handler);\n  }\n\n  onProgress(handler: ProgressHandler): void {\n    this.progressHandlers.push(handler);\n  }\n\n  onError(handler: ErrorHandler): void {\n    this.errorHandlers.push(handler);\n  }\n\n  onComplete(handler: CompleteHandler): void {\n    this.completeHandlers.push(handler);\n  }\n\n  // Set current process for tracking\n  setCurrentProcess(processId: string): void {\n    this.currentProcessId = processId;\n  }\n}\n```\n\n## Usage Example\n\n```typescript\n// Create processor\nconst processor = new StreamJsonProcessor({\n  format: 'stream-json',\n  captureToolCalls: true,\n  captureFileChanges: true,\n  emitProgressEvents: true,\n});\n\n// Set up event listeners\nprocessor.onToolCall((processId, toolCall) => {\n  console.log(`[${processId}] Tool: ${toolCall.name}`, toolCall.input);\n});\n\nprocessor.onFileChange((processId, filePath) => {\n  console.log(`[${processId}] File changed: ${filePath}`);\n});\n\nprocessor.onProgress((processId, progress) => {\n  console.log(`[${processId}] Progress:`, {\n    toolCalls: progress.toolCalls.length,\n    filesChanged: progress.filesChanged.length,\n    activity: progress.currentActivity,\n  });\n});\n\nprocessor.onComplete((processId, metadata) => {\n  console.log(`[${processId}] Complete:`, metadata);\n});\n\n// Integrate with process manager\nconst processManager = new SimpleProcessManager();\nconst process = await processManager.acquireProcess({\n  claudePath: 'claude',\n  workDir: '/path/to/project',\n  args: {\n    print: true,\n    outputFormat: 'stream-json',\n    dangerouslySkipPermissions: true,\n  },\n});\n\nprocessor.setCurrentProcess(process.id);\n\n// Process output as it streams\nprocessManager.onOutput(process.id, (data, type) => {\n  if (type === 'stdout') {\n    const lines = data.toString().split('\\n');\n    for (const line of lines) {\n      processor.processLine(line);\n    }\n  }\n});\n\n// Send input\nawait processManager.sendInput(process.id, 'Fix the bug in auth.ts\\n');\n```\n\n## Testing Strategy\n\n### Unit Tests\n\n1. **JSON parsing**\n   - Parses valid stream-json lines\n   - Handles malformed JSON gracefully\n   - Detects message types correctly\n\n2. **Metadata extraction**\n   - Extracts tool calls from messages\n   - Extracts file changes from Write/Edit tools\n   - Calculates usage and cost correctly\n\n3. **Event emission**\n   - Emits tool call events\n   - Emits file change events\n   - Emits progress events at interval\n\n### Integration Tests\n\n1. **End-to-end processing**\n   - Process real Claude Code output\n   - Track progress accurately\n   - Extract complete metadata\n\n2. **Real-time streaming**\n   - Handle partial lines\n   - Process incomplete JSON\n   - Buffer management\n\n## Future Enhancements\n\n1. **Format adapters** - Support text, JSON formats\n2. **Filtering** - Filter events by type/pattern\n3. **Aggregation** - Aggregate metrics across processes\n4. **Persistence** - Store output for replay\n5. **Compression** - Compress large outputs\n\n## File Structure\n\n```\nserver/src/execution/output/\n├── types.ts                    # Core types (StreamMessage, etc.)\n├── processor.ts                # IOutputProcessor interface\n├── stream-json-processor.ts    # StreamJsonProcessor (start here)\n├── text-processor.ts           # TextProcessor (future)\n└── utils.ts                    # JSON parsing, cost calculation\n```\n\n## Implementation Checklist\n\n- [ ] Define core types\n- [ ] Define IOutputProcessor interface\n- [ ] Implement StreamJsonProcessor\n- [ ] Add line-by-line JSON parsing\n- [ ] Add message type detection\n- [ ] Add tool call extraction\n- [ ] Add file change tracking\n- [ ] Add progress tracking\n- [ ] Add event emission\n- [ ] Add metadata extraction\n- [ ] Write unit tests\n- [ ] Write integration tests\n\n## Related Specs\n\n- Execution System (root spec)\n- [[SPEC-003]] - Process Layer (integrates with)\n- [[SPEC-004]] - Engine Layer\n- [[SPEC-005]] - Task Execution Layer\n- [[SPEC-006]] - Workflow Layer","priority":0,"archived":0,"archived_at":null,"created_at":"2025-10-28 07:45:45","updated_at":"2025-10-28 07:45:45","parent_id":null,"relationships":[],"tags":["execution","layer-5","output-processing","parsing","streaming"]}
